
/***************************************************************************
 *   Copyright (C) 2016 by Sean D'Epagnier                                 *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
 ***************************************************************************/


// Whenever positions  change  m_PositionPanel->PopulatePositions();
// Whenever routes change  m_RouteMapPanel->PopulateRoutes();


#include <wx/wx.h>
#include <wx/aui/aui.h>
#include <wx/imaglist.h>
#include <wx/progdlg.h>
#include <wx/dir.h>
#include <wx/log.h>
#include <wx/glcanvas.h>

#include <stdlib.h>
#include <math.h>
#include <cmath>
#include <time.h>
#include <algorithm>

#include "Utilities.h"
#include "Boat.h"
#include "BoatDialog.h"
#include "RouteMapOverlay.h"
#include "weather_routing_pi.h"
#include "WeatherRouting.h"
#include "RouteSimplifier.h"
#include "AboutDialog.h"
#include "icons.h"
#include "navobj_util.h"
#include "ocpn_plugin.h"
#include "Position.h"
#include "tinyxml.h"
#include "MemoryStatusDialog.h"
#include "RouteMapPanel.h"
#include "WeatherRoutingConfigDialog.h"

// Declare the custom event for route map updates
// This event is used by RouteMapOverlay threads to notify WeatherRouting of
// progress. it is a thread-safe event and can be sent from any thread. The
// event handler.  Globally defined event type that worker threads can post and
// the WeatherRouting can Recieve. It is in the heart of the thread to UI pipeline.
// Also the main thread event handler for this event is the main point
// where the UI gets updated based on background thread progress, so it is a
// critical part of the plugin's architecture.

wxDEFINE_EVENT(EVT_ROUTEMAP_UPDATE, wxThreadEvent);


// Column names
const wxString WeatherRouting::column_names[NUM_COLS] = {_("Visible"),
                                                         _("Boat"),
                                                         _("Start Type"),
                                                         _("Start"),
                                                         _("Start Time"),
                                                         _("End"),
                                                         _("End Time"),
                                                         _("Time"),
                                                         _("Distance"),
                                                         _("Avg Speed"),
                                                         _("Max Speed"),
                                                         _("Avg Speed Ground"),
                                                         _("Max Speed Ground"),
                                                         _("Avg Wind"),
                                                         _("Max Wind"),
                                                         _("Max Wind Gust"),
                                                         _("Avg Current"),
                                                         _("Max Current"),
                                                         _("Avg Swell"),
                                                         _("Max Swell"),
                                                         _("Upwind Percentage"),
                                                         _("Port Starboard"),
                                                         _("Tacks"),
                                                         _("Jibes"),
                                                         _("Sail Plan Changes"),
                                                         _("Comfort"),
                                                         _("State")};

/**
 * Used for NEflag argument to toSDMM_Plugin function from ocpn_plugin.h.
 * @todo Should probably be declared there instead, and probably be a boolean.
 */
enum NEflag {
  LAT = 1,
  LON = 2,
};

/**
 * Used for precision argument to toSDMM_Plugin function from ocpn_plugin.h.
 **/

enum Precision {
  LO = 0,
  HI = 1,
};

/* XPM */
static const char* eye[] = {"20 20 7 1",
                            ". c none",
                            "# c #000000",
                            "a c #333333",
                            "b c #666666",
                            "c c #999999",
                            "d c #cccccc",
                            "e c #ffffff",
                            "....................",
                            "....................",
                            "....................",
                            "....................",
                            ".......######.......",
                            ".....#aabccb#a#.....",
                            "....#deeeddeebcb#...",
                            "..#aeeeec##aceaec#..",
                            ".#bedaeee####dbcec#.",
                            "#aeedbdabc###bcceea#",
                            ".#bedad######abcec#.",
                            "..#be#d######dadb#..",
                            "...#abac####abba#...",
                            ".....##acbaca##.....",
                            ".......######.......",
                            "....................",
                            "....................",
                            "....................",
                            "....................",
                            "...................."};



WeatherRoute::WeatherRoute(WeatherRouting* parent)
    : m_parent(parent), routemapoverlay(new RouteMapOverlay(parent, this)) {}


WeatherRoute::~WeatherRoute() { delete routemapoverlay; }

static int sortcol, sortorder = 1;
// sort callback. Sort by body.
#if wxCHECK_VERSION(2, 9, 0)
int wxCALLBACK SortWeatherRoutes(wxIntPtr item1, wxIntPtr item2, wxIntPtr list)
#else
int wxCALLBACK SortWeatherRoutes(long item1, long item2, long list)
#endif
{
  wxListCtrl* lc = (wxListCtrl*)list;

  wxListItem it1, it2;

  it1.SetId(lc->FindItem(-1, item1));
  it1.SetColumn(sortcol);

  it2.SetId(lc->FindItem(-1, item2));
  it2.SetColumn(sortcol);

  lc->GetItem(it1);
  lc->GetItem(it2);

  return sortorder * it1.GetText().Cmp(it2.GetText());
}


//==============================================================
// CONSTRUCTOR  weatherrouting
//==============================================================

WeatherRouting::WeatherRouting(wxWindow* parent, weather_routing_pi& plugin)
    : WeatherRoutingBase(parent),
      m_weather_routing_pi(plugin),
      m_ConfigurationDialog(*this),
      m_ConfigurationBatchDialog(this),
      m_CursorPositionDialog(this),
      m_RoutePositionDialog(this),
      m_BoatDialog(*this),
      m_SettingsDialog(this),
      m_StatisticsDialog(this),
      m_ReportDialog(*this),
      m_PlotDialog(*this),
      m_FilterRoutesDialog(this),
      m_RoutingTablePanel(nullptr),
      m_panel(NULL),
      m_bShowConfiguration(false), // ADD THIS
      m_bShowConfigurationBatch(false),
      m_bShowSettings(false),
      m_bShowStatistics(false),
      m_bShowReport(false),
      m_bShowPlot(false),
      m_bShowFilter(false),
      m_bShowRoutePosition(false)
{
  wxLogMessage("WR: ctor START");

  // Load configuration, settings, etc.
  wxLogMessage("WR: before LoadConfigurationAndData");
  LoadConfigurationAndData();
  wxLogMessage("WR: after LoadConfigurationAndData");

  // Create the overlay FIRST before calling InitializUI
  // since some UI elements depend on it(e.g.RoutePositionDialog)
  m_pRouteMapOverlay = new RouteMapOverlay(this, nullptr);

  // Build the UI
  wxLogMessage("WR: before InitializeUI");
  InitializeUI();
  wxLogMessage("WR: after InitializeUI");

  // Bind events AFTER panels exist
  wxLogMessage("WR: before BindEvents");
  BindEvents();
  wxLogMessage("WR: after BindEvents");

  // Any remaining initialization
  m_tAutoSaveXML.SetOwner(this);
  wxLogMessage("WR: ctor END");
}


//==============================================================
// LOAD CONFIGURATION AND PLUGIN DATA AND USER SETTINGS
//==============================================================

void WeatherRouting::LoadConfigurationAndData() {
  wxFileConfig* pConf = GetOCPNConfigObject();
  pConf->SetPath("/PlugIns/WeatherRouting");

  // ---------------------------------------------------------
  // 1. Determine standard paths
  // ---------------------------------------------------------
  m_default_configuration_path =
      weather_routing_pi::StandardPath() + "WeatherRoutingConfiguration.xml";

  wxString packagedCfg = GetPluginDataDir("weather_routing_pi") +
                         "/data/WeatherRoutingConfiguration.xml";

  // ---------------------------------------------------------
  // 2. Ensure boats/ and polars/ directories exist
  // ---------------------------------------------------------
  wxString boatsdir = weather_routing_pi::StandardPath() + "/boats";
  wxString polarsdir = weather_routing_pi::StandardPath() + "/polars";

  bool forceCopyBoats = !wxFileName::DirExists(boatsdir);
  bool forceCopyPolars = !wxFileName::DirExists(polarsdir);

  wxFileName fn;
  fn.Mkdir(weather_routing_pi::StandardPath(), wxS_DIR_DEFAULT,
           wxPATH_MKDIR_FULL);
  fn.Mkdir(boatsdir, wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL);
  fn.Mkdir(polarsdir, wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL);

  // ---------------------------------------------------------
  // 3. Copy boats/polars if directories were missing
  // ---------------------------------------------------------
  if (forceCopyBoats)
    CopyDataFiles(GetPluginDataDir("weather_routing_pi") + "/data/boats",
                  boatsdir);

  if (forceCopyPolars)
    CopyDataFiles(GetPluginDataDir("weather_routing_pi") + "/data/polars",
                  polarsdir);

  // ---------------------------------------------------------
  // 4. Handle versioned data updates (boats, polars, examples)
  // ---------------------------------------------------------
  int confVersion;
  pConf->Read("ConfigVersion", &confVersion, 0);

#ifndef __OCPN__ANDROID__
  int currentVersion = PLUGIN_VERSION_MAJOR * 100 + PLUGIN_VERSION_MINOR;

  if (confVersion < currentVersion) {
    wxString title = _("New or updated data available");
    wxString message = _(
        "A new version of the Weather Route plugin has been installed.\n\n"
        "\"Import new boats and polars\" will overwrite the standard boats\n"
        "and polars with newer data. If you have modified this data and not\n"
        "changed the names, your modifications will be overwritten.\n\n"
        "\"Import example configurations\" will overwrite your route\n"
        "configurations with a sample set showing how WeatherRouting works.\n");

    wxString choices[2] = {_("Import new boats and polars"),
                           _("Import example configurations")};

    wxMultiChoiceDialog dlg(this, message, title, 2, choices);

    // First-time users: select both options by default
    if (confVersion == 0) {
      wxArrayInt sel;
      sel.Add(0);
      sel.Add(1);
      dlg.SetSelections(sel);
    }

    if (dlg.ShowModal() == wxID_OK) {
      wxArrayInt result = dlg.GetSelections();

      for (size_t i = 0; i < result.GetCount(); i++) {
        if (result[i] == 0) {
          CopyDataFiles(GetPluginDataDir("weather_routing_pi") + "/data/boats",
                        boatsdir);
          CopyDataFiles(GetPluginDataDir("weather_routing_pi") + "/data/polars",
                        polarsdir);
        } else if (result[i] == 1) {
          if (wxFileName::FileExists(packagedCfg))
            wxCopyFile(packagedCfg, m_default_configuration_path);
        }
      }

      // Path may change after modal dialog
      pConf->SetPath("/PlugIns/WeatherRouting");
      pConf->Write("ConfigVersion", currentVersion);
    }
  }
#endif

  // ---------------------------------------------------------
  // 5. Load plugin settings
  // ---------------------------------------------------------
  m_SettingsDialog.LoadSettings();

  // ---------------------------------------------------------
  // 6. Read UI flags
  // ---------------------------------------------------------
  pConf->SetPath("/PlugIns/WeatherRouting");
  pConf->Read("DisableColPane", &m_disable_colpane, false);

#ifdef __OCPN__ANDROID__
  m_disable_colpane = true;
#endif
}

/*
//==============================================================
// Initialize the user interface
//==============================================================

void WeatherRouting::InitializeUI() {
  wxLogMessage("WR: InitializeUI() starting");

  wxFileConfig* pConf = GetOCPNConfigObject();
  pConf->SetPath("/PlugIns/WeatherRouting");

  // ---------------------------------------------------------
  // Load the plugin icon for dialogs that need it
  // ---------------------------------------------------------
  wxIcon icon;
  icon.CopyFromBitmap(*_img_WeatherRouting);

  // ---------------------------------------------------------
  // MAIN LAYOUT: Horizontal split
  //
  //  LEFT  = configuration panel (collapsible or not)
  //  RIGHT = routing table panel
  //
  // This guarantees that both panels share the same parent (this),
  // which is required for wxSizer::SetContainingWindow to succeed.
  // ---------------------------------------------------------
  wxBoxSizer* mainSizer = new wxBoxSizer(wxHORIZONTAL);
  SetSizer(mainSizer);  // <-- This window ("this") owns mainSizer

  // ---------------------------------------------------------
  // LEFT SIDE: Configuration UI
  //
  // We build a vertical sizer that will contain either:
  //   - a collapsible pane containing WeatherRoutingPanel, OR
  //   - WeatherRoutingPanel directly (if collapsible pane disabled)
  //
  // All children created here MUST have parents consistent with
  // the window that ultimately receives this sizer.
  // ---------------------------------------------------------
  wxBoxSizer* leftSizer = new wxBoxSizer(wxVERTICAL);

  if (!m_disable_colpane) {
    // Create collapsible pane as a child of "this"
    m_colpane = new wxCollapsiblePane(this, wxID_ANY, _("Weather Routing"));
    leftSizer->Add(m_colpane, 1, wxEXPAND | wxALL, 5);

    // The collapsible pane contains its own internal window
    m_colpaneWindow = m_colpane->GetPane();

    // Sizer for the collapsible pane's internal window
    wxBoxSizer* paneSz = new wxBoxSizer(wxVERTICAL);
    m_colpaneWindow->SetSizer(paneSz);

    // Create the main configuration panel INSIDE the collapsible pane
    m_PositionsPanel = new WeatherRoutingPositionsPanel(this, *this);
    leftSizer->Add(m_PositionsPanel, 1, wxEXPAND | wxALL, 5);

    m_colpane->Expand();  // Start expanded by default
  } else {
    // No collapsible pane ? panel attaches directly to this window
    m_colpane = nullptr;
    m_colpaneWindow = this;

    m_panel = new WeatherRoutingPanel(m_colpaneWindow);
    leftSizer->Add(m_panel, 1, wxEXPAND | wxALL, 5);
  }

  leftSizer->SetSizeHints(this);

  // ---------------------------------------------------------
  // RIGHT SIDE: Routing Table Panel
  //
  // This panel MUST be a direct child of "this" because its sizer
  // will be attached to "this" through mainSizer.
  // ---------------------------------------------------------
  m_panel = new WeatherRoutingPanel(m_colpaneWindow);
  paneSz->Add(m_panel, 1, wxEXPAND, 0);
  paneSz->SetSizeHints(m_colpaneWindow);

 // m_RoutingTablePanel = new RoutingTablePanel(this, *this, nullptr);

  wxBoxSizer* rightSizer = new wxBoxSizer(wxVERTICAL);
  rightSizer->Add(m_RoutingTablePanel, 1, wxEXPAND | wxALL, 5);

  // ---------------------------------------------------------
  // Attach LEFT and RIGHT to the main horizontal sizer
  // ---------------------------------------------------------
  mainSizer->Add(leftSizer, 0, wxEXPAND);
  mainSizer->Add(rightSizer, 1, wxEXPAND);

  // ---------------------------------------------------------
  // Configure list columns and icons
  // ---------------------------------------------------------
  m_panel->m_lPositions->InsertColumn(POSITION_NAME, _("Name"));
  m_panel->m_lPositions->InsertColumn(POSITION_LAT, _("Lat"));
  m_panel->m_lPositions->InsertColumn(POSITION_LON, _("Lon"));

  wxImageList* imglist = new wxImageList(20, 20, true, 1);
  imglist->Add(wxBitmap(eye));
  m_panel->m_lWeatherRoutes->AssignImageList(imglist, wxIMAGE_LIST_SMALL);

  UpdateColumns();

  // ---------------------------------------------------------
  // Load XML configuration (routes, boats, settings)
  // ---------------------------------------------------------
  // May not be necessary to load XML before initializing the UI, but some
  // dialogs (e.g., RoutePositionDialog) depend on the overlay existing, and the
  // overlay to be initialized with the configuration. So we load XML first to
  // ensure the that the configuration is fully loaded before any UI elements
  // that depend on it are initialized. This also allows the UI to reflect the
  // loaded configuration immediately upon initialization.
  // However this is a bit of a chicken-and-egg problem because some dialogs
  // (e.g., RoutePositionDialog) are initialized in InitializeUI and depend on
  // the configuration being loaded,
  // This interupts the RouteMapPanel showing.
  // wxLogMessage("WR: Calling OpenXML()");
  // OpenXML(m_default_configuration_path, false);

  // ---------------------------------------------------------
  // Restore window geometry
  // ---------------------------------------------------------
  wxPoint pos = GetPosition();
  pConf->Read("DialogX", &pos.x, pos.x);
  pConf->Read("DialogY", &pos.y, pos.y);

  m_size = GetSize();
  pConf->Read("DialogWidth", &m_size.x, wxMax(m_size.x, 100));
  pConf->Read("DialogHeight", &m_size.y, wxMax(m_size.y, 100));

  SetSize(pos.x, pos.y, m_size.x, m_size.y);

  pConf->Read("DialogSplit", &sashpos, 0);

  // ---------------------------------------------------------
  // Initialize dialogs that require two-phase UI setup
  // ---------------------------------------------------------
  m_ConfigurationDialog.SetIcon(icon);
  m_ConfigurationDialog.InitUI();

  m_BoatDialog.SetIcon(icon);
  m_BoatDialog.InitUI();

  m_ReportDialog.SetIcon(icon);
  m_ReportDialog.InitUI();

  m_PlotDialog.SetIcon(icon);
  m_PlotDialog.InitUI();

  // Batch dialog depends on m_panel existing
  m_ConfigurationBatchDialog.Reset();

  SetEnableConfigurationMenu();

  wxLogMessage("WR: InitializeUI() completed");
}

*/

void WeatherRouting::InitializeUI() {
  // ---------------------------------------------------------
  // MAIN FRAME SETUP
  // ---------------------------------------------------------
  wxBoxSizer* topSizer = new wxBoxSizer(wxVERTICAL);

  // ---------------------------------------------------------
  // MENU BAR
  // ---------------------------------------------------------
  wxMenuBar* menuBar = new wxMenuBar;

  // FILE MENU
  wxMenu* fileMenu = new wxMenu;
  fileMenu->Append(ID_FILE_OPEN, _("Open"));
  fileMenu->Append(ID_FILE_SAVE, _("Save"));
  fileMenu->Append(ID_FILE_SAVEAS, _("Save As"));
  fileMenu->AppendSeparator();
  fileMenu->Append(ID_FILE_CLOSE, _("Close"));
  menuBar->Append(fileMenu, _("File"));

  // POSITION MENU
  wxMenu* positionMenu = new wxMenu;
  positionMenu->Append(ID_POSITION_NEW, _("New Position"));
  positionMenu->Append(ID_POSITION_EDIT, _("Edit Position"));
  positionMenu->Append(ID_POSITION_UPDATE_BOAT, _("Update Boat Position"));
  positionMenu->Append(ID_POSITION_DELETE, _("Delete"));
  positionMenu->Append(ID_POSITION_DELETE_ALL, _("Delete All"));
  menuBar->Append(positionMenu, _("Position"));

  // ROUTINGS MENU
  wxMenu* routingMenu = new wxMenu;
  routingMenu->Append(ID_ROUTING_NEW, _("New"));
  routingMenu->Append(ID_ROUTING_BATCH, _("Batch"));
  routingMenu->Append(ID_ROUTING_EDIT, _("Edit"));
  routingMenu->Append(ID_ROUTING_GOTO, _("Goto"));
  routingMenu->Append(ID_ROUTING_DELETE, _("Delete"));
  routingMenu->Append(ID_ROUTING_DELETE_ALL, _("Delete All"));
  routingMenu->AppendSeparator();
  routingMenu->Append(ID_ROUTING_COMPUTE, _("Compute"));
  routingMenu->Append(ID_ROUTING_COMPUTE_ALL, _("Compute All"));
  routingMenu->Append(ID_ROUTING_STOP, _("Stop"));
  routingMenu->Append(ID_ROUTING_RESET_ALL, _("Reset All"));
  routingMenu->AppendSeparator();
  routingMenu->Append(ID_ROUTING_SAVE_TRACK, _("Save as Track"));
  routingMenu->Append(ID_ROUTING_SAVE_ALL_TRACKS, _("Save All as Tracks"));
  routingMenu->Append(ID_ROUTING_SAVE_ROUTE, _("Save as Route"));
  routingMenu->Append(ID_ROUTING_EXPORT_GPX, _("Export Routing as GPX"));
  routingMenu->Append(ID_ROUTING_FILTER, _("Filter"));
  menuBar->Append(routingMenu, _("Routings"));

  // VIEW MENU
  wxMenu* viewMenu = new wxMenu;
  viewMenu->Append(ID_VIEW_SETTINGS, _("Settings"));
  viewMenu->Append(ID_VIEW_STATISTICS, _("Statistics"));
  viewMenu->Append(ID_VIEW_REPORT, _("Report"));
  viewMenu->Append(ID_VIEW_PLOT, _("Plot"));
  viewMenu->Append(ID_VIEW_CURSOR_POSITION, _("Cursor Position"));
  viewMenu->Append(ID_VIEW_ROUTE_POSITION, _("Route Position"));
  viewMenu->Append(ID_VIEW_ROUTING_TABLE, _("Weather Routing Table"));
  menuBar->Append(viewMenu, _("View"));

  // HELP MENU
  wxMenu* helpMenu = new wxMenu;
  helpMenu->Append(ID_HELP_INFORMATION, _("Information"));
  helpMenu->Append(ID_HELP_MANUAL, _("Manual"));
  helpMenu->Append(ID_HELP_ABOUT, _("About"));
  menuBar->Append(helpMenu, _("Help"));

  // Temporarily disable menu bar until base class is confirmed
  // Later, if you decide WeatherRoutingBase should be a wxFrame, we can re?enable the menu bar
  // SetMenuBar(menuBar);

  // ---------------------------------------------------------
  // MAIN CONTENT AREA (LEFT + RIGHT PANELS)
  // ---------------------------------------------------------
  wxBoxSizer* mainSizer = new wxBoxSizer(wxHORIZONTAL);

  // ---------------------------------------------------------
  // LEFT PANEL ? POSITIONS
  // ---------------------------------------------------------
  wxBoxSizer* leftSizer = new wxBoxSizer(wxVERTICAL);

  wxStaticText* posLabel = new wxStaticText(this, wxID_ANY, _("Positions"));
  posLabel->SetFont(posLabel->GetFont().Bold());
  leftSizer->Add(posLabel, 0, wxLEFT | wxTOP | wxBOTTOM, 5);

  // Create new left panel
  m_PositionPanel = new WeatherRoutingPositionPanel(this, *this);
  leftSizer->Add(m_PositionPanel, 1, wxEXPAND | wxALL, 5);

  // ---------------------------------------------------------
  // RIGHT PANEL ? ROUTINGS
  // ---------------------------------------------------------

    wxBoxSizer* rightSizer = new wxBoxSizer(wxVERTICAL);

  wxStaticText* routeLabel = new wxStaticText(this, wxID_ANY, _("Routings"));
  routeLabel->SetFont(routeLabel->GetFont().Bold());
  rightSizer->Add(routeLabel, 0, wxLEFT | wxTOP | wxBOTTOM, 5);

  // Create new right panel
  m_panel = new WeatherRoutingPanel(
      this,  // wxWindow*
      wxID_ANY,      // wxWindowID
      wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL,
       _("Weather Routing Panel"));
  rightSizer->Add(m_panel, 1, wxEXPAND | wxALL, 5);

  // ---------------------------------------------------------
  // BUTTON ROW UNDER ROUTINGS PANEL
  // ---------------------------------------------------------
  wxBoxSizer* buttonRow = new wxBoxSizer(wxHORIZONTAL);

  m_btnCompute = new wxButton(this, ID_ROUTING_COMPUTE, _("Compute"));
  m_btnSaveTrack = new wxButton(this, ID_ROUTING_SAVE_TRACK, _("Save as Track"));
  m_btnSaveRoute = new wxButton(this, ID_ROUTING_SAVE_ROUTE, _("Save as Route"));
  m_btnExportGPX = new wxButton(this, ID_ROUTING_EXPORT_GPX, _("Export as GPX Route"));
  m_btnReset = new wxButton(this, ID_ROUTING_RESET, _("Reset"));  // Your addition
  m_btnGotoRouting = new wxButton(this, ID_GOTO_ROUTING, _("Goto Routing"));  //

  buttonRow->Add(m_btnCompute, 0, wxRIGHT, 5);
  buttonRow->Add(m_btnSaveTrack, 0, wxRIGHT, 5);
  buttonRow->Add(m_btnSaveRoute, 0, wxRIGHT, 5);
  buttonRow->Add(m_btnExportGPX, 0, wxRIGHT, 5);
  buttonRow->Add(m_btnReset, 0);

  rightSizer->Add(buttonRow, 0, wxALIGN_LEFT | wxALL, 5);

  // ---------------------------------------------------------
  // ADD LEFT + RIGHT PANELS TO MAIN SIZER
  // ---------------------------------------------------------
  mainSizer->Add(leftSizer, 0, wxEXPAND | wxALL, 5);
  mainSizer->Add(rightSizer, 1, wxEXPAND | wxALL, 5);

  topSizer->Add(mainSizer, 1, wxEXPAND);

  SetSizer(topSizer);
  Layout();


  // ======================================================================
  // EVENT BINDINGS FOR NEW UI
  // ======================================================================

  // ---------------------------------------------------------
  // MENU BINDINGS
  // ---------------------------------------------------------


  // FILE
  Bind(wxEVT_MENU, &WeatherRouting::OnFileOpen, this, ID_FILE_OPEN);
  Bind(wxEVT_MENU, &WeatherRouting::OnFileSave, this, ID_FILE_SAVE);
  Bind(wxEVT_MENU, &WeatherRouting::OnFileSaveAs, this, ID_FILE_SAVEAS);
  Bind(wxEVT_MENU, &WeatherRouting::OnFileClose, this, ID_FILE_CLOSE);

  // POSITION
  Bind(wxEVT_MENU, &WeatherRouting::OnNewPosition, this, ID_POSITION_NEW);
//  Bind(wxEVT_MENU, &WeatherRouting::OnEditPosition, this, ID_POSITION_EDIT);
//Use onUpdateBoat?
//  Bind(wxEVT_MENU, &WeatherRouting::OnUpdateBoatPosition, this, ID_POSITION_UPDATE_BOAT);
  Bind(wxEVT_MENU, &WeatherRouting::OnDeletePosition, this, ID_POSITION_DELETE);
  Bind(wxEVT_MENU, &WeatherRouting::OnDeleteAllPositions, this, ID_POSITION_DELETE_ALL);
// Use OnGoto?	   
  Bind(wxEVT_MENU, &WeatherRouting::OnGotoRouting, this, ID_GOTO_ROUTING); 


  // ROUTINGS
  Bind(wxEVT_MENU, &WeatherRouting::OnNewRouting, this, ID_ROUTING_NEW);
  Bind(wxEVT_MENU, &WeatherRouting::OnBatchRouting, this, ID_ROUTING_BATCH);
 //We don't have this yet. 
// Bind(wxEVT_MENU, &WeatherRouting::OnEditRouting, this, ID_ROUTING_EDIT);  
  Bind(wxEVT_MENU, &WeatherRouting::OnGotoRouting, this, ID_ROUTING_GOTO);
  Bind(wxEVT_MENU, &WeatherRouting::OnDeleteRouting, this, ID_ROUTING_DELETE);
  Bind(wxEVT_MENU, &WeatherRouting::OnDeleteAllRoutings, this, ID_ROUTING_DELETE_ALL);

  Bind(wxEVT_MENU, &WeatherRouting::OnCompute, this, ID_ROUTING_COMPUTE);
  Bind(wxEVT_MENU, &WeatherRouting::OnComputeAll, this, ID_ROUTING_COMPUTE_ALL);
  Bind(wxEVT_MENU, &WeatherRouting::OnStop, this, ID_ROUTING_STOP);
  Bind(wxEVT_MENU, &WeatherRouting::OnResetAll, this, ID_ROUTING_RESET_ALL);
 //We don't have this yet.
//  Bind(wxEVT_MENU, &WeatherRouting::OnToggleVisibility, this, ID_TOGGLE_VISIBILITY);


//  Bind(wxEVT_MENU, &WeatherRouting::OnSaveAsTrack, this, ID_ROUTING_SAVE_TRACK);
// We don't have this yet.
//  Bind(wxEVT_MENU, &WeatherRouting::OnSaveAllTracks, this,ID_ROUTING_SAVE_ALL_TRACKS);


  Bind(wxEVT_MENU, &WeatherRouting::OnSaveAsRoute, this, ID_ROUTING_SAVE_ROUTE); 
// We don't have this yet.
//  Bind(wxEVT_MENU, &WeatherRouting::OnExportGPX, this, ID_ROUTING_EXPORT_GPX);  
  Bind(wxEVT_MENU, &WeatherRouting::OnFilter, this, ID_ROUTING_FILTER);

  // VIEW
  Bind(wxEVT_MENU, &WeatherRouting::OnSettings, this, ID_VIEW_SETTINGS);
  Bind(wxEVT_MENU, &WeatherRouting::OnStatistics, this, ID_VIEW_STATISTICS);
  Bind(wxEVT_MENU, &WeatherRouting::OnReport, this, ID_VIEW_REPORT);
  Bind(wxEVT_MENU, &WeatherRouting::OnPlot, this, ID_VIEW_PLOT);
  Bind(wxEVT_MENU, &WeatherRouting::OnCursorPosition, this,ID_VIEW_CURSOR_POSITION);
  Bind(wxEVT_MENU, &WeatherRouting::OnRoutePosition, this, D_VIEW_ROUTE_POSITION);
// not implemented yet
//  Bind(wxEVT_MENU, &WeatherRouting::OnRoutingTable, this, ID_VIEW_ROUTING_TABLE);

  // HELP
  Bind(wxEVT_MENU, &WeatherRouting::OnInformation, this, ID_HELP_INFORMATION);
  Bind(wxEVT_MENU, &WeatherRouting::OnManual, this, ID_HELP_MANUAL);
  Bind(wxEVT_MENU, &WeatherRouting::OnAbout, this, ID_HELP_ABOUT);

  // ======================================================================
  // BUTTON BINDINGS (new button row)
  // ======================================================================

  m_btnCompute->Bind(wxEVT_BUTTON, &WeatherRouting::OnCompute, this);
 // m_btnSaveTrack->Bind(wxEVT_BUTTON, &WeatherRouting::OnSaveAsTrack, this);
 // m_btnSaveRoute->Bind(wxEVT_BUTTON, &WeatherRouting::OnSaveAsRoute, this);
 // m_btnExportGPX->Bind(wxEVT_BUTTON, &WeatherRouting::OnExportGPX, this);
  m_btnReset->Bind(wxEVT_BUTTON, &WeatherRouting::OnResetRouting, this);
  m_btnGotoRouting->Bind(wxEVT_BUTTON, &WeatherRouting::OnGotoRouting, this);

  // ======================================================================
  // LIST CONTROL BINDINGS
  // ======================================================================

  // POSITIONS LIST (left panel)
  m_PositionPanel->m_lPositions->Bind(
      wxEVT_LEFT_DCLICK, &WeatherRouting::OnEditPositionClick, this);

//  m_PositionPanel->m_lPositions->Bind(
//      wxEVT_LIST_ITEM_SELECTED, &WeatherRouting::OnPositionSelected, this);

  // ROUTINGS LIST (right panel)
  m_panel->m_lWeatherRoutes->Bind(
      wxEVT_LEFT_DCLICK, &WeatherRouting::OnEditConfigurationClick, this);

 m_panel->m_lWeatherRoutes->Bind(
     wxEVT_LIST_COL_CLICK, &WeatherRouting::OnWeatherRouteSort, this);

//  m_panel->m_lWeatherRoutes->Bind(
//      wxEVT_LIST_ITEM_SELECTED, &WeatherRouting::OnWeatherRouteSelected, this);

//  m_panel->m_lWeatherRoutes->Bind(
//      wxEVT_LIST_ITEM_DESELECTED, &WeatherRouting::OnWeatherRouteSelected, this);

}



//============================================================
// Bind all event handlers
//==============================================================

void WeatherRouting::BindEvents() {

  // ---------------------------------------------------------
  // System-Level Events
  // ---------------------------------------------------------
  // BIND OnRouteMapUpdate to EVT_ROUTEMAP_UPDATE
  //   // Route map update from RouteMapOverlay threads this is how
  // RouteMapOverlay notifies WeatherRouting of progress
  // It is a thread-safe event and can be sent from any thread
  // The event handler will be called in the main thread context, allowing safe
  // UI updates

  Bind(EVT_ROUTEMAP_UPDATE, &WeatherRouting::OnRouteMapUpdate, this);

#ifdef PLUGIN_USE_ASM
  Bind(EVT_MEMORY_ALERT_STOP, &WeatherRouting::OnMemoryAlertStop, this);
  Bind(EVT_MEMORY_AUTO_RESET, &WeatherRouting::OnMemoryAutoReset, this);
#endif

  // ---------------------------------------------------------
  // Timers
  // ---------------------------------------------------------
  m_tCompute.Connect(wxEVT_TIMER,
                     wxTimerEventHandler(WeatherRouting::OnComputationTimer),
                     nullptr, this);

  m_tHideConfiguration.Connect(
      wxEVT_TIMER,
      wxTimerEventHandler(WeatherRouting::OnHideConfigurationTimer), nullptr,
      this);

  m_tAutoSaveXML.Connect(
      wxEVT_TIMER, wxTimerEventHandler(WeatherRouting::OnAutoSaveXMLTimer),
      nullptr, this);

  Connect(wxEVT_IDLE, wxTimerEventHandler(WeatherRouting::OnRenderedTimer),
          nullptr, this);

  // ---------------------------------------------------------
  // UI Events
  // ---------------------------------------------------------
  if (m_colpane) {
    m_colpane->Connect(
        wxEVT_COLLAPSIBLEPANE_CHANGED,
        wxCollapsiblePaneEventHandler(WeatherRouting::OnCollPaneChanged),
        nullptr, this);
  }

  // Positions list
  m_panel->m_lPositions->Connect(
      wxEVT_LEFT_DCLICK,
      wxMouseEventHandler(WeatherRouting::OnEditPositionClick), nullptr, this);

  // WeatherRoutes list
  m_panel->m_lWeatherRoutes->Connect(
      wxEVT_LEFT_DCLICK,
      wxMouseEventHandler(WeatherRouting::OnEditConfigurationClick), nullptr,
      this);

  m_panel->m_lWeatherRoutes->Connect(
      wxEVT_COMMAND_LIST_COL_CLICK,
      wxListEventHandler(WeatherRouting::OnWeatherRouteSort), nullptr, this);

  m_panel->m_lWeatherRoutes->Connect(
      wxEVT_COMMAND_LIST_ITEM_SELECTED,
      wxListEventHandler(WeatherRouting::OnWeatherRouteSelected), nullptr,
      this);

  m_panel->m_lWeatherRoutes->Connect(
      wxEVT_COMMAND_LIST_ITEM_DESELECTED,
      wxListEventHandler(WeatherRouting::OnWeatherRouteSelected), nullptr,
      this);

  // Buttons
  m_panel->m_bCompute->Connect(wxEVT_COMMAND_BUTTON_CLICKED,
                               wxCommandEventHandler(WeatherRouting::OnCompute),
                               nullptr, this);

  m_panel->m_bSaveAsTrack->Connect(
      wxEVT_COMMAND_BUTTON_CLICKED,
      wxCommandEventHandler(WeatherRouting::OnSaveAsTrack), nullptr, this);

  m_panel->m_bSaveAsRoute->Connect(
      wxEVT_COMMAND_BUTTON_CLICKED,
      wxCommandEventHandler(WeatherRouting::OnSaveAsRoute), nullptr, this);

  m_panel->m_bExportRoute->Connect(
      wxEVT_COMMAND_BUTTON_CLICKED,
      wxCommandEventHandler(WeatherRouting::OnExportRouteAsGPX), nullptr, this);
}




//==============================================================
// DESTRUCTOR  weatherrouting
//==============================================================

WeatherRouting::~WeatherRouting() {

  m_shuttingDown = true;  // <-- ADD THIS

  // Stop internal timers
  if (m_tAutoSaveXML.IsRunning())
      m_tAutoSaveXML.Stop();

  // Quiesce RoutingTablePanel early to prevent late callbacks
  if (m_RoutingTablePanel) {
    m_RoutingTablePanel->Freeze();
    m_RoutingTablePanel->Disconnect();
  }
  wxLogMessage(
      "WeatherRouting::~WeatherRouting - shutdown flag set, timers stopped, "
      "panel disconnected");
  wxLogMessage("~WeatherRouting() - BEGIN");

  // ---------------------------------------------------------
  // 1. Save settings and dialog geometry
  // ---------------------------------------------------------
  m_SettingsDialog.SaveSettings();

  wxFileConfig* pConf = GetOCPNConfigObject();
  pConf->SetPath("/PlugIns/WeatherRouting");

  wxPoint pos = GetPosition();
  pConf->Write("DialogX", pos.x);
  pConf->Write("DialogY", pos.y);
  pConf->Write("DialogWidth", m_size.x);
  pConf->Write("DialogHeight", m_size.y);

  if (m_panel && m_panel->m_splitter1)
    pConf->Write("DialogSplit", m_panel->m_splitter1->GetSashPosition());

  // Save XML project file
  SaveXML(m_FileName.GetFullPath());

  // ---------------------------------------------------------
  // 2. Stop all overlays using the NEW thread lifecycle
  // ---------------------------------------------------------
  {
    wxMutexLocker lock(m_OverlayListMutex);

    for (auto* ov : m_RouteMapOverlays) {
      if (!ov) continue;

      ov->SetFinished(true);
      ov->m_Stopped = true;
    }
  }

// Wait for all threads to exit cleanly
  std::list<RouteMapOverlay*> overlays(m_RouteMapOverlays.begin(),
                                       m_RouteMapOverlays.end());

  WaitForRoutesToStop(overlays);

  // ---------------------------------------------------------
  // 3. Remove overlays from scheduler lists and delete threads
  // ---------------------------------------------------------
  for (auto* ov : m_RouteMapOverlays) {
    if (!ov) continue;

    m_WaitingRouteMaps.remove(ov);
    m_RunningRouteMaps.remove(ov);

    if (ov->HasThread()) ov->Stop();

    ov->DeleteThread();
  }

  // ---------------------------------------------------------
  // 4. Delete WeatherRoute objects (after overlays are safe)
  // ---------------------------------------------------------
  for (auto* wr : m_WeatherRoutes) delete wr;

  m_WeatherRoutes.clear();
  m_RouteMapOverlays.clear();

  // ---------------------------------------------------------
  // 5. Destroy RoutingTablePanel if it exists
  // ---------------------------------------------------------
  if (m_RoutingTablePanel) {
    wxAuiManager* mgr = ::GetFrameAuiManager();
    mgr->DetachPane(m_RoutingTablePanel);
    m_RoutingTablePanel->Destroy();
    m_RoutingTablePanel = nullptr;
  }

  // ---------------------------------------------------------
  // 6. Let wxWidgets destroy child windows naturally
  // ---------------------------------------------------------
  // m_panel and m_colpane are children of this window.
  // wxWidgets will destroy them automatically.

  wxLogMessage("~WeatherRouting() - END");
}

//==============================================================
// DESTRUCTOR  ENDING  weatherrouting
//==============================================================



//==============================================================
// RENDER   OPENCPN Render overlay drawing function
//==============================================================


/*

void WeatherRouting::Render(piDC& dc, PlugIn_ViewPort& vp) {
  // ---------------------------------------------------------------------
  // 1. Validate viewport and detect SDMM format changes
  // ---------------------------------------------------------------------
  static int prevLocationFormat = -1;
  int currentLocationFormat = GetLatLonFormat();
  bool locationFormatChanged = false;

  if (!vp.bValid) return;

  if (currentLocationFormat != prevLocationFormat) {
    prevLocationFormat = currentLocationFormat;
    locationFormatChanged = true;
  }

  // ---------------------------------------------------------------------
  // 2. Update waypoint positions in the Positions list control
  //    This is legacy behavior: the plugin polls RouteMap::Positions
  //    and updates the UI if any waypoint has moved or been renamed.
  // ---------------------------------------------------------------------
  bool work = false;

  for (auto& it : RouteMap::Positions) {
    PlugIn_Waypoint waypoint;
    bool gotWaypoint = false;

    wxString name = it.Name;
    double lat = it.lat;
    double lon = it.lon;

    // If the waypoint has a GUID, fetch its current state from OpenCPN
    if (!it.GUID.IsEmpty()) {
      gotWaypoint = GetSingleWaypoint(it.GUID, &waypoint);

      if (gotWaypoint) {
        if (lat != waypoint.m_lat || lon != waypoint.m_lon ||
            !waypoint.m_MarkName.IsSameAs(it.Name)) {
          work = true;
        }
      }
    }

    long index = m_panel->m_lPositions->FindItem(0, it.ID);
    if (index < 0) continue;  // corrupted or missing row

    // Update cached values if waypoint changed
    if (gotWaypoint && work) {
      name = waypoint.m_MarkName;
      lat = waypoint.m_lat;
      lon = waypoint.m_lon;

      it.Name = name;
      it.lat = lat;
      it.lon = lon;
    }

    // Update UI if waypoint changed or SDMM format changed
    if (work || locationFormatChanged) {
      m_panel->m_lPositions->SetItem(index, POSITION_NAME, name);
      m_panel->m_lPositions->SetColumnWidth(POSITION_NAME, wxLIST_AUTOSIZE);

      m_panel->m_lPositions->SetItem(
          index, POSITION_LAT, toSDMM_PlugIn(NEflag::LAT, lat, Precision::HI));
      m_panel->m_lPositions->SetColumnWidth(POSITION_LAT, wxLIST_AUTOSIZE);

      m_panel->m_lPositions->SetItem(
          index, POSITION_LON, toSDMM_PlugIn(NEflag::LON, lon, Precision::HI));
      m_panel->m_lPositions->SetColumnWidth(POSITION_LON, wxLIST_AUTOSIZE);
    }
  }

  // If anything changed, refresh the parent window
  if (work || locationFormatChanged) GetParent()->Refresh();

  // ---------------------------------------------------------------------
  // 3. Prepare OpenGL state (if using GL instead of wxDC)
  // ---------------------------------------------------------------------
  if (!dc.GetDC()) {
#ifndef __OCPN__ANDROID__
    glPushAttrib(GL_LINE_BIT | GL_ENABLE_BIT | GL_HINT_BIT);
    glEnable(GL_LINE_SMOOTH);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
#endif
    glEnable(GL_BLEND);
  }

  // ---------------------------------------------------------------------
  // 4. Determine GRIB timeline time for rendering
  // ---------------------------------------------------------------------
  wxDateTime time = m_ConfigurationDialog.m_GribTimelineTime;
  if (!time.IsValid()) time = wxDateTime::UNow();

  // ---------------------------------------------------------------------
  // 5. Update routing table highlight (UI only)
  // ---------------------------------------------------------------------
  if (m_RoutingTablePanel) m_RoutingTablePanel->UpdateTimeHighlight(time);

  // ---------------------------------------------------------------------
  // 6. Render all route overlays in the list control
  // ---------------------------------------------------------------------
  for (int i = 0; i < m_panel->m_lWeatherRoutes->GetItemCount(); i++) {
    WeatherRoute* weatherroute = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));

    if (weatherroute && weatherroute->routemapoverlay &&
        weatherroute->routemapoverlay->m_bEndRouteVisible) {
      weatherroute->routemapoverlay->Render(time, m_SettingsDialog, dc, vp,
                                            true);
    }
  }

  // ---------------------------------------------------------------------
  // 7. Render batch configuration overlay (if active)
  // ---------------------------------------------------------------------
  m_ConfigurationBatchDialog.Render(dc, vp);

  // ---------------------------------------------------------------------
  // 8. Restore OpenGL state
  // ---------------------------------------------------------------------
#ifndef __OCPN__ANDROID__
  if (!dc.GetDC()) glPopAttrib();
#endif
}

//==============================================================
// ANDROID GESTURE EVENT HANDLER
//==============================================================


#ifdef __OCPN__ANDROID__
void WeatherRouting::OnEvtPanGesture(wxQT_PanGestureEvent& event) {
  switch (event.GetState()) {
    case GestureStarted:
      m_startPos = GetPosition();
      m_startMouse = event.GetCursorPos();  // g_mouse_pos_screen;
      break;
    default: {
      wxPoint pos = event.GetCursorPos();
      int x = wxMax(0, pos.x + m_startPos.x - m_startMouse.x);
      int y = wxMax(0, pos.y + m_startPos.y - m_startMouse.y);
      int xmax = ::wxGetDisplaySize().x - GetSize().x;
      x = wxMin(x, xmax);
      int ymax =
          ::wxGetDisplaySize().y - GetSize().y;  // Some fluff at the bottom
      y = wxMin(y, ymax);

      Move(x, y);
      m_tDownTimer.Stop();
    } break;
  }
}
#endif



//==============================================================
// ANDROID GESTURE EVENT HANDLER
//==============================================================


#ifdef __OCPN__ANDROID__
void WeatherRouting::OnEvtPanGesture(wxQT_PanGestureEvent& event) {
  switch (event.GetState()) {
    case GestureStarted:
      m_startPos = GetPosition();
      m_startMouse = event.GetCursorPos();  // g_mouse_pos_screen;
      break;
    default: {
      wxPoint pos = event.GetCursorPos();
      int x = wxMax(0, pos.x + m_startPos.x - m_startMouse.x);
      int y = wxMax(0, pos.y + m_startPos.y - m_startMouse.y);
      int xmax = ::wxGetDisplaySize().x - GetSize().x;
      x = wxMin(x, xmax);
      int ymax =
          ::wxGetDisplaySize().y - GetSize().y;  // Some fluff at the bottom
      y = wxMin(y, ymax);

      Move(x, y);
      m_tDownTimer.Stop();
    } break;
  }
}
#endif

*/








//==============================================================
// COMPUTE 
//=============================================================


// ============================================================================
// WeatherRouting::Start computation for selected routes
// Modern compute entry point: start computation only on selected overlays,
// using the per-overlay thread lifecycle. No scheduler, no waiting lists.
// ============================================================================
// Start(ov) is the modern entry point for starting computation on a single
// overlay. It is located in RouteMapOverlay and is called by ComputeSelectedRoute
// for each selected overlay. It is also called by the RouteMapOverlay context menu
// for starting/stopping individual overlays. It ensures that the overlay's thread
// is properly managed according to the new lifecycle rules (no scheduler, no
// waiting lists). It is the authoritative way to start computation on an overlay.
// ComputeSelectedRoute is the batch entry point for starting computation on
// all selected overlays. It calls Start(ov) for each selected overlay, and
// also performs UI updates and invariant checks after starting the threads.
// This ensures that the UI state is updated and lifecycle invariants are maintained.
// Call ov->Start() to start computation on // an individual overlay


// ============================================================================
// WeatherRouting::ComputeSelectedRoute
// Modern compute entry point: start computation only on selected overlays,
// using the per-overlay thread lifecycle. No scheduler, no waiting lists.
// ============================================================================
void WeatherRouting::ComputeSelectedRoute() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("WeatherRouting::ComputeSelectedRoute - BEGIN");

  // ---------------------------------------------------------------------
  // 1. Collect selected overlays
  // ---------------------------------------------------------------------
  std::vector<RouteMapOverlay*> overlays = GetSelectedOverlays();

  if (overlays.empty()) {
    wxMessageBox(_("No routes selected."), _("Weather Routing"),
                 wxOK | wxICON_INFORMATION, this);
    wxLogMessage("ComputeSelectedRoute: no selection");
    return;
  }

  // ---------------------------------------------------------------------
  // 2. Start computation for each selected overlay
  // ---------------------------------------------------------------------
  for (auto* ov : overlays) {
    if (!ov) continue;

    WeatherRoute* wr = ov->m_weatherRoute;
    if (!wr) continue;

    // Skip if already running
    if (ov->Running()) {
      wxLogMessage("ComputeSelectedRoute: overlay=%p already running", ov);
      continue;
    }

    wxLogMessage("ComputeSelectedRoute: starting overlay=%p", ov);

    // Ensure no stale worker thread exists
    ov->Stop();
    ov->DeleteThread();

    // Reset compute state
    wr->ClearComputedFields();
    ov->ResetFinished();
    ov->MarkDirty();

    // Launch computation thread
    wxString error;
    ov->Start(error);
  }

  // ---------------------------------------------------------------------
  // 3. Refresh UI state
  // ---------------------------------------------------------------------
  UpdateStates();

  // ---------------------------------------------------------------------
  // 4. Assert lifecycle invariants
  // ---------------------------------------------------------------------
  AssertThreadLifecycleInvariants();

  wxLogMessage("WeatherRouting::ComputeSelectedRoute - END");
}

// ============================================================================
// WeatherRouting::ComputeAllRoutes
// Modern compute entry point: start computation on all overlays.
// No scheduler, no waiting lists, no running lists.
// ============================================================================

 // REMOVED ComputeAllRoutes is the batch entry point for starting computation on
// all


// ============================================================================
//  SELECTION HELPERS
// ============================================================================
// WeatherRouting::GetSelectedOverlays
// Modern selection helper: returns the RouteMapOverlay* objects corresponding
// to the currently selected rows in the WeatherRoutes list control.
//
// Notes:
//  ? This function is *pure* ? it does not modify state, UI, or threads.
//  ? It is the authoritative way to determine which overlays are selected.
//  ? It replaces all legacy selection logic (no scheduler lists, no indices).
// ============================================================================
// MODERN

std::vector<RouteMapOverlay*> WeatherRouting::GetSelectedOverlays() const {
  std::vector<RouteMapOverlay*> result;

  // 1. Validate UI context
  if (!m_panel || !m_panel->m_lWeatherRoutes) return result;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  // 2. Enumerate selected rows
  long item = -1;
  for (;;) {
    item = list->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item < 0) break;

    // 3. Retrieve the WeatherRoute*
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(list->GetItemData(item));
    if (!wr) continue;

    RouteMapOverlay* rmo = wr->routemapoverlay;
    if (!rmo) continue;

    // 4. Append overlay
    result.push_back(rmo);
  }

  return result;
}


//--------------------------------------------------------------------
// WeatherRouting::GetSelectedRoute
//---------------------------------------------------------------------
// returns the WeatherRoute* corresponding to the first selected row in the
// WeatherRoutes list control, or nullptr if no selection. This is a helper for
// single-route operations (e.g., Edit Configuration) where we only care about
// the first selected route. It is a pure function that does not modify state,
// UI, or threads. It is the authoritative way to get the selected WeatherRoute*
// for single-route operations. It replaces legacy logic that might have been
// based on list indices or scheduler state.

// MODERN
WeatherRoute* WeatherRouting::GetSelectedRoute() const {
  // Ensure UI is valid
  if (!m_panel || !m_panel->m_lWeatherRoutes) return nullptr;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  // Get first selected row
  long item = list->GetNextItem(-1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
  if (item < 0) return nullptr;

  // Retrieve WeatherRoute* stored in row data
  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(list->GetItemData(item));

  return wr;
}

// MODERN
void WeatherRouting::UpdateItem(long row, bool refreshState) {
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(list->GetItemData(row));
  if (!wr) return;

  // Column 0: Visibility
  list->SetItem(row, 0, wr->visible ? _("X") : _(""));

  // Column 1: Boat
  list->SetItem(row, 1, wr->BoatName);

  // Column 2: Start Type
  list->SetItem(row, 2, wr->StartTypeString());

  // Column 3: Start
  list->SetItem(row, 3, wr->StartString());

  // Column 4: Start Time
  list->SetItem(row, 4, wr->StartTimeString());

  // Column 5: End
  list->SetItem(row, 5, wr->EndString());

  // Column 6: End Time
  list->SetItem(row, 6, wr->EndTimeString());

  // Column 7: Duration
  list->SetItem(row, 7, wr->DurationString());

  // Column 8: Distance
  list->SetItem(row, 8, wr->DistanceString());

  // Column 9: State
  if (refreshState) list->SetItem(row, 9, wr->StateString());
}


// -----------------------------------------------------------------------------
// OnWeatherRouteSelected  - event handler for when the user selects or deselects
// ----------------------------------------------------------------------------
// a route in the WeatherRoutes list control. It performs the following actions:
// 1. Collects all selected WeatherRoute objects (not just the clicked row)
// 2. Updates the Configuration dialog with the selected routes (multi-route
//   aware)
// 3. Updates the Statistics, Report, and Plot dialogs to reflect the selected
//  routes
// 4. Updates the Routing Table panel to show the first selected route (if any)
// 5. Updates the compute button, stop button, progress bar, and status text
//   based on the selected routes' states
// 6. Refreshes the parent window to update map highlights
// This event handler is designed to be robust and responsive, providing
// immediate
// feedback to the user when they select or deselect routes in the list control.
// It ensures that the UI state is consistent with the current selection and
// that
// all relevant dialogs and panels are updated accordingly.
// Note: This handler is called for both selection and deselection events, so it
// must handle the case where no routes are selected (e.g., when the user
// deselects all routes) and update the UI state appropriately (e.g., hide
// the Configuration dialog).
// Note: The handler uses the GetSelectedOverlays() helper function to determine
// which routes are currently selected, ensuring that it works correctly even
// if the user selects multiple routes or changes the selection in a non-linear
// way (e.g., using Ctrl+click or Shift+click).
// Note: The handler updates the Routing Table panel to show the first selected
// route, but it could be extended to show multiple routes or provide a way for
// the user to choose which route to display if multiple are selected.
// Note: The handler calls UpdateComputeState() to ensure that the compute and
// stop
// buttons are enabled or disabled based on the states of the selected routes,
// providing immediate feedback to the user about what actions are available for
// the current selection.
// Note: The handler refreshes the parent window at the end to ensure that any
// map highlights or other visual indicators of the selected routes are updated
// immediately, providing a responsive and interactive user experience.

// Modern


void WeatherRouting::OnWeatherRouteSelected(wxListEvent& event) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  // ---------------------------------------------------------------------
  // 1. Collect ALL selected WeatherRoutes (not just the clicked row)
  // ---------------------------------------------------------------------
  std::list<WeatherRoute*> selectedRoutes;

  long item = -1;
  while (true) {
    item = list->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr =
        reinterpret_cast<WeatherRoute*>(wxUIntToPtr(list->GetItemData(item)));

    if (wr) selectedRoutes.push_back(wr);
  }

  // ---------------------------------------------------------------------
  // 2. Update Configuration dialog (multi?route aware)
  // ---------------------------------------------------------------------
  if (selectedRoutes.empty()) {
    m_tHideConfiguration.Start(25, true);
  } else {
    m_tHideConfiguration.Stop();

    std::list<RouteMapConfiguration> configs;
    for (auto* wr : selectedRoutes) {
      if (wr->routemapoverlay)
        configs.push_back(wr->routemapoverlay->GetConfiguration());
    }

    m_bSkipUpdateCurrentItems = true;
    m_ConfigurationDialog.SetConfigurations(configs);
    m_bSkipUpdateCurrentItems = false;
  }

  // ---------------------------------------------------------------------
  // 3. Update Statistics, Report, Plot dialogs
  // ---------------------------------------------------------------------
  UpdateDialogs();

  // ---------------------------------------------------------------------
  // 4. Update Routing Table (first selected route only)
  // ---------------------------------------------------------------------
  if (m_RoutingTablePanel) {
    wxAuiManager* mgr = ::GetFrameAuiManager();
    wxAuiPaneInfo& pane = mgr->GetPane(m_RoutingTablePanel);

    if (pane.IsOk() && pane.IsShown() && !selectedRoutes.empty()) {
      WeatherRoute* wr = selectedRoutes.front();
      auto* panel = static_cast<RoutingTablePanel*>(m_RoutingTablePanel);

      panel->m_RouteMap = wr->routemapoverlay;
      panel->PopulateTable();
    }
  }

  // ---------------------------------------------------------------------
  // 5. Update compute button, stop button, progress bar, status text
  // ---------------------------------------------------------------------
  UpdateComputeState();

  // ---------------------------------------------------------------------
  // 6. Refresh parent window to update map highlights
  // ---------------------------------------------------------------------
  if (GetParent()) GetParent()->Refresh();
}


// Put these methods together for better context
// GetSelectedOverlays()
// FirstCurrentRouteMap()(if still present)
// CurrentRouteMaps()
//This keeps your selection helpers grouped.
// MODERN

void WeatherRouting::DeleteSelectedRoute() {
  // ---------------------------------------------------------
  // 1. Get selected overlays
  // ---------------------------------------------------------
  std::vector<RouteMapOverlay*> overlays = GetSelectedOverlays();
  if (overlays.empty()) {
    wxLogMessage("WR: DeleteSelectedRoute ? no routes selected");
    return;
  }

  wxLogMessage("WR: DeleteSelectedRoute ? BEGIN");

  // ---------------------------------------------------------
  // 2. Stop running computations
  // ---------------------------------------------------------
  for (auto* rmo : overlays) {
    if (!rmo) continue;

    rmo->Stop();
    rmo->DeleteThread();
  }

  // ---------------------------------------------------------
  // 3. Delete overlays + WeatherRoute objects
  // ---------------------------------------------------------
  for (auto* rmo : overlays) {
    if (!rmo) continue;

    WeatherRoute* wr = rmo->m_weatherRoute;
    if (!wr) continue;

    // Remove from master list
    auto it = std::find(m_WeatherRoutes.begin(), m_WeatherRoutes.end(), wr);
    if (it != m_WeatherRoutes.end()) m_WeatherRoutes.erase(it);

    // Delete overlay (thread-safe, centralized)
    DeleteRouteMap(rmo);

    // Delete WeatherRoute object
    delete wr;
  }

  // ---------------------------------------------------------
  // 4. Clear stale UI state
  // ---------------------------------------------------------
  m_positionOnRoute = nullptr;

  // ---------------------------------------------------------
  // 5. Refresh UI (modern pipeline)
  // ---------------------------------------------------------
  UpdateCurrentConfigurations();  // rebuilds list control
  UpdateDialogs();                // stats/report/plot
  UpdateComputeState();           // compute button, etc.

  if (GetParent()) GetParent()->Refresh();

  // ---------------------------------------------------------
  // 6. Schedule autosave
  // ---------------------------------------------------------
  m_tAutoSaveXML.Start(5000, true);

  wxLogMessage("WR: DeleteSelectedRoute ? END");
}



void WeatherRouting::OnDeleteRouting(wxCommandEvent& event) {
  DeleteSelectedRoute();
}


// MODERN

void WeatherRouting::OnDeleteAllRoutings(wxCommandEvent& event) {
  // ---------------------------------------------------------
  // 1. Stop all computations first
  // ---------------------------------------------------------
  StopAll();

  // ---------------------------------------------------------
  // 2. Delete all overlays + WeatherRoute objects
  // ---------------------------------------------------------
  for (auto* wr : m_WeatherRoutes) {
    if (!wr) continue;

    if (wr->routemapoverlay) DeleteRouteMap(wr->routemapoverlay);

    delete wr;
  }

  m_WeatherRoutes.clear();

  // ---------------------------------------------------------
  // 3. Clear UI state
  // ---------------------------------------------------------
  m_positionOnRoute = nullptr;

  // ---------------------------------------------------------
  // 4. Refresh UI (modern pipeline)
  // ---------------------------------------------------------
  UpdateCurrentConfigurations();  // rebuilds routing list
  UpdateDialogs();                // stats/report/plot
  UpdateComputeState();           // compute button, etc.

  if (GetParent()) GetParent()->Refresh();

  // ---------------------------------------------------------
  // 5. Schedule autosave
  // ---------------------------------------------------------
  m_tAutoSaveXML.Start(5000, true);

  wxLogMessage("WR: OnDeleteAllRoutings ? all routes deleted");
}




// --------------------------------------------------------------------
// WeatherRouting::GetRouteRow
// --------------------------------------------------------------------
// MODERN helper: returns the row index of the given WeatherRoute*

long WeatherRouting::GetRouteRow(WeatherRoute* wr) const {
  if (!wr || !m_panel || !m_panel->m_lWeatherRoutes) return -1;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  long count = list->GetItemCount();
  for (long row = 0; row < count; row++) {
    WeatherRoute* rowWR =
        reinterpret_cast<WeatherRoute*>(list->GetItemData(row));

    if (rowWR == wr) return row;
  }

  return -1;
}


void WeatherRouting::OnStopRouting(wxCommandEvent& event) { StopSelected(); }


void WeatherRouting::OnStopAllRoutings(wxCommandEvent& event) { StopAll(); }


void WeatherRouting::OnGotoRouting(wxCommandEvent& event) {
  auto overlays = GetSelectedOverlays();
  if (overlays.empty()) return;

  RouteMapOverlay* rmo = overlays.front();
  if (!rmo || !rmo->m_weatherRoute) return;

WeatherRoute* wr = rmo->m_weatherRoute;
  if (!wr || wr->routepoints.empty()) return;

  const auto& p = wr->routepoints.front();

  PlugIn_Position_Fix_Ex fix;
  fix.Lat = p.lat;
  fix.Lon = p.lon;
  fix.Cog = NAN;
  fix.Sog = NAN;
  fix.Var = NAN;
  fix.Hdt = NAN;
  fix.Hdm = NAN;
//  fix.Hdg = NAN;    Not in api118
  fix.FixTime = wxDateTime::Now().GetTicks();
//  JumpToPosition(fix);  Not  in api118
  JumpToPosition(fix.Lat, fix.Lon, 1.0);
}


void WeatherRouting::SaveColumnWidth(int col, int width) {
  m_ColumnWidths[col] = width;
  m_tAutoSaveXML.Start(5000, true);
}

int WeatherRouting::LoadColumnWidth(int col) const {
  auto it = m_ColumnWidths.find(col);
  return (it != m_ColumnWidths.end()) ? it->second : -1;
}


//==============================================================
// END OF NEW  STUFF
//=============================================================



//============================================================
//  SYSTEM LEVEL EVENT HANDLERS (RouteMapUpdate, Memory Alerts)
//============================================================
// OnPostionKeyDown:
//     Handle key events for positions list
//     Currently only handles Delete key to delete position
//     Other keys are passed to default handler
// OnLeftDown
//    On left mouse button down event handler for both weather routing lists
// OnLeftUp
//     On left mouse button up event handler for both weather routing lists
// OnDownTimer
//    Timer event handler for "press and hold" context menu popup
// OnMemoryAlertStop
//   Handler for memory alert stop event from ASM
// OnMemoryAutoReset
//  Handler for memory auto reset event from ASM
// OnLeftDClick
//    On left double click event handler for positions list
// OnRightUp
//   On right mouse button up event handler for both weather routing lists
//-------------------------------------------------------------

void WeatherRouting::OnPositionKeyDown(wxListEvent& event) {
  // Ensure the new UI panel and list control exist
  if (!m_PositionPanel || !m_PositionPanel->m_lPositions) {
    event.Skip();
    return;
  }
  switch (event.GetKeyCode()) {
    case WXK_DELETE: {
      wxCommandEvent cmd;
      OnDeletePosition(cmd);
      break;
    }
    default:
      event.Skip();
  }
}


// Shared mouse event handler for both weather routing lists (positions and
// routes) Handles "press and hold" timer for context menu popup
// Allow default selection behavior
void WeatherRouting::OnLeftDown(wxMouseEvent& event) {
  m_tDownTimer.Start(1200, true);
  m_downPos = event.GetPosition();
  event.Skip(); 
}

// Shared mouse event handler for both weather routing lists
// Stops the "press and hold" timer for context menu

void WeatherRouting::OnLeftUp(wxMouseEvent& event) { m_tDownTimer.Stop(); }


void WeatherRouting::OnDownTimer(wxTimerEvent&) {
  // Ensure the new UI panels exist
  if (!m_panel || !m_PositionPanel) return;

  wxListCtrl* routes = m_panel->m_lWeatherRoutes;
  wxListCtrl* positions = m_PositionPanel->m_lPositions;

  if (!routes || !positions) return;

  int flags = wxLIST_HITTEST_NOWHERE | wxLIST_HITTEST_ONITEM;

  // ---------------------------------------------------------
  // 1. Did the long?press occur on the ROUTINGS list?
  // ---------------------------------------------------------
  if (routes->HitTest(m_downPos, flags) != wxNOT_FOUND) {
    routes->PopupMenu(m_mContextMenu, m_downPos);
    return;
  }

  // ---------------------------------------------------------
  // 2. Did the long?press occur on the POSITIONS list?
  // ---------------------------------------------------------
  if (positions->HitTest(m_downPos, flags) != wxNOT_FOUND) {
    positions->PopupMenu(m_mContextMenuPositions, m_downPos);
    return;
  }
}

void WeatherRouting::OnRightUp(wxMouseEvent& event) {
  wxObject* obj = event.GetEventObject();

  // Right?click on ROUTINGS list
  if (m_panel && obj == m_panel->m_lWeatherRoutes) {
    m_panel->m_lWeatherRoutes->PopupMenu(m_mContextMenu, event.GetPosition());
    return;
  }

  // Right?click on POSITIONS list
  if (m_PositionPanel && obj == m_PositionPanel->m_lPositions) {
    m_PositionPanel->m_lPositions->PopupMenu(m_mContextMenuPositions,
                                             event.GetPosition());
    return;
  }

  // Otherwise let wxWidgets handle it
  event.Skip();
}



void WeatherRouting::OnMemoryAlertStop(wxCommandEvent& event) {
  wxLogMessage("WeatherRouting::OnMemoryAlertStop - BEGIN");

  // Phase 1: signal all workers to stop
  StopAll();

  // Phase 2: wait for all threads to exit
  WaitForAllRoutesToStop();

  // Phase 3: update UI to reflect stopped state
  RefreshUI();

  // Show the AlertStop dialog
  MemoryStatusDialog dlg(this, MemoryDialogMode::AlertStop);
  int r = dlg.ShowModal();

  // If user pressed Reset, perform a full reset
  if (r == wxID_RESET) {
    ResetAll();  // <-- correct call
  }

  wxLogMessage("WeatherRouting::OnMemoryAlertStop - END");
}


void WeatherRouting::OnMemoryAutoReset(wxCommandEvent& event) {
  wxLogMessage("WeatherRouting::OnMemoryAutoReset - BEGIN");

  // Phase 1: signal all workers to stop
  StopAll();

  // Phase 2: wait for all threads to exit
  WaitForAllRoutesToStop();

  // Phase 3: full reset of all overlays
  ResetAll();

  // Show informational dialog
  MemoryStatusDialog dlg(this, MemoryDialogMode::AutoReset);
  dlg.ShowModal();

  wxLogMessage("WeatherRouting::OnMemoryAutoReset - END");
}



/* ============================================================
   UTILITY FUNCTIONS
   ============================================================
   Stateless helpers used by routing and UI layers.
   These do not depend on WeatherRoute instance state.
   ============================================================ */

// Cursor position dialog message
//    Quick helper to set message in cursor position dialog
// Route position dialog message
//    Quick helper to set message in route position dialog
// CursorPRouteChanged
//    Callback when cursor route changes to update plot dialog
// UpdateRoutePositionDialog
//    Update route position dialog based on cursor position
// UpdateCursorPositionDialog



static void CursorPositionDialogMessage(CursorPositionDialog& dlg,
                                        wxString msg) {
  dlg.m_stPosition->SetLabel(msg);
  dlg.m_stPosition->Fit();
  dlg.m_stTime->SetLabel("");
  dlg.m_stPolar->SetLabel("");
  dlg.m_stSailChanges->SetLabel("");
  dlg.m_stTacks->SetLabel("");
  dlg.m_stJibes->SetLabel("");
  dlg.m_stSailPlanChanges->SetLabel("");
  dlg.m_stWeatherData->SetLabel("");
  dlg.Fit();
}

static void RoutePositionDialogMessage(RoutePositionDialog& dlg, wxString msg) {
  dlg.m_stPosition->SetLabel(msg);
  dlg.m_stPosition->Fit();
  dlg.m_stTime->SetLabel("");
  dlg.m_stPolar->SetLabel("");
  dlg.m_stSailChanges->SetLabel("");
  dlg.m_stTacks->SetLabel("");
  dlg.m_stJibes->SetLabel("");
  dlg.m_stSailPlanChanges->SetLabel("");
  dlg.m_stWeatherData->SetLabel("");
  dlg.Fit();
}


// -----------------------------------------------------------------------------
// GetAllOverlays()
// -----------------------------------------------------------------------------
// Returns a vector containing *every* RouteMapOverlay currently managed by the
// WeatherRouting plugin.
//
// ARCHITECTURAL ROLE
// -------------------
// This method provides a unified, authoritative way to enumerate all overlays
// regardless of selection state. It complements GetSelectedOverlays() and
// supports operations that must consider the entire overlay set:
//
//   ? Global reset / StopAll()
//   ? Batch configuration and batch compute
//   ? Diagnostics, logging, and memory monitoring
//   ? Rendering passes that need to inspect overlay state
//   ? Future multi-route editing workflows
//
// SOURCE OF TRUTH
// ---------------
// Overlays are stored in m_RouteMapOverlays, a vector owned by WeatherRouting.
// Access to this container is protected by m_OverlayListMutex to ensure
// thread-safe iteration, since overlays may be created, destroyed, or modified
// by worker threads.
//
// RETURN TYPE
// -----------
// A std::vector<RouteMapOverlay*> is returned because:
//   ? It preserves stable iteration order
//   ? It is easy to pass to algorithms and range-based loops
//   ? It avoids exposing internal container types
//
// SAFETY NOTES
// ------------
//  ? The mutex is locked only long enough to copy pointers out of the master
//    list, minimizing contention with worker threads.
//  ? Null pointers are not expected but are ignored defensively.
// -----------------------------------------------------------------------------

std::vector<RouteMapOverlay*> WeatherRouting::GetAllOverlays() {
  if (m_shuttingDown)
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
      return {};

  std::vector<RouteMapOverlay*> result;

  // Lock the master overlay list for safe iteration
  wxMutexLocker lock(m_OverlayListMutex);

  // Copy all overlay pointers into the result vector
  for (RouteMapOverlay* rmo : m_RouteMapOverlays) {
    if (rmo) result.push_back(rmo);
  }

  return result;
}


// -----------------------------------------------------------------------------
// GetSelectedOverlays()
// -----------------------------------------------------------------------------
// Returns a vector of all RouteMapOverlay objects currently selected in the
// Weather Routing list control.
//
// ARCHITECTURAL ROLE
// -------------------
// This method is the modern replacement for the old CurrentRouteMaps() API.
// The list control (m_lWeatherRoutes) is now the *authoritative source* of
// route selection state. All multi-route operations?cursor updates, batch
// configuration, multi-reset, and future multi-route editing?should use this
// method.
//
// WHY A VECTOR?
// -------------
//  ? Stable iteration order (matches UI order)
//  ? Easy to pass to algorithms and range-based loops
//  ? Avoids the overhead and ambiguity of std::list
//
// SELECTION MODEL
// ---------------
// The list control supports multi-selection. Each selected row stores a
// RouteMapOverlay* in its item data. This method extracts those pointers and
// returns them as a clean, ready-to-use container.
//
// FUTURE EXTENSIONS
// -----------------
//  ? Multi-route editing in ConfigurationDialog
//  ? Multi-route batch generation
//  ? Multi-route Reset() and Compute()
//  ? Selection-based rendering optimizations
//
// SAFETY NOTES
// ------------
//  ? If the panel or list control is missing (e.g., during early construction
//    or teardown), the method returns an empty vector.
//  ? Null item-data pointers are ignored defensively.
// -----------------------------------------------------------------------------




void WeatherRouting::CursorRouteChanged() {
  if (m_PlotDialog.IsShown() && m_PlotDialog.m_rbCursorRoute->GetValue())
    m_PlotDialog.SetRouteMapOverlay(FirstCurrentRouteMap());
}


void WeatherRouting::UpdateCursorPositionDialog() {
  CursorPositionDialog& dlg = m_CursorPositionDialog;

  // Dialog not yet visible ? nothing to do
  if (!dlg.IsShown()) return;

  // Panel or list control not ready yet
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  // No routes yet
  if (m_RouteMapOverlays.empty()) return;

  // Determine which WeatherRoute is selected
  long item = m_panel->m_lWeatherRoutes->GetNextItem(-1, wxLIST_NEXT_ALL,
                                                     wxLIST_STATE_SELECTED);

  if (item < 0) {
    CursorPositionDialogMessage(dlg, _("Select exactly 1 configuration"));
    return;
  }

  // Retrieve the WeatherRoute and its overlay
  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
      wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

  RouteMapOverlay* rmo = wr ? wr->routemapoverlay : nullptr;

  if (!rmo) {
    CursorPositionDialogMessage(dlg, _("No route map overlay available"));
    return;
  }

  const Position* p = rmo->GetLastCursorPosition();
  if (!p) {
    CursorPositionDialogMessage(dlg, _("Cursor outside computed route map"));
    return;
  }
  wxDateTime display_time = rmo->GetLastCursorTime();

  if (m_SettingsDialog.m_cbUseLocalTime->GetValue())
    display_time = display_time.FromUTC();

  dlg.m_stTime->SetLabel(display_time.Format("%x %H:%M"));

  RouteMapConfiguration configuration = rmo->GetConfiguration();
  auto latStr = toSDMM_PlugIn(NEflag::LAT, p->lat, Precision::HI);
  auto lonStr = toSDMM_PlugIn(NEflag::LON, p->lon, Precision::HI);
  dlg.m_stPosition->SetLabel(latStr + " " + lonStr);

  if (p->polar == -1)
    dlg.m_stPolar->SetLabel(wxEmptyString);
  else {
    wxFileName fn = configuration.boat.Polars[p->polar].FileName;
    dlg.m_stPolar->SetLabel(fn.GetFullName());
  }

  dlg.m_stSailChanges->SetLabel(wxString::Format("%d", p->SailChanges()));

  dlg.m_stTacks->SetLabel(wxString::Format("%d", p->tacks));
  dlg.m_stJibes->SetLabel(wxString::Format("%d", p->jibes));
  dlg.m_stSailPlanChanges->SetLabel(
      wxString::Format("%d", p->sail_plan_changes));

  wxString weatherdata;
  wxString grib = _("Grib") + " ";
  wxString climatology = _("Climatology") + " ";
  wxString data_deficient = _("Data Deficient") + " ";
  wxString wind = _("Wind") + " ";
  wxString current = _("Current") + " ";

  if (p->data_mask & DataMask::GRIB_WIND) weatherdata += grib + wind;
  if (p->data_mask & DataMask::CLIMATOLOGY_WIND)
    weatherdata += climatology + wind;
  if (p->data_mask & DataMask::DATA_DEFICIENT_WIND)
    weatherdata += data_deficient + wind;
  if (p->data_mask & DataMask::GRIB_CURRENT) weatherdata += grib + current;
  if (p->data_mask & DataMask::CLIMATOLOGY_CURRENT)
    weatherdata += climatology + current;
  if (p->data_mask & DataMask::DATA_DEFICIENT_CURRENT)
    weatherdata += data_deficient + current;

  dlg.m_stWeatherData->SetLabel(weatherdata);
  dlg.Fit();
}


// -----------------------------------------------------------------------------
  /* New method to display information on the weather route
   * (like starttime, finishtime, time, position, wind, speed, etc.)
   * based on cursor position of the user.
   * This is complementary with the plot chart.    */
// -----------------------------------------------------------------------------
void WeatherRouting::UpdateRoutePositionDialog(RoutePositionDialog & dlg) {
    // ---------------------------------------------------------------------
    // 1. Determine the first selected route map overlay
    //    The list control is the authoritative source of selection.
    // ---------------------------------------------------------------------
    RouteMapOverlay* rmo = FirstCurrentRouteMap();
    if (!rmo) {
      RoutePositionDialogMessage(dlg, _("No route selected"));
      return;
    }
    RouteMapConfiguration configuration = rmo->GetConfiguration();

    // ---------------------------------------------------------------------
    // 2. Determine the closest computed route point to the cursor
    //    getClosestRoutePositionFromCursor() fills PlotData with the
    //    interpolated or exact point along the route.
    // ---------------------------------------------------------------------
    PlotData data;
    Position* closestPosition = rmo->getClosestRoutePositionFromCursor(
        m_weather_routing_pi.m_cursor_lat, m_weather_routing_pi.m_cursor_lon,
        data);

    // Store the position for display in the dialog
    m_positionOnRoute = closestPosition;

    // If no discrete Position* exists but PlotData is valid,
    // fall back to a synthetic saved position
    if (!closestPosition && data.time.IsValid()) {
      m_positionOnRoute = &m_savedPosition;
      m_savedPosition = data;
    }

    // If still nothing, the cursor is outside the computed route map
    if (!m_positionOnRoute) {
      RoutePositionDialogMessage(dlg, _("Cursor outside computed route map"));
      return;
    }

    // ---------------------------------------------------------------------
    // 3. Trip time (start ? cursor)
    // ---------------------------------------------------------------------
    wxDateTime startTime = configuration.StartTime;
    wxDateTime cursorTime = data.time;

    // Convert to local time if requested
    if (m_SettingsDialog.m_cbUseLocalTime->GetValue()) {
      startTime = startTime.FromUTC();
      cursorTime = data.time.FromUTC();
    }

    // Display elapsed time
    wxString time = calculateTimeDelta(startTime, cursorTime);
    dlg.m_stTime->SetLabel(time);

    // ---------------------------------------------------------------------
    // 4. Position (lat/lon)
    // ---------------------------------------------------------------------
    auto latStr = toSDMM_PlugIn(NEflag::LAT, data.lat, Precision::HI);
    auto lonStr = toSDMM_PlugIn(NEflag::LON, data.lon, Precision::HI);
    dlg.m_stPosition->SetLabel(latStr + " " + lonStr);

    // ---------------------------------------------------------------------
    // 5. Polar file used at this point
    // ---------------------------------------------------------------------
    if (data.polar == -1) {
      dlg.m_stPolar->SetLabel(wxEmptyString);
    } else {
      wxFileName fn = configuration.boat.Polars[data.polar].FileName;
      dlg.m_stPolar->SetLabel(fn.GetFullName());
    }

    // ---------------------------------------------------------------------
    // 6. Maneuvers: tacks & jibes
    // ---------------------------------------------------------------------
    dlg.m_stTacks->SetLabel(wxString::Format("%d", data.tacks));
    dlg.m_stJibes->SetLabel(wxString::Format("%d", data.jibes));

    // ---------------------------------------------------------------------
    // 7. Boat speed (SOW/SOG)
    // ---------------------------------------------------------------------
    if (std::abs(data.stw - data.sog) > 0.1) {
      dlg.m_stBoatSpeed->SetLabel(wxString::Format(
          "%.1f knts (SOW), %.1f knts (SOG)", data.stw, data.sog));
    } else {
      dlg.m_stBoatSpeed->SetLabel(wxString::Format("%.1f knts", data.stw));
    }

    // ---------------------------------------------------------------------
    // 8. Boat course (COW/COG)
    // ---------------------------------------------------------------------
    if (std::abs(data.ctw - data.cog) >= 5) {
      dlg.m_stBoatCourse->SetLabel(wxString::Format(
          "%.0f T (COW), %.0f T (COG)", positive_degrees(data.ctw),
          positive_degrees(data.cog)));
    } else {
      dlg.m_stBoatCourse->SetLabel(
          wxString::Format("%.0f T", positive_degrees(data.ctw)));
    }

    // ---------------------------------------------------------------------
    // 9. True wind speed
    // ---------------------------------------------------------------------
    dlg.m_stTWS->SetLabel(wxString::Format("%.0f knts", data.twsOverWater));

    // ---------------------------------------------------------------------
    // 10. True wind angle (port/starboard)
    // ---------------------------------------------------------------------
    double windDirection = heading_resolve(data.ctw - data.twdOverWater);
    wxString windDirectionLabel =
        windDirection <= 0
            ? wxString::Format("%.0f starboard", fabs(windDirection))
            : wxString::Format("%.0f port", fabs(windDirection));
    dlg.m_stTWA->SetLabel(windDirectionLabel);

    // ---------------------------------------------------------------------
    // 11. Apparent wind speed
    // ---------------------------------------------------------------------
    float apparentWindSpeed =
        Polar::VelocityApparentWind(data.stw, windDirection, data.twsOverWater);
    dlg.m_stAWS->SetLabel(wxString::Format("%.0f knts", apparentWindSpeed));

    // ---------------------------------------------------------------------
    // 12. Apparent wind angle (port/starboard)
    // ---------------------------------------------------------------------
    float apparentWindDirection = Polar::DirectionApparentWind(
        apparentWindSpeed, data.stw, windDirection, data.twsOverWater);

    wxString apparentWindDirectionLabel =
        apparentWindDirection <= 0
            ? wxString::Format("%.0f starboard", fabs(apparentWindDirection))
            : wxString::Format("%.0f port", fabs(apparentWindDirection));
    dlg.m_stAWA->SetLabel(apparentWindDirectionLabel);

    // ---------------------------------------------------------------------
    // 13. Waves & wind gusts
    // ---------------------------------------------------------------------
    dlg.m_stWaves->SetLabel(wxString::Format("%.0f m", data.WVHT));
    dlg.m_stWindGust->SetLabel(wxString::Format("%.0f knts", data.VW_GUST));

    // ---------------------------------------------------------------------
    // 14. Climatology / GRIB data mask summary
    // ---------------------------------------------------------------------
    wxString weatherdata;
    wxString grib = _("Grib") + " ";
    wxString climatology = _("Climatology") + " ";
    wxString data_deficient = _("Data Deficient") + " ";
    wxString wind = _("Wind") + " ";
    wxString current = _("Current") + " ";

    if (closestPosition) {
      dlg.m_stSailChanges->SetLabel(
          wxString::Format("%d", closestPosition->SailChanges()));

      if (closestPosition->data_mask & DataMask::GRIB_WIND)
        weatherdata += grib + wind;
      if (closestPosition->data_mask & DataMask::CLIMATOLOGY_WIND)
        weatherdata += climatology + wind;
      if (closestPosition->data_mask & DataMask::DATA_DEFICIENT_WIND)
        weatherdata += data_deficient + wind;

      if (closestPosition->data_mask & DataMask::GRIB_CURRENT)
        weatherdata += grib + current;
      if (closestPosition->data_mask & DataMask::CLIMATOLOGY_CURRENT)
        weatherdata += climatology + current;
      if (closestPosition->data_mask & DataMask::DATA_DEFICIENT_CURRENT)
        weatherdata += data_deficient + current;

      dlg.m_stWeatherData->SetLabel(weatherdata);
    }

    // ---------------------------------------------------------------------
    // 15. Fit dialog to updated content
    // ---------------------------------------------------------------------
    dlg.Fit();
  }



// -----------------------------------------------------------------------------
   // This is the parameterless version that uses the member dialog instance
  // It can be called from anywhere in the code without needing to pass the
  // dialog reference
  // -----------------------------------------------------------------------------
  void WeatherRouting::UpdateRoutePositionDialog() {
    // Dialog not yet visible ? nothing to do
    if (!m_RoutePositionDialog.IsShown()) return;

    // Panel or list control not ready yet ? bail out
    if (!m_panel || !m_panel->m_lWeatherRoutes) return;

    // No overlays yet ? nothing meaningful to show
    if (m_RouteMapOverlays.empty()) return;

    UpdateRoutePositionDialog(m_RoutePositionDialog);
  }



// clean, compact way to bail out of a function when something fail
// Store the error code.Jump to a cleanup label at the bottom of the function.
// This makes the macro behave like a single statement, so you can safely write:
// if(!OpenXML()) FAIL(1);     without breaking the if block.
// plugin has several functions that:open files, parse XML,
// allocate objects, need cleanup on failure

#define FAIL(X)  \
  do {           \
    error = X;   \
    goto failed; \
  } while (0)


// OLD CODE NO LONGER USED
// Starts the scheduler timer.  OLDER
/* ^void WeatherRouting::UpdateComputeState() {
  m_panel->m_gProgress->SetRange(m_RoutesToRun);
  m_panel->m_gProgress->SetValue(0);
  m_mCompute->Enable();
  m_panel->m_bCompute->Enable();
  m_StartTime = wxDateTime::Now();
  m_tCompute.Start(1, true);
}
*/


/*********************************************************/
/*   3. Invariants Violation  Guardrails                 */
/*********************************************************/

void WeatherRouting::AssertAllInvariants() {
  AssertSchedulerInvariants();
  AssertThreadLifecycleInvariants();
}

void WeatherRouting::AssertSchedulerInvariants() {
  // No overlay appears in both lists
  for (auto* ov : m_WaitingRouteMaps) {
    wxASSERT_MSG(std::find(m_RunningRouteMaps.begin(), m_RunningRouteMaps.end(),
                           ov) == m_RunningRouteMaps.end(),
                 "Overlay appears in both waiting and running lists");
  }

  // Running overlays must have threads
  for (auto* ov : m_RunningRouteMaps) {
    wxASSERT_MSG(ov->HasThread(), "Running overlay has no thread");
  }

  // Waiting overlays must NOT have threads
  for (auto* ov : m_WaitingRouteMaps) {
    wxASSERT_MSG(!ov->HasThread(), "Waiting overlay incorrectly has a thread");
  }
}


void WeatherRouting::AssertThreadLifecycleInvariants() {
  for (auto* ov : m_RouteMapOverlays) {
    if (!ov) continue;

    // If overlay says it has a thread, pointer must be valid
    if (ov->HasThread()) {
      wxASSERT_MSG(ov->m_Thread != nullptr,
                   "Overlay reports HasThread() but m_Thread is null");
    }

    // If overlay is running, thread must be alive
    if (ov->Running()) {
      wxASSERT_MSG(ov->HasThread(),
                   "Overlay reports Running() but HasThread() is false");
    }

    // If overlay is finished, thread must be gone
    if (ov->Finished()) {
      wxASSERT_MSG(!ov->HasThread(),
                   "Overlay reports Finished() but thread still exists");
    }

    // If overlay is stopped, thread must be gone
    if (ov->m_Stopped) {
      wxASSERT_MSG(!ov->HasThread(),
                   "Overlay reports m_Stopped but thread still exists");
    }
  }
}


/*********************************************************/
/*   3. Initialization Helper                              */
/*********************************************************/
//StartCompute
//   Column initialization, Timer setup, Dialog creation
//   Event bindings
//  NOTE: Heavy lifting initialization is in Initialize()
//   to keep constructor clean
//  This method is called by Initialize() after
//    the plugin environment is fully ready for use.
//  This funcion starts the compute timer if there is work to do.
//   Alternatively, StartCompute() can be called
//  from other places when new work is added.
//*********************************************************/

/* Kick start the scheduler and computing*/
void WeatherRouting::StartCompute() {
  // Only start the scheduler timer if:
  // 1. We actually have work to do (m_bRunning == true)
  // 2. The timer is not already running
  if (m_bRunning && !m_tCompute.IsRunning()) {
    wxLogMessage("StartCompute(): Starting scheduler timer (25ms one-shot)");
    m_tCompute.Start(25, true);
  }
  AssertThreadLifecycleInvariants();
}


bool WeatherRouting::IsWaiting(const RouteMapOverlay* rmo) const {
  for (auto* w : m_WaitingRouteMaps)
    if (w == rmo) return true;
  return false;
}


/******************************************************************/
/*  4. Top?Level Thread and UI Syncrhonization and Event Handlers */
/******************************************************************/

//-----------------------------------------------------------------
//   4.1 EVT_ROUTEMAP_UPDATE Handler(UI Choke Point)
//-----------------------------------------------------------------
// This is the single choke point for all UI updates.
// All worker-thread completions funnel through this event.
// Ensures UpdateStates(), UpdateDialogs(), and UpdateComputeState()
// run on the main thread in a race-free, deterministic order.
// NOTE: This event is posted by worker threads when they complete
// their computations. All UI updates MUST occur here!!!
//-----------------------------------------------------------------

void WeatherRouting::OnRouteMapUpdate(wxThreadEvent& event) {
  wxLogMessage("WeatherRouting::OnRouteMapUpdate - BEGIN");

  UpdateStates();        // must run first
  UpdateDialogs();       // refresh dependent dialogs
  UpdateComputeState();  // update compute button, etc.

  wxLogMessage("WeatherRouting::OnRouteMapUpdate - END");
}

//-----------------------------------------------------------------
// Core UI Update Methods
//-----------------------------------------------------------------
// UpdateStates
//   Walks all WeatherRoute objects, checks their associated
//   RouteMapOverlay state, updates WeatherRoute fields,
//   and refreshes the corresponding wxListCtrl row if needed.
// UpdateDialogs
//   Updates all open dialogs (Statistics, Report, Plot)
//   with the current RouteMapOverlay data.
// UpdateComputeState
//   Updates the Compute button, Stop button, progress bar,
//   and status text based on the current state of all
//   RouteMapOverlay objects.


void WeatherRouting::UpdateStates() {
  int index = 0;

  for (auto* wr : m_WeatherRoutes) {
    RouteMapOverlay* ov = wr->routemapoverlay;

    bool changed = false;
    wxString newState;

    // Snapshot overlay state for logging
    const bool hasOverlay = (ov != nullptr);
    const bool isDirty = hasOverlay && ov->IsDirty();
    const bool hasThread = hasOverlay && ov->HasThread();
    const bool finished = hasOverlay && ov->Finished();
    const bool reachedDest = hasOverlay && ov->ReachedDestination();
    const bool stopped = hasOverlay && ov->m_Stopped;

    // --- 1. Determine the new state --------------------------------
    if (!hasOverlay) {
      newState = _("Not Computed");
    } else if (isDirty) {
      newState = _("Ready");
      ov->ClearDirty();  // consume dirty flag
      changed = true;
    } else if (hasThread) {
      newState = _("Computing");
    } else if (finished && reachedDest) {
      newState = _("Complete");
    } else if (finished) {
      newState = _("Ready");
    } else {
      newState = _("Not Computed");
    }

    // --- 2. Update the model if the state changed ------------------
    if (wr->State != newState) {
      wxLogMessage(
          "WeatherRouting::UpdateStates route %d: '%s' -> '%s' "
          "(hasOverlay=%d, dirty=%d, hasThread=%d, finished=%d, "
          "reachedDest=%d, stopped=%d)",
          index, wr->State.mb_str(), newState.mb_str(), hasOverlay, isDirty,
          hasThread, finished, reachedDest, stopped);

      wr->State = newState;
      wr->StateChanged = true;
      changed = true;
    }

    // --- 3. Update other columns (distance, ETA, etc.) -------------
    wr->Update(this, changed);

    // --- 4. Refresh the UI row only if something changed -----------
    if (changed) {
      UpdateItem(index, true);

      wxLogMessage(
          "WeatherRouting::UpdateStates route %d: UI row refreshed "
          "(StateChanged=%d)",
          index, wr->StateChanged ? 1 : 0);
    }

    // Reset per?iteration flag
    wr->StateChanged = false;
    index++;
  }
}

void WeatherRouting::UpdateDialogs() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  long item = -1;
  while (true) {
    item = list->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr =
        reinterpret_cast<WeatherRoute*>(wxUIntToPtr(list->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  // ---------------------------------------------------------------------
  // 2. Statistics Dialog
  // ---------------------------------------------------------------------
  if (m_StatisticsDialog.IsShown()) {
    m_StatisticsDialog.SetRouteMapOverlays(overlays);
    m_StatisticsDialog.Refresh();
  }

  // ---------------------------------------------------------------------
  // 3. Report Dialog
  // ---------------------------------------------------------------------
  if (m_ReportDialog.IsShown()) {
    m_ReportDialog.SetRouteMapOverlays(overlays);
    m_ReportDialog.Refresh();
  }

  // ---------------------------------------------------------------------
  // 4. Plot Dialog (uses only the first selected overlay)
  // ---------------------------------------------------------------------
  if (m_PlotDialog.IsShown()) {
    RouteMapOverlay* first = overlays.empty() ? nullptr : overlays.front();
    m_PlotDialog.SetRouteMapOverlay(first);
    m_PlotDialog.Refresh();
  }
}

void WeatherRouting::UpdateComputeState() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  if (!m_panel) return;

  // Count how many overlays are in each state
  int computing = 0;
  int ready = 0;
  int notComputed = 0;
  int complete = 0;

  for (auto* wr : m_WeatherRoutes) {
    RouteMapOverlay* ov = wr->routemapoverlay;

    if (!ov) {
      notComputed++;
      continue;
    }

    if (ov->HasThread()) {
      computing++;
    } else if (ov->Finished() && ov->ReachedDestination()) {
      complete++;
    } else if (ov->Finished()) {
      ready++;
    } else {
      notComputed++;
    }
  }

  // --- Compute button logic ---
  bool canCompute = (ready > 0 || notComputed > 0);
  m_panel->m_bCompute->Enable(canCompute);

  // --- Stop button logic ---
  bool canStop = (computing > 0);
  m_panel->SetStopButtonEnabled(canStop);

  // --- Progress bar ---
  int total = m_WeatherRoutes.size();
  int done = complete + ready;

  m_panel->m_gProgress->SetRange(total);
  m_panel->m_gProgress->SetValue(done);

  // --- Status text ---
  wxString status;

  if (computing > 0)
    status = _("Computing routes");
  else if (complete > 0)
    status = _("Routes computed");
  else if (ready > 0)
    status = _("Ready");
  else
    status = _("Not computed");

  m_panel->SetStatusText(status);
}

//-----------------------------------------------------------------
// UpdateItem (Rows)
//-----------------------------------------------------------------
// UpdateStates() decides whether to call UpdateItem(index, true)
// UpdateItem() always writes the full row
// The list control is cheap to update
// The changed flag is only used by the caller to avoid unnecessary calls
// "Changed" flag controls whether UpdateItem is called
// UpdateItem does not need to know why it was called

void WeatherRouting::UpdateItem(int index, bool changed) {
  // Validate index against model
  if (index < 0 || index >= (int)m_WeatherRoutes.size()) return;

  // Validate UI panel and list control
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  // Validate index against UI list
  if (index < 0 || index >= list->GetItemCount()) return;

  // Retrieve WeatherRoute*
  auto it = m_WeatherRoutes.begin();
  std::advance(it, index);
  WeatherRoute* wr = *it;

  RouteMapOverlay* ov = wr->routemapoverlay;

  // --- Always write the State column ---
  SetColumn(index, STATE, wr->State);

  // --- Always write static configuration columns ---
  UpdateStaticColumns(index, wr);

  // If route not computed yet, leave computed columns blank
  if (!ov || !ov->Finished() || ov->GetIsoChronList().empty()) {
    ClearComputedColumns(index);
    return;
  }

  // --- Now write computed columns ---
  const auto& origin = ov->GetIsoChronList();
  IsoChron* firstIso = origin.front();
  IsoChron* lastIso = origin.back();

  if (!firstIso || !lastIso) {
    ClearComputedColumns(index);
    return;
  }

  // Start Time
  SetColumn(index, STARTTIME, firstIso->time.FormatISOCombined(' '));

  // End Time
  SetColumn(index, ENDTIME, lastIso->time.FormatISOCombined(' '));

  // Duration
  wxTimeSpan span = lastIso->time - firstIso->time;
  SetColumn(index, TIME, span.Format("%H:%M"));

  // Distance
  double dist = 0.0;
  const Position* dest = nullptr;

  if (ov->Finished() && ov->ReachedDestination())
    dest = ov->GetDestinationPosition();

  if (dest) dist = ComputeRouteDistance(dest);

  SetColumn(index, DISTANCE, wxString::Format("%.1f nm", dist));

  // Computed values
  UpdateComputedColumns(index, wr);
}


//-----------------------------------------------------------------
// UpdateAllItems
//-----------------------------------------------------------------
// Updates all rows

void WeatherRouting::UpdateAllItems(bool changed) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  if (m_WeatherRoutes.empty()) return;

  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  lc->Freeze();

  int index = 0;
  for (auto* wr : m_WeatherRoutes) {
    UpdateItem(index++, changed);
  }

  if (changed) {
    for (int c = 0; c < NUM_COLS; c++) {
      if (columns[c] >= 0) lc->SetColumnWidth(columns[c], wxLIST_AUTOSIZE);
    }
  }

  lc->Thaw();
}


//-----------------------------------------------------------------
// UpdateColumns   
//-----------------------------------------------------------------
// Rebuilds the columns in the wxListCtrl based on user settings and updates all
// rows to reflect any changes (eg. local/UTC switch for time columns)
// Called when user changes column visibility settings or local/UTC time setting
// or when loading from XML to ensure correct columns are shown
// and all data is up to date
// MODERN IMPLEMENTATION

void WeatherRouting::UpdateColumns() {
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;
  list->DeleteAllColumns();

  for (int i = 0; i < NUM_COLS; i++) {
    if (GetSettingsDialog().m_cblFields->IsChecked(i)) {
      columns[i] = list->GetColumnCount();
      wxString name = _(column_names[i]);

      if (i == STARTTIME || i == ENDTIME) {
        name += " (";
        name += GetSettingsDialog().m_cbUseLocalTime->GetValue() ? _("local")
                                                                 : "UTC";
        name += ")";
      }

      list->InsertColumn(columns[i], name);
      list->SetColumnWidth(columns[i], wxLIST_AUTOSIZE);
    } else {
      columns[i] = -1;
    }
  }

  int index = 0;
  for (auto* wr : m_WeatherRoutes) {
    list->SetItemPtrData(index, (wxUIntPtr)wr);
    wr->Update(this);  // update utc/local time strings
    UpdateItem(index, true);
    index++;
  }
  wxListEvent dummy;
  OnWeatherRouteSelected(dummy);   ;  // update dialogs if visible
}


//-----------------------------------------------------------------------
// Update method for WeatherRoute (Time)
//-----------------------------------------------------------------------
// The state machine now lives in:WeatherRouting::UpdateStates()
// This method is purely for updating computed fields based on the current
// state of the RouteMapOverlay UpdateColumns() calls wr->Update(this)
// which updates the time strings based on the UTC local toggle
// then UpdateItem() writes those strings into the list control


void WeatherRoute::Update(WeatherRouting* parent, bool fullUpdate) {
  // ---------------------------------------------------------------------
  // 1. Update state string (WeatherRouting already computed the state)
  // ---------------------------------------------------------------------
  if (fullUpdate) {
    if (!routemapoverlay)
      State = _("Not Computed");
    else if (routemapoverlay->HasThread())
      State = _("Computing");
    else if (routemapoverlay->Finished() &&
             routemapoverlay->ReachedDestination())
      State = _("Complete");
    else if (routemapoverlay->Finished())
      State = _("Ready");
    else
      State = _("Not Computed");
  }

  // ---------------------------------------------------------------------
  // 2. Update time strings (UTC/local toggle)
  // ---------------------------------------------------------------------
  if (routemapoverlay && routemapoverlay->Finished()) {
    const auto& iso = routemapoverlay->GetIsoChronList();
    if (!iso.empty()) {
      IsoChron* firstIso = iso.front();
      IsoChron* lastIso = iso.back();

      if (firstIso && lastIso) {
        bool useLocal =
            parent->GetSettingsDialog().m_cbUseLocalTime->GetValue();

        wxDateTime start = firstIso->time;
        wxDateTime end = lastIso->time;

        if (useLocal) {
          start.MakeFromUTC();
          end.MakeFromUTC();
        }

        StartTimeString = start.FormatISOCombined(' ');
        EndTimeString = end.FormatISOCombined(' ');

        wxTimeSpan span = end - start;
        DurationString = span.Format("%H:%M");
      }
    }
  } else {
    StartTimeString.clear();
    EndTimeString.clear();
    DurationString.clear();
  }

  // ---------------------------------------------------------------------
  // 3. Distance and other computed fields are now handled in UpdateItem()
  // ---------------------------------------------------------------------
}


//-----------------------------------------------------------------
// ComputeStateString
//-----------------------------------------------------------------
// This method computes the state string for a given RouteMapOverlay.
// It is used by WeatherRoute::Update() to set the State field based on the
// current status of the overlay. The logic is:
// - If no overlay, return "Not Computed"
// - If dirty, return "Ready"
// - If has active thread, return "Computing"
// - If finished and reached destination, return "Complete"
// - If finished but not at destination, return "Ready"
// - Default fallback: "Not Computed"
// This method is purely a string computation based on the overlay state.
// The actual state machine logic lives in WeatherRouting::UpdateStates() which
// sets the WeatherRoute->State field and controls when UpdateItem() is called.
// This separation allows us to keep the state machine logic in one place
// and the string representation logic in another, making it easier to maintain
// and test each part independently.
// Note: WeatherRouting::UpdateStates() is responsible for calling this method
// and then updating the WeatherRoute->State field accordingly.
// WeatherRoute::Update()
// calls this method indirectly through WeatherRouting::UpdateStates() and
// then updates the list control through WeatherRouting::UpdateItem() if needed.
// This method does NOT have any side effects and does not modify the overlay
// or the WeatherRoute. It simply returns the appropriate string based on the
// current state of the overlay.
//-----------------------------------------------------------------

wxString WeatherRouting::ComputeStateString(const RouteMapOverlay* ov) const {
  // No overlay ? nothing has been computed yet
  if (!ov) return _("Not Computed");

  // Dirty means configuration changed and route is ready to recompute
  if (ov->IsDirty()) return _("Ready");

  // Active worker thread
  if (ov->HasThread()) return _("Computing");

  // Finished and reached destination
  if (ov->Finished() && ov->ReachedDestination()) return _("Complete");

  // Finished but not at destination ? Ready to recompute
  if (ov->Finished()) return _("Ready");

  // Default fallback
  return _("Not Computed");
}



//-----------------------------------------------------------------
// End of Core UI Update Methods
//-----------------------------------------------------------------



//----------------------------------
//   4.1 File / Session
//----------------------------------
// OnOpen
//    Opens an existing weather routing configuration XML file.
// OnSave
//    Saves the current configuration to the existing XML file.
// OnSaveAs
//    Saves the current configuration to a new XML file.
//----------------------------------


void WeatherRouting::OnOpen(wxCommandEvent& event) {
  wxString error;
  wxFileDialog openDialog(
      this, _("Select Configuration"), m_FileName.GetPath(),
      m_FileName.GetName(),
      wxT("XML files (*.xml)|*.XML;*.xml|All files (*.*)|*.*"), wxFD_OPEN);

  if (openDialog.ShowModal() == wxID_OK) {
    wxCommandEvent event;
    OnDeleteAllPositions(event);
    OnDeleteAll(event);
    OpenXML(openDialog.GetPath());
  }
}

void WeatherRouting::OnSave(wxCommandEvent& event) {
  if (m_FileName.GetFullPath().IsEmpty()) {
    // No file path set yet, behave like Save As
    OnSaveAs(event);
    return;
  }

  SaveXML(m_FileName.GetFullPath());
  m_tAutoSaveXML
      .Stop();  // Stop any pending auto-save since we just manually saved
}

void WeatherRouting::OnSaveAs(wxCommandEvent& event) {
  wxString error;
  wxFileDialog saveDialog(
      this, _("Select Configuration"), m_FileName.GetPath(),
      m_FileName.GetName(),
      wxT("XML files (*.xml)|*.XML;*.xml|All files (*.*)|*.*"),
      wxFD_SAVE | wxFD_OVERWRITE_PROMPT);

  if (saveDialog.ShowModal() == wxID_OK) {
    // Use wxFileDialog::AppendExtension to ensure the file has the .xml
    // extension
    wxString filename =
        wxFileDialog::AppendExtension(saveDialog.GetPath(), "*.xml");

    SaveXML(filename);
    m_tAutoSaveXML
        .Stop();  // Stop any pending auto-save since we just manually saved
  }
}


/***********************************************************************
 * WeatherRouting Close Handlers
 *
 * WeatherRouting implements two different OnClose() handlers:
 *
 *   1. void OnClose(wxCloseEvent& event)
 *   2. void OnClose(wxCommandEvent& event)
 *
 * These two handlers serve different purposes and MUST NOT call each
 * other recursively. Their responsibilities are intentionally distinct:
 *
 * --------------------------------------------------------------------
 * 1. OnClose(wxCloseEvent&)
 * --------------------------------------------------------------------
 * Triggered when the user clicks the window managers X button or
 * when wxWidgets attempts to close the panel programmatically.
 *
 * OpenCPN plugins must NEVER allow their main panel to be destroyed
 * by a wxCloseEvent. The panel is owned by OpenCPN, not the plugin.
 *
 * Therefore:
 *   - We VETO the close request to prevent destruction.
 *   - We forward the intent to the command-version handler so the
 *     plugin can hide itself cleanly.
 *
 * This keeps the plugin alive and prevents crashes or dangling pointers.
 *
 * --------------------------------------------------------------------
 * 2. OnClose(wxCommandEvent&)
 * --------------------------------------------------------------------
 * Triggered when the plugin itself decides to close/hide the panel
 * (toolbar button, menu item, or forwarded from the wxCloseEvent
 * handler above).
 *
 * This handler performs the *actual* close behavior:
 *   - Hide the panel (never destroy it)
 *   - Stop computations safely
 *   - Persist visibility state
 *   - Update menus and refresh UI
 *
 * This is the correct OpenCPN plugin pattern: hide, don?t destroy.
 *
 * --------------------------------------------------------------------
 * Summary
 * --------------------------------------------------------------------
 * wxCloseEvent  -  Veto + forward to command handler
 * wxCommandEvent -  Perform safe hide + state updates
 *
 * This separation ensures:
 *   - No recursion
 *   - No accidental destruction
 *   - Clean shutdown of computations
 *   - Correct persistence of UI state
 *   - Full compatibility with OpenCPN?s plugin lifecycle
 ***********************************************************************/


void WeatherRouting::OnClose(wxCommandEvent& event) {
  // handler for your plugin?s own ?Close/Hide? command.
  // Hide the panel instead of destroying it.
  // This is the standard OpenCPN plugin pattern.
  Hide();

  // Persist window state (size, position, visibility)
  wxFileConfig* pConf = GetOCPNConfigObject();
  if (pConf) {
    pConf->SetPath("/Plugins/WeatherRouting");
    pConf->Write("Visible", false);
  }

  // Stop any running computations safely
  StopAll();

  // Update menus and toolbar buttons
  SetEnableConfigurationMenu();

  // Ensure UI refreshes cleanly
  GetParent()->Refresh();
}

void WeatherRouting::OnClose(wxCloseEvent& event) {
  // Window Manager close or plugin hide command received.
  // Prevent wxWidgets from destroying the panel.
  // OpenCPN owns this window; plugins must never allow destruction here.
  event.Veto();

  // Convert the window-manager close (clicking ?X?) into the same behavior
  // as pressing the plugin?s own ?close/hide? command.
  wxCommandEvent cevent;
  OnClose(cevent);  // Call the command-version safely

  // No event.Skip() here ? we?ve handled the close fully.
}
void WeatherRouting::OnAutoSaveXMLTimer(wxTimerEvent&) { AutoSaveXML(); }

void WeatherRouting::AutoSaveXML() { SaveXML(m_FileName.GetFullPath()); }


//----------------------------------
//   4.2 Route Creation / Deletion
//----------------------------------
// OnNew
//    Creates a new routing configuration.
// OnRenderedTimer
//    Sets initial sash position after rendering starts.
// OnSize
//    Handles resizing of the main panel.
// OnCollPaneChanged
//    Handles changes to the collapsible pane state.
// OnDelete
//    Deletes selected routing configurations.
// OnDeleteAll
//    Deletes all routing configurations
// OnEditPosition - Seen in Position Management section
//    Edits the selected position. See 6. Position Management section. 
//----------------------------------


void WeatherRouting::OnNew(wxCommandEvent& event) {
  // Create an empty configuration object
  RouteMapConfiguration configuration;

  // Pass the configuration into the dialog
  m_ConfigurationDialog.SetConfiguration(configuration);

  // Show the dialog (no arguments allowed)
  if (m_ConfigurationDialog.ShowModal() != wxID_OK) {
    // User cancelled
    return;
  }

  // Retrieve the updated configuration from the dialog
  configuration = m_ConfigurationDialog.GetConfiguration();

  // Add the new configuration to the model + UI
  if (!AddConfiguration(configuration)) {
    wxMessageDialog mdlg(this, _("Failed to create new routing configuration."),
                         _("Weather Routing"), wxOK | wxICON_ERROR);
    mdlg.ShowModal();
    return;
  }

  // Update menus and UI state
  SetEnableConfigurationMenu();
}

void WeatherRouting::OnRenderedTimer(wxTimerEvent&) {
  // don't do it until the window system is up and running
  if (GetClientSize().GetWidth() > 20) {
    if (!sashpos) sashpos = GetClientSize().GetWidth() / 5;
    m_panel->m_splitter1->SetSashPosition(sashpos, true);
    Disconnect(wxEVT_IDLE, wxTimerEventHandler(WeatherRouting::OnRenderedTimer),
               NULL, this);
  }
}

void WeatherRouting::OnSize(wxSizeEvent& event) {
  if (m_colpane && m_colpane->IsExpanded()) {
    Update();
    Layout();
    m_size = GetSize();
  } else {
    if (m_colpane) Fit();
  }
  event.Skip();
}

//-
void WeatherRouting::OnCollPaneChanged(wxCollapsiblePaneEvent& event) {
  if (m_colpane && m_colpane->IsExpanded())
    SetSize(m_size);
  else if (m_colpane)
    Fit();
  Update();
  Layout();
}


//----------------------------------
//   4.3 Reset
//----------------------------------
// OnReset  
// .. Resets a route
// OnResetSelected
//    Resets selected routes.
// OnResetAll
//    Resets all routes.
//----------------------------------

//void WeatherRouting::OnReset(wxCommandEvent& event)
//  { ResetAll();
//}

void WeatherRouting::OnResetSelected(wxCommandEvent& event) {
  ResetSelected();
}

void WeatherRouting::OnResetAll(wxCommandEvent& event) {
   m_StatisticsDialog.SetRunTime(m_RunTime = wxTimeSpan(0));
   ResetAll();
}


//----------------------------------
//   4.4 Compute / Stop
//----------------------------------
// OnCompute
//   build waiting list from selected routes
// OnComputeAll
//   build waiting list from all routes
// OnComputationTimer
//   the actual routing engine
// OnComputeAll
//    Starts route computation for all routes.
// OnStop
//    Stops route computation for selected routes.
// RouteMapOverlay
//  each overlay has its own thread and state machine
// Start
//   create worker threads
// StartAll
//   create worker threads for all routes
// Stop
//   signal worker threads to stop, but do not wait for them here. The threads
// StartCompute
//  Keep small prevents subtle bugs and makes the scheduler predictable.

//----------------------------------

void WeatherRouting::OnCompute(wxCommandEvent& event) {
#ifdef PLUGIN_USE_ASM
  // If the address space monitor is active and memory is critically low,
  // route computation is disabled to prevent instability.
  if (m_addressSpaceMonitor && m_addressSpaceMonitor->IsComputationDisabled()) {
    wxMessageBox(
        _("Route computation is currently disabled due to high memory usage.\n"
          "Use Reset All or wait until memory is available."),
        _("Weather Routing - Memory Alert"), wxOK | wxICON_WARNING);
    return;
  }
#endif

  wxLogMessage("OnCompute(): Preparing selected routes for computation.");

  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  //    The list control is the authoritative source of selection.
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> selectedOverlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    // Retrieve the WeatherRoute associated with this row
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    // Only enqueue overlays that actually exist
    if (wr && wr->routemapoverlay)
      selectedOverlays.push_back(wr->routemapoverlay);
  }

  // If nothing is selected, there is nothing to compute
  if (selectedOverlays.empty()) return;

  // ---------------------------------------------------------------------
  // 2. Reset scheduler lists
  //    These lists drive the asynchronous computation scheduler.
  // ---------------------------------------------------------------------
  m_WaitingRouteMaps.clear();
  m_RunningRouteMaps.clear();

  // ---------------------------------------------------------------------
  // 3. Populate the waiting list with selected overlays
  // ---------------------------------------------------------------------
  for (auto* ov : selectedOverlays) m_WaitingRouteMaps.push_back(ov);

  // ---------------------------------------------------------------------
  // 4. Initialize scheduler counters and state
  // ---------------------------------------------------------------------
  m_RoutesToRun = m_WaitingRouteMaps.size();
  m_bRunning = (m_RoutesToRun > 0);

  // ---------------------------------------------------------------------
  // 5. If there is work to do, update UI and start the scheduler
  // ---------------------------------------------------------------------
  if (m_bRunning) {
    UpdateComputeState();  // Update buttons, progress bar, status text
    StartCompute();        // Begin timed scheduling of route computations
  }
}


void WeatherRouting::OnComputeAll(wxCommandEvent& event) {
#ifdef PLUGIN_USE_ASM
  if (m_addressSpaceMonitor && m_addressSpaceMonitor->IsComputationDisabled()) {
    wxMessageBox(
        _("Route computation is currently disabled due to high memory usage.\n"
          "Use Reset All or wait until memory is available."),
        _("Weather Routing - Memory Alert"), wxOK | wxICON_WARNING);
    return;
  }
#endif

  wxLogMessage(
      "OnComputeAll(): For all Routes, Prep to compute, Create Overlay wait "
      "list, Clear running list, Call StartCompute.");

  // Build waiting list from ALL route overlays
  StartAll();  // fills m_WaitingRouteMaps, sets m_bRunning, m_RoutesToRun

  if (!m_bRunning) return;  // nothing to compute

  // Initialize progress bar if present
  if (m_panel && m_panel->m_gProgress) {
    m_panel->m_gProgress->SetRange(m_RoutesToRun);
    m_panel->m_gProgress->SetValue(0);
  }

  UpdateComputeState();  // update UI (buttons, labels, etc.)
  StartCompute();        // ignite the scheduler timer
}




void WeatherRouting::OnStop(wxCommandEvent& event) {
  wxLogMessage("OnStop(): stopping selected routes");

  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  //    The list control is the authoritative source of selection.
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> selectedOverlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    // Retrieve the WeatherRoute associated with this row
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay)
      selectedOverlays.push_back(wr->routemapoverlay);
  }

  // If nothing is selected, nothing to stop
  if (selectedOverlays.empty()) return;

  // ---------------------------------------------------------------------
  // 2. Signal each selected overlay to stop
  //    Stop(ov) sets the overlay's stop flag; the scheduler timer
  //    will handle cleanup and thread shutdown.
  // ---------------------------------------------------------------------
  for (auto* ov : selectedOverlays) {
    if (!ov) continue;
    Stop(ov);
  }

  // ---------------------------------------------------------------------
  // 3. Update UI state (buttons, labels, progress bar, etc.)
  // ---------------------------------------------------------------------
  UpdateComputeState();

  // Optional: debug-only invariant check could go here
}




//------------------------------------------
//   4.5 Selection / Sorting / Interaction
//------------------------------------------- List Includes Control Event Handlers --
// 
// OnWeatherRouteSelected
//    Updates the configuration dialog when the user selects a route.
// OnWeatherPositionSelected
//    Updates the position dialog when the user selects a position.
// OnWeatherRouteSort
//    Sorts the weather routes list when the user clicks a column header.
// OnWeatherRoutesListLeftDown
//    Handles clicks on the visibility column to toggle route visibility.
// OnWeatherRouteKeyDown
//    Handles delete key to remove selected routes.
// OnListLabelEdit
//   Handles in-place editing of route names and positions.(NOT USED)
//
//
// -----------------------------------------
// OnPositionKeyDown
// OnRouteSelected
// OnCursorRouteChanged if event driven
//------------------------------------------



// ============================================================================
// WeatherRouting::OnWeatherRoutesListLeftDown
// Modern visibility-toggle handler for the WeatherRoutes list control.
// ============================================================================

void WeatherRouting::OnWeatherRoutesListLeftDown(wxMouseEvent& event) {
  // Preserve long?press behavior for context menu
  OnLeftDown(event);

  // Ensure the modern panel exists
  if (!m_panel || !m_panel->m_lWeatherRoutes) {
    event.Skip();
    return;
  }

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  wxPoint pos = event.GetPosition();
  int flags = 0;

  // Determine which row was clicked
  long index = list->HitTest(pos, flags);
  if (index < 0) {
    event.Skip();
    return;
  }

  // ---------------------------------------------------------------------
  // 1. Check if the Visibility column exists
  // ---------------------------------------------------------------------
  if (columns[VISIBLE] >= 0) {
    int col = columns[VISIBLE];

    int minx = 0;
    int maxx = list->GetColumnWidth(col);

    // -----------------------------------------------------------------
    // 2. Did the user click inside the Visibility column?
    // -----------------------------------------------------------------
    if (event.GetX() >= minx && event.GetX() < maxx) {
      // Retrieve the WeatherRoute* stored in the row
      WeatherRoute* wr =
          reinterpret_cast<WeatherRoute*>(list->GetItemData(index));

      if (!wr || !wr->routemapoverlay) {
        event.Skip();
        return;
      }

      // -----------------------------------------------------------------
      // 3. Toggle visibility
      // -----------------------------------------------------------------
      wr->routemapoverlay->m_bEndRouteVisible =
          !wr->routemapoverlay->m_bEndRouteVisible;

      // -----------------------------------------------------------------
      // 4. Update the row in the UI
      // -----------------------------------------------------------------
      UpdateItem(index, false);

      // -----------------------------------------------------------------
      // 5. Refresh the chart
      // -----------------------------------------------------------------
      RequestRefresh(GetParent());

      // We handled the click ? do not let wxWidgets re?select the row
      return;
    }
  }

  // Allow default selection behavior for all other columns
  event.Skip();
}



void WeatherRouting::OnWeatherRouteKeyDown(wxListEvent& event) {
  // Ensure the new UI panel and list control exist
  if (!m_panel || !m_panel->m_lWeatherRoutes) {
    event.Skip();
    return;
  }

  switch (event.GetKeyCode()) {
    case WXK_DELETE: {
      wxCommandEvent cmd;
      OnDelete(cmd);
      break;
    }
    default:
      event.Skip();
  }
}



//------------------------------------------
//   4.6 Navigation
//------------------------------------------
// OnGoTo
//    Jumps the chart to show all selected routes.



void WeatherRouting::OnGoTo(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // 1. Collect all valid RouteMapOverlays from m_WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  for (auto* wr : m_WeatherRoutes) {
    if (!wr || !wr->routemapoverlay) continue;

    RouteMapConfiguration cfg = wr->routemapoverlay->GetConfiguration();
    if (std::isnan(cfg.StartLat)) continue;  // skip invalid routes

    overlays.push_back(wr->routemapoverlay);
  }

  if (overlays.empty()) return;

  // ---------------------------------------------------------------------
  // 2. Compute centroid of all selected route start/end points
  // ---------------------------------------------------------------------
  double avg_lat = 0, avg_lonx = 0, avg_lony = 0, total = 0;

  for (auto* ov : overlays) {
    RouteMapConfiguration cfg = ov->GetConfiguration();
    if (std::isnan(cfg.StartLat)) continue;

    avg_lat += cfg.StartLat + cfg.EndLat;
    avg_lonx += cos(deg2rad(cfg.StartLon)) + cos(deg2rad(cfg.EndLon));
    avg_lony += sin(deg2rad(cfg.StartLon)) + sin(deg2rad(cfg.EndLon));

    total += 2;
  }

  avg_lat /= total;
  avg_lonx /= total;
  avg_lony /= total;

  double avg_lon = rad2deg(atan2(avg_lony, avg_lonx));

  // ---------------------------------------------------------------------
  // 3. Compute maximum distance from centroid to determine zoom level
  // ---------------------------------------------------------------------
  double max_distance = 0;

  for (auto* ov : overlays) {
    RouteMapConfiguration cfg = ov->GetConfiguration();
    if (std::isnan(cfg.StartLat)) continue;

    double distance;

    DistanceBearingMercator_Plugin(avg_lat, avg_lon, cfg.StartLat, cfg.StartLon,
                                   NULL, &distance);
    max_distance = wxMax(max_distance, distance);

    DistanceBearingMercator_Plugin(avg_lat, avg_lon, cfg.EndLat, cfg.EndLon,
                                   NULL, &distance);
    max_distance = wxMax(max_distance, distance);
  }

  // ---------------------------------------------------------------------
  // 4. Jump to the computed centroid with appropriate zoom
  // ---------------------------------------------------------------------
  if (max_distance > 1e-4) {
    JumpToPosition(avg_lat, avg_lon, .125 / max_distance);
  } else {
    wxMessageDialog mdlg(this, _("Cannot goto invalid route(s)."),
                         _("Weather Routing"), wxOK | wxICON_ERROR);
    mdlg.ShowModal();
  }
}

/* ============================================================
   UI UPDATE & DISPLAY SYNCHRONIZATION
   ------------------------------------------------------------
   Functions that refresh dialog state, map overlays, and
   presentation logic. These do not compute routing results.
   They only reflect current state into the UI.
   ============================================================ */
// UpdateDisplaySettings
//    Updates the display settings of all route map overlays
//    to reflect changes in global display options.
//    Called when global display settings change.
//    Marks all overlays for update and requests a refresh.
//------------------------------------------------------------


void WeatherRouting::UpdateDisplaySettings() {
  for (int i = 0; i < m_panel->m_lWeatherRoutes->GetItemCount(); i++) {
    WeatherRoute* weatherroute = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));
    weatherroute->routemapoverlay->m_UpdateOverlay = true;
  }

  GetParent()->Refresh();
}


/* ============================================================
   UI REACTION HANDLERS
   ------------------------------------------------------------
   Functions that respond to UI state changes (dialogs, radio
   buttons, selections) and update overlays or dialogs.
   These do not compute routing or modify configuration.
   ============================================================ */

double WeatherRouting::ComputeRouteDistance(const Position* dest) {
  double total = 0.0;

  const Position* p = dest;
  while (p && p->parent) {
    const Position* q = static_cast<const Position*>(p->parent);
    total += p->Distance(q);
    p = q;
  }

  return total;
}


// ============================================================================
// WeatherRouting::PopulatePositions
// Rebuilds the positions list control from RouteMap::Positions.
// ============================================================================
// Modern implementation of positions list population.

void WeatherRouting::PopulatePositions() {
  if (!m_PositionPanel || !m_PositionPanel->m_lPositions) return;

  wxListCtrl* list = m_PositionPanel->m_lPositions;

   // Determine which route is selected
  WeatherRoute* wr = GetSelectedRoute();
  if (!wr) {
    list->DeleteAllItems();
    return;
  }

  list->Freeze();
  list->DeleteAllItems();

  // Populate rows from wr->Positions
  int index = 0;
  for (const WeatherPoint& p : wr->Positions) {
    long row = list->InsertItem(list->GetItemCount(), p.Name);

    list->SetItem(row, POSITION_LAT,
                  toSDMM_PlugIn(NEflag::LAT, p.lat, Precision::HI));

    list->SetItem(row, POSITION_LON,
                  toSDMM_PlugIn(NEflag::LON, p.lon, Precision::HI));

    // Store the index so edit/delete handlers can find the right element
    list->SetItemPtrData(row, (wxUIntPtr)index);
    index++;
  }

  list->Thaw();
}





// ============================================================================
// WeatherRouting::AddConfiguration
// Creates a new WeatherRoute + RouteMapOverlay, applies configuration,
// loads start/end positions (if GUID present), inserts into UI, and autosaves.
// ============================================================================
// Modern implementation

bool WeatherRouting::AddConfiguration(RouteMapConfiguration& configuration) {
  wxLogMessage("WR: AddConfiguration() - BEGIN");

  // ---------------------------------------------------------------------
  // 1. Create WeatherRoute + Overlay
  // ---------------------------------------------------------------------
  WeatherRoute* weatherroute = new WeatherRoute;
  weatherroute->routemapoverlay = new RouteMapOverlay(this, weatherroute);

  RouteMapOverlay* ov = weatherroute->routemapoverlay;
  ov->SetConfiguration(configuration);
  ov->ResetFinished();  // modern clean state

  // ---------------------------------------------------------------------
  // 2. Load start/end positions if a Route GUID is provided
  // ---------------------------------------------------------------------
  if (!configuration.RouteGUID.IsEmpty()) {
    std::unique_ptr<PlugIn_Route> rte =
        GetRoute_Plugin(configuration.RouteGUID);
    if (rte && rte->pWaypointList) {
      wxPlugin_WaypointListNode* pwpnode = rte->pWaypointList->GetFirst();

      if (pwpnode) {
        // Start
        PlugIn_Waypoint* pwp = pwpnode->GetData();
        AddPosition(weatherroute, pwp->m_lat, pwp->m_lon, pwp->m_MarkName,
                    pwp->m_GUID);

        configuration.Start = pwp->m_MarkName;
        configuration.StartGUID = pwp->m_GUID;
        configuration.StartLat = pwp->m_lat;
        configuration.StartLon = pwp->m_lon;

        // End (walk to last waypoint)
        while (pwpnode->GetNext()) pwpnode = pwpnode->GetNext();

        pwp = pwpnode->GetData();
        AddPosition(weatherroute, pwp->m_lat, pwp->m_lon, pwp->m_MarkName,
                    pwp->m_GUID);

        configuration.End = pwp->m_MarkName;
        configuration.EndGUID = pwp->m_GUID;
        configuration.EndLat = pwp->m_lat;
        configuration.EndLon = pwp->m_lon;
      }
    }
  }
  // ---------------------------------------------------------------------
  // 3. Insert into model lists
  // ---------------------------------------------------------------------
  m_WeatherRoutes.push_back(weatherroute);

  // ---------------------------------------------------------------------
  // 4. Insert into the list control (modern panel)
  // ---------------------------------------------------------------------
  // ---------------------------------------------------------------------
  // 4. Insert into the list control (modern panel)
  // ---------------------------------------------------------------------
  if (m_panel && m_panel->m_lWeatherRoutes) {
    wxListCtrl* list = m_panel->m_lWeatherRoutes;

    wxListItem item;
    long index = list->InsertItem(list->GetItemCount(), item);

    list->SetItemPtrData(index, (wxUIntPtr)weatherroute);

    // Update UI row
    UpdateItem(index, true);
  }

  // ---------------------------------------------------------------------
  // 5. Autosave
  // ---------------------------------------------------------------------
  SaveXML();

  wxLogMessage("WR: AddConfiguration() - END");
  return true;
}




// ============================================================================
// WeatherRouting::UpdateBoatFilename
// Reapplies configuration + resets overlays whose boat file matches.
// ============================================================================
// Modern implementation

void WeatherRouting::UpdateBoatFilename(const wxString& boatFileName) {
  wxLogMessage("WR: UpdateBoatFilename() - BEGIN (%s)", boatFileName.mb_str());

  if (!m_panel || !m_panel->m_lWeatherRoutes)
      return;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  long count = list->GetItemCount();

  for (long i = 0; i < count; i++) {
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(list->GetItemData(i));
    if (!wr || !wr->routemapoverlay) continue;

    RouteMapOverlay* ov = wr->routemapoverlay;
    RouteMapConfiguration c = ov->GetConfiguration();

    if (c.boatFileName == boatFileName) {
      wxLogMessage("WR: Updating route %ld for boat file change", i);

      // Update configuration
      c.boatFileName = boatFileName;
      ov->SetConfiguration(c);

      // Modern reset lifecycle
      ov->Stop();
      ov->DeleteThread();
      ov->ResetFinished();

      // Update UI row
      UpdateItem(i, true);
    }
  }

  // Autosave
  SaveXML();

  wxLogMessage("WR: UpdateBoatFilename() - END");
}






//------------------------------------------
//   4.7 Dialogs EVENT HANDLERS ? Configuration / Settings Dialogs
//------------------------------------------
//
// --- Button Command Event Handlers ---
// OnUpdateBoat
//    Updates the "Boat" position to the current boat location
//    This is called when the user requests to update the boat position
// OnDelete          See 6 Route Creation / Deletion
// OnDeletePosition  See 6 Position Management

// --------------------------------------------------------------------------
// OnEditConfiguration  
// --------------------------------------------------------------------------
//    Opens the Configuration dialog for the selected route(s)
//    This is the main edit function for configurations.
// Modern implementation  supports multiple selection.
    
void WeatherRouting::OnEditConfiguration() {
  // 1. Determine which WeatherRoutes are selected
  std::list<RouteMapConfiguration> selectedConfigs;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (!wr || !wr->routemapoverlay) continue;

    // Collect the configuration for the dialog
    selectedConfigs.push_back(wr->routemapoverlay->GetConfiguration());
  }

  // If nothing is selected, nothing to edit
  if (selectedConfigs.empty()) return;

  // 2. Show the configuration dialog populated with selected configurations
  m_bSkipUpdateCurrentItems = true;
  m_ConfigurationDialog.SetConfigurations(selectedConfigs);
  m_bSkipUpdateCurrentItems = false;

  m_ConfigurationDialog.Show();
}

// --------------------------------------------------------------------------
// OnEditConfiguration - Mouse Event Wrapper
// ------------------------------------------------------------------------
// Opens the Configuration dialog for the selected route(s)
// This is the main edit function for configurations.
// Modern implementation of the Edit Configuration handler that supports
// multiple selection.
// Modern 

void WeatherRouting::OnEditPositionClick(wxMouseEvent& event) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxCommandEvent cmd(wxEVT_MENU, ID_POSITION_EDIT);
  OnEditPosition(cmd);

  event.Skip();
}

// --------------------------------------------------------------------------
// OnEditConfiguration - Menu Event Wrapper
// --------------------------------------------------------------------------
// Modern 
void WeatherRouting::OnEditConfiguration(wxCommandEvent& event) {
  OnEditConfiguration();  // call the internal logic
}





//--------------------------------------------------------------------------
// OnUpdateBoat
// -------------------------------------------------------------------------
//    Updates the boat position in the positions list when the boat moves.
// Modern

// MODERN WRAPPER
void WeatherRouting::OnUpdateBoatPosition(wxCommandEvent& event) {
  OnUpdateBoat(event);  // forward to the unified handler
}



// MODERN IMPLEMENTATION
void WeatherRouting::OnUpdateBoat(wxCommandEvent& event) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  // ---------------------------------------------------------------------
  // 1. Get the active WeatherRoute
  // ---------------------------------------------------------------------
  WeatherRoute* wr = GetSelectedRoute();
  if (!wr) {
    wxLogMessage("OnUpdateBoat: no route selected");
    return;
  }

  // ---------------------------------------------------------------------
  // 2. Get the new boat position from the plugin
  // ---------------------------------------------------------------------
  double lat = m_weather_routing_pi.m_boat_lat;
  double lon = m_weather_routing_pi.m_boat_lon;

  // ---------------------------------------------------------------------
  // 3. Find an existing ?Boat? position in this route
  // ---------------------------------------------------------------------
  bool found = false;
  for (auto& pos : wr->Positions) {
    if (pos.Name == _("Boat")) {
      pos.lat = lat;
      pos.lon = lon;
      found = true;
      break;
    }
  }
  // ---------------------------------------------------------------------
  // 4. If no Boat position exists, create one
  // ---------------------------------------------------------------------
  if (!found) {
    WeatherPoint p;
    p.Name = _("Boat");
    p.lat = lat;
    p.lon = lon;
    p.GUID = wxEmptyString;

    wr->Positions.push_back(p);
  }

  // ---------------------------------------------------------------------
  // 5. Mark overlay dirty so the route recomputes
  // ---------------------------------------------------------------------
  if (wr->routemapoverlay) wr->routemapoverlay->MarkDirty();

  // ---------------------------------------------------------------------
  // 6. Refresh UI using the modern pipeline
  // ---------------------------------------------------------------------
  PopulatePositions();   // refresh the positions list
  UpdateStates();        // recompute route state
  UpdateDialogs();       // update stats/report/plot dialogs
  UpdateComputeState();  // update compute/stop buttons

  // ---------------------------------------------------------------------
  // 7. Autosave
  // ---------------------------------------------------------------------
  SaveXML();
}







//------------------------------------------
// -- Dialog Interaction Handlers --
//
// OnSettings
//    Opens the Settings dialog on request from the menu.
// OnFilter 
//    Opens the Filter Routes dialog on request from the menu.
// OnStatistics
//    Opens the Statistics dialog on request from the menu.
// OnReport
//    Opens the Report dialog on request from the menu.
// OnCursorPosition
//    Toggles the Cursor Position dialog on request from the menu.
// OnRoutePosition
//    Toggles the Route Position dialog on request from the menu.
// OnBatch
//    Opens the Batch Configuration dialog on request from the menu.
//  OnUpdateBoat
//    Updates the "Boat" position to the current boat location

//------------------------------------------


void WeatherRouting::OnSettings(wxCommandEvent& event) {
  m_SettingsDialog.Show();
}

void WeatherRouting::OnFilter(wxCommandEvent& event) {
  m_FilterRoutesDialog.Show();
}

void WeatherRouting::OnStatistics(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // Collect overlays for all selected WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  if (overlays.empty()) return;

  m_StatisticsDialog.SetRouteMapOverlays(overlays);
  m_StatisticsDialog.Show();
}

void WeatherRouting::OnReport(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // Collect overlays for all selected WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  if (overlays.empty()) return;

  m_ReportDialog.SetRouteMapOverlays(overlays);
  m_ReportDialog.Show();
}

void WeatherRouting::OnCursorPosition(wxCommandEvent& event) {
  m_CursorPositionDialog.Show(!m_CursorPositionDialog.IsShown());
  UpdateCursorPositionDialog();
}

void WeatherRouting::OnRoutePosition(wxCommandEvent& event) {
  m_RoutePositionDialog.Show(!m_RoutePositionDialog.IsShown());
  UpdateRoutePositionDialog();
}

void WeatherRouting::OnBatch(wxCommandEvent& event) {
  if (m_ConfigurationBatchDialog.IsShown()) return;

  // Reset the batch UI dialog (UI only, not engine state)
  m_ConfigurationBatchDialog.Reset();
  m_ConfigurationBatchDialog.Show();
}

void WeatherRouting::OnPlot(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // Use the *first selected* WeatherRoute for plotting
  // ---------------------------------------------------------------------
  long item = m_panel->m_lWeatherRoutes->GetNextItem(-1, wxLIST_NEXT_ALL,
                                                     wxLIST_STATE_SELECTED);

  if (item < 0) return;

  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
      wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

  if (!wr || !wr->routemapoverlay) return;

  m_PlotDialog.SetRouteMapOverlay(wr->routemapoverlay);
  m_PlotDialog.Show();
}


//-----------------------------------------------------------
//   4.8  UI Commands: Help / Information / Auxiliary Dialogs
//-----------------------------------------------------------
// OnWeatherTable
//    This function opens the Weather Routing Table panel.
//    and adds it to the AUI manager if not already present.
//    upon user request from the menu.
// OnManual
//    This function opens the Weather Routing User Manual
//    in the default web browser upon user request from the menu.
// OnInformation
//   This function opens the Weather Routing Information
//   HTML file in the default web browser upon user request from the menu.
// OnAbout
//   This function opens the About dialog upon user request from the menu.
//-----------------------------------------------------------

void WeatherRouting::OnWeatherTable(wxCommandEvent& event) {
  AddRoutingPanel();
}

void WeatherRouting::OnManual(wxCommandEvent& event) {
  wxLaunchDefaultBrowser(
      "https://opencpn.org/wiki/dokuwiki/"
      "doku.php?id=opencpn:opencpn_user_manual:plugins:weather:weather_"
      "routing");
}

void WeatherRouting::OnInformation(wxCommandEvent& event) {
  wxString infolocation = GetPluginDataDir("weather_routing_pi") + "/data/" +
                          _("WeatherRoutingInformation.html");
  wxLaunchDefaultBrowser("file://" + infolocation);
}

void WeatherRouting::OnAbout(wxCommandEvent& event) {
  AboutDialog dlg(GetParent());
  dlg.ShowModal();
}



/*********************************************************/
/*   5. XML Load / Save                              */
/*********************************************************/





bool WeatherRouting::OpenXML(wxString filename, bool reportfailure) {
  wxLogMessage("WR: OpenXML() entered");

  TiXmlDocument doc;
  wxString error;

  wxProgressDialog* progressdialog = NULL;
  wxDateTime start = wxDateTime::UNow();

  wxString lastboatFileName;
  Boat lastboat;

  if (!doc.LoadFile(filename.mb_str())) FAIL(_("Failed to load file."));

  TiXmlHandle root(doc.RootElement());
  wxString rootName = wxString::FromUTF8(root.Element()->Value());
  wxLogMessage("ROOT ELEMENT = %s", rootName.mb_str());

  // Accept historical root names
  if (rootName != "OpenCPNWeatherRoutingConfiguration" &&
      rootName != "WeatherRoutingConfiguration" &&
      rootName != "OpenCPNWeatherRouting") {
    FAIL(_("Invalid xml file"));
  }

  // Count nodes for progress dialog
  int count = 0;
  for (TiXmlElement* e = root.FirstChild().Element(); e;
       e = e->NextSiblingElement())
    count++;

  int i = 0;
  for (TiXmlElement* e = root.FirstChild().Element(); e;
       e = e->NextSiblingElement(), i++) {
    // Progress dialog logic
    if (progressdialog) {
      if (!progressdialog->Update(i)) {
        delete progressdialog;
        return true;
      }
    } else {
      wxDateTime now = wxDateTime::UNow();
      if ((now - start).GetMilliseconds() > 250 && i < count / 2) {
        progressdialog = new wxProgressDialog(
            _("Load"), _("Weather Routing"), count, this,
            wxPD_CAN_ABORT | wxPD_ELAPSED_TIME | wxPD_REMAINING_TIME);
      }
    }

    // ---------------------------------------------------------------------
    // Ignore legacy <Position> nodes (old global list)
    // ---------------------------------------------------------------------
    if (!strcmp(e->Value(), "Position")) {
      wxLogMessage("Skipping legacy <Position> node");
      continue;
    }

    // ---------------------------------------------------------------------
    // Load <Configuration> blocks
    // ---------------------------------------------------------------------
    if (!strcmp(e->Value(), "Configuration")) {
      RouteMapConfiguration configuration;

      configuration.RouteGUID = wxString::FromUTF8(e->Attribute("GUID"));

      configuration.StartType =
          (RouteMapConfiguration::StartDataType)AttributeInt(
              e, "StartType", RouteMapConfiguration::START_FROM_POSITION);

      configuration.Start = wxString::FromUTF8(e->Attribute("Start"));

      configuration.UseCurrentTime = AttributeBool(e, "UseCurrentTime", false);

      if (configuration.UseCurrentTime) {
        configuration.StartTime = wxDateTime::Now().ToUTC();
      } else {
        wxDateTime date;
        date.ParseISODate(wxString::FromUTF8(e->Attribute("StartDate")));
        wxDateTime time;
        time.ParseISOTime(wxString::FromUTF8(e->Attribute("StartTime")));

        if (date.IsValid()) {
          if (time.IsValid()) {
            date.SetHour(time.GetHour());
            date.SetMinute(time.GetMinute());
            date.SetSecond(time.GetSecond());
          }
          configuration.StartTime = date;
        } else {
          configuration.StartTime = wxDateTime::Now();
        }
      }

      configuration.End = wxString::FromUTF8(e->Attribute("End"));

      configuration.DeltaTime = AttributeDouble(e, "dt", 0);

      configuration.boatFileName = wxString::FromUTF8(e->Attribute("Boat"));

      if (!wxFileName::FileExists(configuration.boatFileName)) {
        configuration.boatFileName = weather_routing_pi::StandardPath() +
                                     "boats" + wxFileName::GetPathSeparator() +
                                     configuration.boatFileName;

        if (!wxFileName::FileExists(configuration.boatFileName))
          configuration.boatFileName = wxEmptyString;
      }

      configuration.Integrator =
          (RouteMapConfiguration::IntegratorType)AttributeInt(e, "Integrator",
                                                              0);

      configuration.MaxDivertedCourse =
          AttributeDouble(e, "MaxDivertedCourse", 90);
      configuration.MaxCourseAngle = AttributeDouble(e, "MaxCourseAngle", 180);
      configuration.MaxSearchAngle = AttributeDouble(e, "MaxSearchAngle", 120);
      configuration.MaxTrueWindKnots =
          AttributeDouble(e, "MaxTrueWindKnots", 50);
      configuration.MaxApparentWindKnots =
          AttributeDouble(e, "MaxApparentWindKnots", 50);

      configuration.MaxSwellMeters = AttributeDouble(e, "MaxSwellMeters", 20.);
      configuration.MaxLatitude = AttributeDouble(e, "MaxLatitude", 90);
      configuration.TackingTime = AttributeDouble(e, "TackingTime", 0);
      configuration.JibingTime = AttributeDouble(e, "JibingTime", 0);
      configuration.SailPlanChangeTime =
          AttributeDouble(e, "SailPlanChangeTime", 0);
      configuration.WindVSCurrent = AttributeDouble(e, "WindVSCurrent", 0);

      configuration.AvoidCycloneTracks =
          AttributeBool(e, "AvoidCycloneTracks", false);
      configuration.CycloneMonths = AttributeInt(e, "CycloneMonths", 2);
      configuration.CycloneDays = AttributeInt(e, "CycloneDays", 0);

      configuration.UseGrib = AttributeBool(e, "UseGrib", true);
      configuration.ClimatologyType =
          (RouteMapConfiguration::ClimatologyDataType)AttributeInt(
              e, "ClimatologyType", RouteMapConfiguration::CUMULATIVE_MAP);
      configuration.AllowDataDeficient =
          AttributeBool(e, "AllowDataDeficient", false);
      configuration.WindStrength = AttributeDouble(e, "WindStrength", 1);

      configuration.UpwindEfficiency =
          AttributeDouble(e, "UpwindEfficiency", 1.);
      configuration.DownwindEfficiency =
          AttributeDouble(e, "DownwindEfficiency", 1.);
      configuration.NightCumulativeEfficiency =
          AttributeDouble(e, "NightCumulativeEfficiency", 1.);

      configuration.DetectLand = AttributeBool(e, "DetectLand", true);
      configuration.SafetyMarginLand =
          AttributeDouble(e, "SafetyMarginLand", 0.);
      configuration.DetectBoundary = AttributeBool(e, "DetectBoundary", false);
      configuration.Currents = AttributeBool(e, "Currents", true);
      configuration.OptimizeTacking =
          AttributeBool(e, "OptimizeTacking", false);

      configuration.InvertedRegions =
          AttributeBool(e, "InvertedRegions", false);
      configuration.Anchoring = AttributeBool(e, "Anchoring", false);

      configuration.FromDegree = AttributeDouble(e, "FromDegree", 0);
      configuration.ToDegree = AttributeDouble(e, "ToDegree", 180);
      configuration.ByDegrees = AttributeDouble(e, "ByDegrees", 5.);

      configuration.UseMotor = AttributeBool(e, "UseMotor", false);
      configuration.MotorSpeedThreshold =
          AttributeDouble(e, "MotorSpeedThreshold", 2.0);
      configuration.MotorSpeed = AttributeDouble(e, "MotorSpeed", 5.0);

      if (configuration.boatFileName == lastboatFileName)
        configuration.boat = lastboat;

      // Create WeatherRoute + Overlay
      AddConfiguration(configuration);

      WeatherRoute* wr = m_WeatherRoutes.back();

      // -----------------------------------------------------------------
      // NEW: Load per-route <Positions>
      // -----------------------------------------------------------------
      for (TiXmlElement* positions = e->FirstChildElement("Positions");
           positions; positions = positions->NextSiblingElement("Positions")) {
        for (TiXmlElement* pe = positions->FirstChildElement("Position"); pe;
             pe = pe->NextSiblingElement("Position")) {
          WeatherPoint p;
          p.Name = wxString::FromUTF8(pe->Attribute("Name"));
          p.GUID = wxString::FromUTF8(pe->Attribute("GUID"));
          p.lat = AttributeDouble(pe, "Latitude", NAN);
          p.lon = AttributeDouble(pe, "Longitude", NAN);

          if (!std::isnan(p.lat) && !std::isnan(p.lon))
            wr->Positions.push_back(p);
        }
      }

      lastboatFileName = configuration.boatFileName;
      wr->routemapoverlay->LoadBoat();
      lastboat = wr->routemapoverlay->GetConfiguration().boat;
    } else {
      wxLogMessage("Skipping unknown XML node: %s", e->Value());
      continue;
    }
  }

  delete progressdialog;
  return true;

failed:
  delete progressdialog;
  if (reportfailure) {
    wxMessageDialog mdlg(this, error, _("Weather Routing"),
                         wxOK | wxICON_ERROR);
    mdlg.ShowModal();
  }
  return false;
}


void WeatherRouting::SaveXML(wxString filename) {
  wxFileName fn(filename);
  m_FileName = fn;

  TiXmlDocument doc;
  TiXmlDeclaration* decl = new TiXmlDeclaration("1.0", "utf-8", "");
  doc.LinkEndChild(decl);

  TiXmlElement* root = new TiXmlElement("OpenCPNWeatherRoutingConfiguration");
  doc.LinkEndChild(root);

  char version[24];
  sprintf(version, "%d.%d", PLUGIN_VERSION_MAJOR, PLUGIN_VERSION_MINOR);
  root->SetAttribute("version", version);
  root->SetAttribute("creator", "Opencpn Weather Routing plugin");

  // ---------------------------------------------------------------------
  // Save each WeatherRoute as a <Configuration> block
  // ---------------------------------------------------------------------
  for (auto it = m_WeatherRoutes.begin(); it != m_WeatherRoutes.end(); it++) {
    WeatherRoute* wr = *it;
    RouteMapOverlay* ov = wr->routemapoverlay;
    RouteMapConfiguration configuration = ov->GetConfiguration();

    TiXmlElement* c = new TiXmlElement("Configuration");

    if (!configuration.RouteGUID.IsEmpty())
      c->SetAttribute("GUID", configuration.RouteGUID.mb_str());

    c->SetAttribute("StartType", configuration.StartType);
    c->SetAttribute("Start", configuration.Start.mb_str());
    c->SetAttribute("UseCurrentTime", configuration.UseCurrentTime);

    if (!configuration.UseCurrentTime) {
      c->SetAttribute("StartDate",
                      configuration.StartTime.FormatISODate().mb_str());
      c->SetAttribute("StartTime",
                      configuration.StartTime.FormatISOTime().mb_str());
    }

    c->SetAttribute("End", configuration.End.mb_str());
    c->SetAttribute("dt", configuration.DeltaTime);

    c->SetAttribute("Boat", configuration.boatFileName.ToUTF8());
    c->SetAttribute("Integrator", configuration.Integrator);

    c->SetAttribute("MaxDivertedCourse", configuration.MaxDivertedCourse);
    c->SetAttribute("MaxCourseAngle", configuration.MaxCourseAngle);
    c->SetAttribute("MaxSearchAngle", configuration.MaxSearchAngle);
    c->SetAttribute("MaxTrueWindKnots", configuration.MaxTrueWindKnots);
    c->SetAttribute("MaxApparentWindKnots", configuration.MaxApparentWindKnots);

    c->SetDoubleAttribute("MaxSwellMeters", configuration.MaxSwellMeters);
    c->SetAttribute("MaxLatitude", configuration.MaxLatitude);
    c->SetAttribute("TackingTime", configuration.TackingTime);
    c->SetAttribute("JibingTime", configuration.JibingTime);
    c->SetAttribute("SailPlanChangeTime", configuration.SailPlanChangeTime);
    c->SetAttribute("WindVSCurrent", configuration.WindVSCurrent);

    c->SetAttribute("AvoidCycloneTracks", configuration.AvoidCycloneTracks);
    c->SetAttribute("CycloneMonths", configuration.CycloneMonths);
    c->SetAttribute("CycloneDays", configuration.CycloneDays);

    c->SetAttribute("UseGrib", configuration.UseGrib);
    c->SetAttribute("ClimatologyType", configuration.ClimatologyType);
    c->SetAttribute("AllowDataDeficient", configuration.AllowDataDeficient);
    c->SetDoubleAttribute("WindStrength", configuration.WindStrength);

    c->SetDoubleAttribute("UpwindEfficiency", configuration.UpwindEfficiency);
    c->SetDoubleAttribute("DownwindEfficiency",
                          configuration.DownwindEfficiency);
    c->SetDoubleAttribute("NightCumulativeEfficiency",
                          configuration.NightCumulativeEfficiency);

    c->SetAttribute("DetectLand", configuration.DetectLand);
    c->SetDoubleAttribute("SafetyMarginLand", configuration.SafetyMarginLand);
    c->SetAttribute("DetectBoundary", configuration.DetectBoundary);
    c->SetAttribute("Currents", configuration.Currents);
    c->SetAttribute("OptimizeTacking", configuration.OptimizeTacking);

    c->SetAttribute("InvertedRegions", configuration.InvertedRegions);
    c->SetAttribute("Anchoring", configuration.Anchoring);

    c->SetDoubleAttribute("FromDegree", configuration.FromDegree);
    c->SetDoubleAttribute("ToDegree", configuration.ToDegree);
    c->SetDoubleAttribute("ByDegrees", configuration.ByDegrees);

    c->SetAttribute("UseMotor", configuration.UseMotor);
    c->SetDoubleAttribute("MotorSpeedThreshold",
                          configuration.MotorSpeedThreshold);
    c->SetDoubleAttribute("MotorSpeed", configuration.MotorSpeed);

    // -----------------------------------------------------------------
    // NEW: Save per-route positions
    // -----------------------------------------------------------------
    TiXmlElement* positions = new TiXmlElement("Positions");
    c->LinkEndChild(positions);

    for (const WeatherPoint& p : wr->Positions) {
      TiXmlElement* pos = new TiXmlElement("Position");

      pos->SetAttribute("Name", p.Name.mb_str());
      pos->SetAttribute("Latitude", wxString::Format("%.6f", p.lat).mb_str());
      pos->SetAttribute("Longitude", wxString::Format("%.6f", p.lon).mb_str());

      if (!p.GUID.IsEmpty()) pos->SetAttribute("GUID", p.GUID.mb_str());

      positions->LinkEndChild(pos);
    }

    root->LinkEndChild(c);
  }

  if (!doc.SaveFile(filename.mb_str())) {
    wxMessageDialog mdlg(this, _("Failed to save xml file: ") + filename,
                         _("Weather Routing"), wxOK | wxICON_ERROR);
    mdlg.ShowModal();
  }
}




TiXmlElement* WeatherRouting::SaveSimplifiedRouteAsGPX(
    const RouteMapOverlay& routemapoverlay,
    const std::list<Position*>& simplifiedRoute) {
  if (simplifiedRoute.empty()) return nullptr;

  // Create <trk>
  TiXmlElement* trk = new TiXmlElement("trk");

  // Track name
  const RouteMapConfiguration& config = routemapoverlay.GetConfiguration();
  wxString trackName =
      wxString::Format("Simplified %s to %s", config.Start, config.End);

  TiXmlElement* name = new TiXmlElement("name");
  name->LinkEndChild(new TiXmlText(trackName.ToUTF8()));
  trk->LinkEndChild(name);

  // Create <trkseg>
  TiXmlElement* trkseg = new TiXmlElement("trkseg");
  trk->LinkEndChild(trkseg);

  // Write each simplified point
  for (Position* pos : simplifiedRoute) {
    TiXmlElement* trkpt = new TiXmlElement("trkpt");

    trkpt->SetDoubleAttribute("lat", pos->lat);
    trkpt->SetDoubleAttribute("lon", pos->lon);

    // Time (ISO8601)
    if (pos->time.IsValid()) {
      TiXmlElement* time = new TiXmlElement("time");
      time->LinkEndChild(
          new TiXmlText(pos->time.FormatISOCombined('T').ToUTF8()));
      trkpt->LinkEndChild(time);
    }

    // Extensions block for extra data
    TiXmlElement* ext = nullptr;

    auto addExtension = [&](const char* tag, double value) {
      if (std::isnan(value)) return;
      if (!ext) {
        ext = new TiXmlElement("extensions");
        trkpt->LinkEndChild(ext);
      }
      TiXmlElement* e = new TiXmlElement(tag);
      e->LinkEndChild(new TiXmlText(wxString::Format("%.3f", value).ToUTF8()));
      ext->LinkEndChild(e);
    };

    // Boat speed (SOG)
    addExtension("opencpn:sog", pos->speed);

    // Wind
    addExtension("opencpn:wind_speed", pos->wind_speed);
    addExtension("opencpn:wind_dir", pos->wind_direction);

    // Current
    addExtension("opencpn:current_speed", pos->current_speed);
    addExtension("opencpn:current_dir", pos->current_direction);

    // Swell
    addExtension("opencpn:swell_height", pos->swell_height);

    trkseg->LinkEndChild(trkpt);
  }

  return trk;
}


/*********************************************************/
/*   4. POSITION / CONFIGURATION EDITING                 */
/*********************************************************/
// NOTE Why 3 AddPosition overloads 
//    UI update code is similar in all three.but the semantics are different
//    three different workflows, not duplicates.
//--------------------------------
// Other position management functions are in RouteMap.cpp
//--------------------------------
// OnEditPosition
//   User selects a position in the list and clicks Edit
//   Prompts for new name, Checks for name collisions
//   Updates the list control, Updates configuration dialogs
// OnDeletePosition
//   User selects a position in the list and clicks Delete
//   Prompts for confirmation, Removes from the list control
//   Updates configuration dialogs, Removes from RouteMap::Positions
// OnDeleteAllPositions
//   User clicks Delete All Positions
//   Prompts for confirmation, Clears the list control
//   Updates configuration dialogs, Clears RouteMap::Positions
//--------------------------------


// AddPosition 1 -The interactive UI entry point.User Clicks add position   
// Called when the user clicks Add Position in theU
// UI and only provides coordinates
// UI entry point: user clicks ?New Position??.

void WeatherRouting::AddPosition(double lat, double lon) {
  wxTextEntryDialog pd(this, _("Enter Name"), _("New Position"));
  if (pd.ShowModal() != wxID_OK) return;

  WeatherRoute* wr = GetSelectedRoute();
  if (!wr) return;

  AddPosition(wr, lat, lon, pd.GetValue(), wxEmptyString, false);
}


// AddPosition 2 - Handles user-created positions that have no GUID.
// Checks for name collisions
// Optionally prompts the user (?Replace existing??)
// Updates the list control   Updates configuration dialogs
// Schedules autosave,  the core logic for user-defined positions.
// User?created positions (no GUID)

void WeatherRouting::AddPosition(WeatherRoute* wr, double lat, double lon,
                                 const wxString& name, const wxString& GUID,
                                 bool suppress_prompt) {
  if (!wr) return;

  // ---------------------------------------------------------------------
  // 1. GUID?based positions go to the GUID handler
  // ---------------------------------------------------------------------
  if (!GUID.IsEmpty()) {
    AddPosition_GUID(wr, lat, lon, name, GUID);
    return;
  }

  // ---------------------------------------------------------------------
  // 2. Check for name collision among user?defined positions
  // ---------------------------------------------------------------------
  for (size_t i = 0; i < wr->Positions.size(); i++) {
    WeatherPoint& p = wr->Positions[i];

    if (p.GUID.IsEmpty() && p.Name == name) {
      int replace = wxID_YES;

      if (!suppress_prompt) {
        wxMessageDialog dlg(this, _("This name already exists. Replace it?"),
                            _("Weather Routing"),
                            wxYES | wxNO | wxICON_WARNING);
        replace = dlg.ShowModal();
      }

      if (replace == wxID_YES) {
        p.lat = lat;
        p.lon = lon;
        UpdatePositionRow(i);
        MarkRouteDirty(wr);
      }
      return;
    }
  }

  // ---------------------------------------------------------------------
  // 3. Insert new user?defined position
  // ---------------------------------------------------------------------
  WeatherPoint p;
  p.lat = lat;
  p.lon = lon;
  p.Name = name;
  p.GUID = wxEmptyString;

  wr->Positions.push_back(p);

  AddPositionRow(wr->Positions.size() - 1);
  MarkRouteDirty(wr);
}



// AddPosition 3 - Handles positions loaded from XML or generated by routing.
// If GUID is empty delegates to the user defined version
// If GUID exists ? updates or inserts a GUID?based position
// Does not prompt the user Does not treat name collisions the same way
// Updates the UI and configuration dialogs
// GUID?based positions are route-derived, not user-created. They behave differently
// GUID?based positions (loaded from XML or plugin routes)

void WeatherRouting::AddPosition_GUID(WeatherRoute* wr, double lat, double lon,
                                      const wxString& name,
                                      const wxString& GUID) {
  if (!wr) return;

  // ---------------------------------------------------------------------
  // 1. Update existing GUID?based position
  // ---------------------------------------------------------------------
  for (size_t i = 0; i < wr->Positions.size(); i++) {
    WeatherPoint& p = wr->Positions[i];

    if (!p.GUID.IsEmpty() && p.GUID == GUID) {
      p.lat = lat;
      p.lon = lon;
      p.Name = name;

      UpdatePositionRow(i);
      MarkRouteDirty(wr);
      return;
    }
  }

  // ---------------------------------------------------------------------
  // 2. Insert new GUID?based position
  // ---------------------------------------------------------------------
  WeatherPoint p;
  p.lat = lat;
  p.lon = lon;
  p.Name = name;
  p.GUID = GUID;

  wr->Positions.push_back(p);

  AddPositionRow(wr->Positions.size() - 1);
  MarkRouteDirty(wr);
}


void WeatherRouting::OnNewPosition(wxCommandEvent& event) {
  NewPositionDialog dlg(this);
  if (dlg.ShowModal() == wxID_OK) {
    AddPosition(fromDMM_Plugin(dlg.m_tLatitude->GetValue()),
                fromDMM_Plugin(dlg.m_tLongitude->GetValue()),
                dlg.m_tName->GetValue(), false);
  }
}

// Supporting UI Helper: opens the New Position dialog, collects user input, and
// calls the main AddPosition logic.

void WeatherRouting::AddPositionRow(size_t index) {
  if (!m_PositionPanel || !m_PositionPanel->m_lPositions) return;

  WeatherRoute* wr = GetSelectedRoute();
  if (!wr) return;

  const WeatherPoint& p = wr->Positions[index];
  wxListCtrl* list = m_PositionPanel->m_lPositions;

  wxListItem item;
  long row = list->InsertItem(list->GetItemCount(), item);

  list->SetItem(row, 0, p.Name);
  list->SetItem(row, 1, toSDMM_PlugIn(NEflag::LAT, p.lat, Precision::HI));
  list->SetItem(row, 2, toSDMM_PlugIn(NEflag::LON, p.lon, Precision::HI));

  list->SetItemPtrData(row, (wxUIntPtr)index);
}

void WeatherRouting::UpdatePositionRow(size_t index) {
  if (!m_PositionPanel || !m_PositionPanel->m_lPositions) return;

  WeatherRoute* wr = GetSelectedRoute();
  if (!wr) return;

  wxListCtrl* list = m_PositionPanel->m_lPositions;

  long row = list->FindItem(-1, (wxUIntPtr)index);
  if (row < 0) return;

  const WeatherPoint& p = wr->Positions[index];

  list->SetItem(row, 0, p.Name);
  list->SetItem(row, 1, toSDMM_PlugIn(NEflag::LAT, p.lat, Precision::HI));
  list->SetItem(row, 2, toSDMM_PlugIn(NEflag::LON, p.lon, Precision::HI));
}

void WeatherRouting::MarkRouteDirty(WeatherRoute* wr) {
  if (!wr) return;

  wr->routemapoverlay->MarkDirty();
  SaveXML(true);  // or schedule autosave
}





// ============================================================================
// WeatherRouting::OnEditPosition
// Modern position editor: edits a single position in the selected WeatherRoute.
// ============================================================================
// Modern

void WeatherRouting::OnEditPosition(wxCommandEvent& event) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  // ---------------------------------------------------------------------
  // 1. Determine which route is selected
  // ---------------------------------------------------------------------
  auto overlays = GetSelectedOverlays();
  if (overlays.size() != 1) {
    wxLogMessage("OnEditPosition: requires exactly one selected route");
    return;
  }

  RouteMapOverlay* ov = overlays[0];
  WeatherRoute* wr = ov->m_weatherRoute;
  if (!wr) return;

// ---------------------------------------------------------------------
  // 2. Determine which position is selected in the Positions list
  // ---------------------------------------------------------------------
  if (!m_PositionPanel || !m_PositionPanel->m_lPositions) {
    wxLogMessage("OnEditPosition: no positions list available");
    return;
  }

  wxListCtrl* list = m_PositionPanel->m_lPositions;

  long item = list->GetNextItem(-1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
  if (item < 0) {
    wxLogMessage("OnEditPosition: no position selected");
    return;
  }


  // The list control stores the index of the position in wr->Positions
  long posIndex = list->GetItemData(item);
  if (posIndex < 0 || posIndex >= (long)wr->Positions.size()) {
    wxLogMessage("OnEditPosition: invalid position index");
    return;
  }

  WeatherPoint& p = wr->Positions[posIndex];

  // ---------------------------------------------------------------------
  // 3. Fill dialog with position data
  // ---------------------------------------------------------------------
  NewPositionDialog dlg(this);
  dlg.m_tName->SetValue(p.Name);
  dlg.m_tLatitude->SetValue(toSDMM_PlugIn(1, p.lat));
  dlg.m_tLongitude->SetValue(toSDMM_PlugIn(2, p.lon));

  // ---------------------------------------------------------------------
  // 4. Apply edits
  // ---------------------------------------------------------------------
  if (dlg.ShowModal() == wxID_OK) {
    p.Name = dlg.m_tName->GetValue();
    p.lat = fromDMM_Plugin(dlg.m_tLatitude->GetValue());
    p.lon = fromDMM_Plugin(dlg.m_tLongitude->GetValue());

    // Mark overlay dirty so compute results are invalidated
    ov->MarkDirty();

    // Refresh UI
    PopulatePositions();
    UpdateStates();
    SaveXML(true);

    wxLogMessage("OnEditPosition: updated position index=%ld", posIndex);
  }
}




void WeatherRouting::OnDeletePosition(wxCommandEvent& event) {
  // Ensure the new UI panel exists
  if (!m_PositionPanel || !m_PositionPanel->m_lPositions) return;

  wxListCtrl* list = m_PositionPanel->m_lPositions;

  // Find the selected row
  long index = list->GetNextItem(-1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
  if (index < 0) return;

  // Retrieve the ID stored in the row
  long ID = list->GetItemData(index);
  assert(ID >= 0);

  // Remove from RouteMap::Positions
  for (auto it = RouteMap::Positions.begin(); it != RouteMap::Positions.end();
       ++it) {
    if (it->ID == ID) {
      wxString name = it->Name;

      // Remove from configuration dialogs
      m_ConfigurationDialog.RemoveSource(name);
      m_ConfigurationBatchDialog.RemoveSource(name);

      RouteMap::Positions.erase(it);
      break;
    }
  }

  // Remove from the UI list
  list->DeleteItem(index);

  // Update dependent UI
  UpdateConfigurations();

  // Schedule autosave
  m_tAutoSaveXML.Start(5000, true);
}


void WeatherRouting::OnDeleteAllPositions(wxCommandEvent& event) {
  // Clear model
  RouteMap::Positions.clear();

  // Clear configuration dialogs
  m_ConfigurationDialog.ClearSources();
  m_ConfigurationBatchDialog.ClearSources();

  // Clear UI list
  if (m_PositionPanel && m_PositionPanel->m_lPositions)
    m_PositionPanel->m_lPositions->DeleteAllItems();

  // Schedule autosave
  m_tAutoSaveXML.Start(5000, true);
}



void WeatherRouting::OnDelete(wxCommandEvent& event) {
  // 1. Determine which overlays/routes are selected
  auto overlays = GetSelectedOverlays();
  if (overlays.empty()) return;

  // 2. Stop all computations before deleting anything
  StopAll();

  // 3. Delete the selected overlays/routes safely
  DeleteRouteMaps(overlays);

  // 4. Update UI state
  UpdateStates();
  UpdateDialogs();

  // 5. Refresh the chart
  RequestRefresh(GetParent());

  // 6. Schedule autosave
  m_tAutoSaveXML.Start(5000, true);
}




/*********************************************************/
/*   7. Configuration Management                          */
/*********************************************************/
// DefaultConfiguration
//   Creates a default configuration based on first two positions
//   and standard settings.
//   Used when creating a new route from scratch.
//   The default boat is Boat.xml from the standard boats directory.
//   If less than two positions exist, lat/lon are set to 0.
//   The start time is set to now, with a delta time of 1 hour.
//   Other settings are hard-coded defaults.
//   Returns the created RouteMapConfiguration object.
// AddConfiguration
//   Adds a new configuration to the list of weather routes.
//   If the configuration has a RouteGUID, it retrieves the route
//   and sets the start and end positions accordingly.
//   Creates a new WeatherRoute and RouteMapOverlay for the configuration.
//   Updates the UI list and enables relevant menu items.
//   Schedules an auto-save of the XML file.
//   Returns true if the configuration was added successfully.
// UpdateConfigurations
//   Updates all existing weather routes with their current configurations.
//   This is typically called after positions have been modified.
//   It retrieves the configuration from each RouteMapOverlay,
//   sets it back to update start/end positions, and then updates the route.
//   No return value.
// UpdateBoatFileName
//   Updates the boat file name for all existing weather routes.
//   This is called when the standard boats directory changes.
//   It sets the boat file name in each RouteMapOverlay's configuration
//   to the new standard path. No return value.
// SetEnableConfigurationMenu
//   Enables or disables the configuration menu items.
//  This is used to prevent user interaction during long operations.
//   It sets the enabled state of the configuration menu and batch menu.
//   No return value.
//----------------------------------------------------------



void WeatherRouting::OnDefaultConfiguration(wxCommandEvent& event) {
  // Empty handler is fine ? menu item reserved for future use
}


RouteMapConfiguration WeatherRouting::DefaultConfiguration() {
  RouteMapConfiguration configuration;

  if (RouteMap::Positions.size() >= 1) {
    RouteMapPosition& p = *RouteMap::Positions.begin();
    configuration.Start = p.Name;
    configuration.StartLat = p.lat, configuration.StartLon = p.lon;
  } else
    configuration.StartLat = 0, configuration.StartLon = 0;

  configuration.StartTime = wxDateTime::Now();
  configuration.DeltaTime = 3600;

  if (RouteMap::Positions.size() >= 2) {
    RouteMapPosition& p = *(++RouteMap::Positions.begin());
    configuration.End = p.Name;
    configuration.EndLat = p.lat, configuration.EndLon = p.lon;
  } else
    configuration.EndLat = 0, configuration.EndLon = 0;

  configuration.boatFileName = weather_routing_pi::StandardPath() + "boats" +
                               wxFileName::GetPathSeparator() + "Boat.xml";

  configuration.Integrator = RouteMapConfiguration::NEWTON;

  configuration.MaxDivertedCourse = 90;
  configuration.MaxCourseAngle = 180;
  configuration.MaxSearchAngle = 120;
  configuration.MaxTrueWindKnots = 50;      // Safety margin for wind speed
  configuration.MaxApparentWindKnots = 50;  // Safety margin for wind speed

  configuration.MaxSwellMeters = 20.;
  configuration.MaxLatitude = 90;
  configuration.TackingTime = 0;
  configuration.JibingTime = 0;
  configuration.SailPlanChangeTime = 0;
  configuration.WindVSCurrent = 0;

  configuration.AvoidCycloneTracks = false;
  configuration.CycloneMonths = 1;
  configuration.CycloneDays = 0;

  configuration.UseGrib = true;
  configuration.ClimatologyType = RouteMapConfiguration::MOST_LIKELY;
  configuration.AllowDataDeficient = false;
  configuration.WindStrength = 1;
  configuration.DetectLand = true;
  configuration.SafetyMarginLand = 0.;
  configuration.DetectBoundary = false;
  configuration.Currents = false;
  configuration.OptimizeTacking = false;
  configuration.InvertedRegions = false;
  configuration.Anchoring = false;

  configuration.FromDegree = 0;
  configuration.ToDegree = 180;
  configuration.ByDegrees = 5;

  return configuration;
}



void WeatherRouting::AddRoutingPanel() {
  // ---------------------------------------------------------------------
  // 1. Determine the first selected WeatherRoute
  //    The list control is the authoritative source of selection.
  // ---------------------------------------------------------------------
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* lc = m_panel->m_lWeatherRoutes;

  long item = lc->GetNextItem(-1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
  if (item < 0) return;  // No selection ? nothing to show

  WeatherRoute* wr =
      reinterpret_cast<WeatherRoute*>(wxUIntToPtr(lc->GetItemData(item)));

  if (!wr || !wr->routemapoverlay) return;

  RouteMapOverlay* ov = wr->routemapoverlay;

  // ---------------------------------------------------------------------
  // 2. Create the RoutingTablePanel if needed
  // ---------------------------------------------------------------------
  if (!m_RoutingTablePanel) {
    wxWindow* parent = m_weather_routing_pi.GetParentWindow();

    m_RoutingTablePanel = new RoutingTablePanel(parent, *this, ov);

    wxAuiManager* mgr = ::GetFrameAuiManager();
    wxAuiPaneInfo pane = wxAuiPaneInfo()    
                             .Name("Weather Routing Table")
                             .Caption("Weather Routing Table")
                             .CaptionVisible(true)
                             .Float()
                             .FloatingPosition(100, 100)
                             .FloatingSize(700, 400)
                             .Dockable(true)
                             .Movable(true)
                             .CloseButton(true);

    mgr->AddPane(m_RoutingTablePanel, pane);

#if OCPN_API_VERSION_MAJOR > 1 || \
    (OCPN_API_VERSION_MAJOR == 1 && OCPN_API_VERSION_MINOR >= 20)
    PI_ColorScheme cs = GetAppColorScheme();
    static_cast<RoutingTablePanel*>(m_RoutingTablePanel)->SetColorScheme(cs);
#endif

    mgr->Update();
  }

  // ---------------------------------------------------------------------
  // 3. Update existing panel with the selected route
  // ---------------------------------------------------------------------
  else {
    auto* panel = static_cast<RoutingTablePanel*>(m_RoutingTablePanel);
    panel->m_RouteMap = ov;
    panel->PopulateTable();

    wxAuiManager* mgr = ::GetFrameAuiManager();
    wxAuiPaneInfo& pane = mgr->GetPane(m_RoutingTablePanel);

    if (!pane.IsShown()) {
      pane.Show(true);
      mgr->Update();
    }
  }
}


/*********************************************************/
/*   8. Route List Management (Model + wxListCtrl ) */
/*********************************************************/
// AddRouteToList
//   Add a new WeatherRoute to the internal model and the wxListCtrl
//   then populate its row via UpdateItem()
// RemoveRouteFromList
//   Remove a WeatherRoute from the internal model and the wxListCtrl
//   using the unified Reset(overlay) lifecycle for safe teardown
//   then refresh remaining rows with UpdateItem()
//-----------------------------------------------------  
// RemoveSelectedRoutes
//   Remove all selected WeatherRoutes from the internal model and the
//   wxListCtrl then refresh remaining rows with UpdateItem()
// RemoveAllRoutes
//   Remove all WeatherRoutes from the internal model and the wxListCtrl
//   using the unified Reset(overlay) lifecycle for safe teardown
//   then refresh UI state with UpdateDialogs()
//-----------------------------------------------------
// SelectRouteInList
//   Select a WeatherRoute in the wxListCtrl given its pointer
//   clearing any previous selection
//   used after adding a new route to highlight it
//   or when the user requests selection via context menu
//   or when a route computation finishes
//   or when the user double-clicks a route to edit it
//   or when the user requests selection via external code
//  then refresh UI state with UpdateDialogs()

//------------------------------------------
//   8.1 Add / Remove
//------------------------------------------

// Modern unified route addition logic
void WeatherRouting::AddRouteToList(WeatherRoute* wr) {
  if (!wr) return;

  // Add to internal model
  m_WeatherRoutes.push_back(wr);

  // Determine the new row index
  long index = m_panel->m_lWeatherRoutes->GetItemCount();

  // Insert a new row with the route pointer as item data
  wxListItem item;
  item.SetId(index);
  item.SetData(reinterpret_cast<wxUIntPtr>(wr));
  item.SetText("");  // first column text (STATE will be filled by UpdateItem)
  m_panel->m_lWeatherRoutes->InsertItem(item);

  // Initialize all columns to empty strings
  for (int c = 0; c < NUM_COLS; c++) {
    if (columns[c] >= 0)
      m_panel->m_lWeatherRoutes->SetItem(index, columns[c], "");
  }

  // Now populate the row using the unified update pipeline
  UpdateItem(index, true);
}



// Modern unified route removal logic using the canonical Reset(overlay)
// lifecycle

void WeatherRouting::RemoveRouteFromList(long index) {
  if (index < 0 || index >= (long)m_WeatherRoutes.size()) return;

  // 1. Locate the WeatherRoute in the model
  auto it = m_WeatherRoutes.begin();
  std::advance(it, index);
  WeatherRoute* wr = *it;

  // 2. Delete the overlay using the unified lifecycle
  if (wr && wr->routemapoverlay) {
    DeleteRouteMap(wr->routemapoverlay);
  }

  // 3. Delete the WeatherRoute object
  delete wr;
  m_WeatherRoutes.erase(it);

  // 4. Remove the row from the UI list control
  m_panel->m_lWeatherRoutes->DeleteItem(index);

  // 5. Reindex remaining rows
  long count = m_panel->m_lWeatherRoutes->GetItemCount();
  auto it2 = m_WeatherRoutes.begin();
  for (long i = 0; i < count; i++, ++it2) {
    m_panel->m_lWeatherRoutes->SetItemData(i,
                                           reinterpret_cast<wxUIntPtr>(*it2));
  }

  // 6. Refresh UI rows
  for (long i = 0; i < count; i++) UpdateItem(i, true);

  // 7. Global UI refresh pipeline
  UpdateDialogs();
  UpdateComputeState();
  if (GetParent()) GetParent()->Refresh();

  AssertSchedulerInvariants();
}



// RemoveSelectedRoutes
//   Remove all selected WeatherRoutes from the internal model and the
// MODERN
void WeatherRouting::RemoveSelectedRoutes() {
  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  if (!lc) return;

  // Collect selected indices (descending order avoids index shifting)
  std::vector<long> selected;
  long item = -1;

  for (;;) {
    item = lc->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item == -1) break;
    selected.push_back(item);
  }

  if (selected.empty()) return;

  std::sort(selected.begin(), selected.end(), std::greater<long>());

  // Remove each selected route using the unified lifecycle
  for (long idx : selected) RemoveRouteFromList(idx);

  // Refresh remaining rows
  long count = lc->GetItemCount();
  for (long i = 0; i < count; i++) UpdateItem(i, true);

  // Update dialogs and UI state
  UpdateDialogs();
  GetParent()->Refresh();
}


// RemoveAllRoutes
// MODERN
void WeatherRouting::RemoveAllRoutes() {
  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  if (!lc) return;

  if (m_WeatherRoutes.empty()) return;

  // Freeze UI to avoid flicker during mass deletion
  lc->Freeze();

  // 1. Reset each overlay using the canonical 3?phase lifecycle
  for (WeatherRoute* wr : m_WeatherRoutes) {
    if (wr && wr->routemapoverlay) {
      Reset(wr->routemapoverlay);  // unified, safe teardown
    }
  }

  // 2. Delete all WeatherRoute objects
  for (WeatherRoute* wr : m_WeatherRoutes) {
    delete wr;
  }

  // 3. Clear the model
  m_WeatherRoutes.clear();

  // 4. Clear the UI list control
  lc->DeleteAllItems();

  // 5. Thaw UI
  lc->Thaw();

  // 6. Refresh dialogs and UI state
  UpdateDialogs();
  GetParent()->Refresh();
}



//------------------------------------------
//   8.2 Selection
//------------------------------------------

// SelectRouteInList
// MODERN 

void
    WeatherRouting::SelectRouteInList(WeatherRoute* wr) {
  if (!wr) return;

  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  if (!lc) return;

  // Find the index of this WeatherRoute in the model
  long index = -1;

  long i = 0;
  for (auto it = m_WeatherRoutes.begin(); it != m_WeatherRoutes.end();
       ++it, ++i) {
    if (*it == wr) {
      index = i;
      break;
    }
  }

  if (index == -1) return;  // Not found

  // Clear any previous selection (wxListCtrl has no UnselectAll)
  long item = -1;
  while (true) {
    item = lc->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item == -1) break;
    lc->SetItemState(item, 0, wxLIST_STATE_SELECTED);
  }

  // Select the row
  lc->SetItemState(index, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);

  // Ensure it is visible
  lc->EnsureVisible(index);
}


//------------------------------------------
//   8.3 Column / WeatherRouting  Table Management
//------------------------------------------

void WeatherRouting::RebuildListControlColumns() {
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* lc = m_panel->m_lWeatherRoutes;

  // Freeze UI to avoid flicker
  lc->Freeze();

  // 1. Remove all existing columns
  lc->DeleteAllColumns();

  // 2. Rebuild the columns[] mapping based on user settings
  int colIndex = 0;
  for (int i = 0; i < NUM_COLS; i++) {
    if (m_SettingsDialog.m_cblFields->IsChecked(i)) {
      columns[i] = colIndex;

      wxString name = column_names[i];

      // Add "(local)" or "(UTC)" to time columns
      if (i == STARTTIME || i == ENDTIME) {
        name += " (";
        if (m_SettingsDialog.m_cbUseLocalTime->GetValue())
          name += _("local");
        else
          name += _("UTC");
        name += ")";
      }

      lc->InsertColumn(colIndex, name);
      lc->SetColumnWidth(colIndex, wxLIST_AUTOSIZE);
      colIndex++;
    } else {
      columns[i] = -1;  // column hidden
    }
  }

  // 3. Rebuild all rows (item data + values)
  long count = lc->GetItemCount();
  lc->DeleteAllItems();

  long index = 0;
  for (auto wr : m_WeatherRoutes) {
    wxListItem item;
    item.SetId(index);
    item.SetData(reinterpret_cast<wxUIntPtr>(wr));
    item.SetText("");  // STATE column will be filled by UpdateItem
    lc->InsertItem(item);

    UpdateItem(index, true);
    index++;
  }

  // 4. Thaw UI
  lc->Thaw();
}



/*************************************************************************/
/*     9.WeatherRoute::Update(Model Update Logic)  full 1?30?2026 version */
/**************************************************************************/
// Update
//   Update the WeatherRoute fields from the RouteMapOverlay
//   Called when the RouteMapOverlay has new data
//   Typically after a computation step or completion
//   Update can be full or state only
//   If stateonly == true, only the State field is updated
//   Used when only the State may have changed (eg. Started, Stopped, Error
//   Finished, etc.)
//   If stateonly == false, all fields are updated
//   Used when the route has new data (eg. after a computation step or
//   completion)
// UpdateItem
//   Displays the WeatherRoute fields in the wxListCtrl
//   Called after WeatherRoute::Update to refresh the UI
// RebuildList
//   Rebuilds the wxListCtrl columns based on user settings
//   Called when user changes column visibility settings
// ------------------------------------------------------------
// THIS IS THE MODERNIZED, FULLY REFACTORED WeatherRoute::Update METHOD

void WeatherRoute::Update(WeatherRouting* wr, bool stateonly) {
  wxLogMessage("WR: WeatherRoute::Update() entered");

  // ------------------------------------------------------------
  //    1. Update all computer fields (unless stateonly == true)
  //  -----------------------------------------------------------
  if (!stateonly) {
    // Clear computed fields ONLY when overlay is dirty AND this is a full
    // update
    if (!stateonly && routemapoverlay->IsDirty()) {
      ClearComputedFields();
      routemapoverlay->ClearDirty();
    }

    RouteMapConfiguration configuration = routemapoverlay->GetConfiguration();

    BoatFilename = configuration.boatFileName;

    // Add handling for Start field based on StartType
    if (configuration.StartType == RouteMapConfiguration::START_FROM_BOAT) {
      Start = _("Boat");
    } else {
      Start = configuration.Start;
    }

    StartType =
        configuration.StartType == RouteMapConfiguration::START_FROM_POSITION
            ? _("From Position")
            : _("From Boat");

    UseCurrentTime = configuration.UseCurrentTime ? _("true") : _("false");

    wxDateTime starttime = configuration.StartTime;
    if (wr->GetSettingsDialog().m_cbUseLocalTime->GetValue())
      starttime = starttime.FromUTC();
    StartTime = starttime.Format("%x %H:%M");

    End = configuration.End;

    wxDateTime endtime = routemapoverlay->EndTime();
    if (endtime.IsValid()) {
      if (wr->GetSettingsDialog().m_cbUseLocalTime->GetValue())
        endtime = endtime.FromUTC();
      EndTime = endtime.Format("%x %H:%M");
    } else {
      EndTime = "N/A";
    }

    // REFACTORING
    // Dedicate a function to display the difference
    // between the two TimeDate. Useful in other parts of the code.
    Time = calculateTimeDelta(starttime, endtime);

    Distance = wxString::Format(
        "%.0f/%.0f", routemapoverlay->RouteInfo(RouteMapOverlay::DISTANCE),
        DistGreatCircle_Plugin(configuration.StartLat, configuration.StartLon,
                               configuration.EndLat, configuration.EndLon));

    AvgSpeed = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::AVGSPEED));

    MaxSpeed = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::MAXSPEED));

    AvgSpeedGround = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::AVGSPEEDGROUND));

    MaxSpeedGround = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::MAXSPEEDGROUND));

    AvgWind = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::AVGWIND));

    MaxWind = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::MAXWIND));

    MaxWindGust = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::MAXWINDGUST));

    AvgCurrent = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::AVGCURRENT));

    MaxCurrent = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::MAXCURRENT));

    AvgSwell = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::AVGSWELL));

    MaxSwell = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::MAXSWELL));

    UpwindPercentage = wxString::Format(
        "%.1f%%",
        routemapoverlay->RouteInfo(RouteMapOverlay::PERCENTAGE_UPWIND));

    double ps = routemapoverlay->RouteInfo(RouteMapOverlay::PORT_STARBOARD);
    PortStarboard = wxString::Format("%.0f/%.0f", ps, 100 - ps);

    Tacks = wxString::Format(
        "%.0f", routemapoverlay->RouteInfo(RouteMapOverlay::TACKS));
    Jibes = wxString::Format(
        "%.0f", routemapoverlay->RouteInfo(RouteMapOverlay::JIBES));
    SailPlanChanges = wxString::Format(
        "%.0f", routemapoverlay->RouteInfo(RouteMapOverlay::SAIL_PLAN_CHANGES));

    // CUSTOMIZATION  Display sailing comfort
    int comfort_level = routemapoverlay->RouteInfo(RouteMapOverlay::COMFORT);
    Comfort = RouteMapOverlay::sailingConditionText(comfort_level);
  }
  // -----------------------------------
  //  2. Compute and Update State field
  // -----------------------------------
  if (!routemapoverlay->Valid()) {
    State = _("Invalid Start/End");
    wxString error = routemapoverlay->GetError();
    wxString weatherError = routemapoverlay->GetWeatherForecastError();
    if (!error.IsEmpty())
      State += ": " + error;
    else if (!weatherError.IsEmpty())
      State += ": " + weatherError;
    return;
  }

  if (routemapoverlay->Running()) {
    State = _("Computing...");
    return;
  }

  if (routemapoverlay->m_Stopped) {
    State = _("Stopped");
    return;
  }
  // --------------------------------------------
  //  3. Finished Route
  // --------------------------------------------
  if (routemapoverlay->Finished()) {
    if (routemapoverlay->ReachedDestination()) {
      State = _("Complete");
    } else {
      // Partial / failed completion
      State = "";
      bool needsComma = false;

      wxString weatherStatus = routemapoverlay->GetWeatherForecastError();
      if (weatherStatus != wxEmptyString) {
        if (needsComma) State += ", ";
        State += _("Grib");
        State += ": ";
        State += weatherStatus;
        needsComma = true;
      }

      PolarSpeedStatus polarStatus = routemapoverlay->GetPolarStatus();
      if (polarStatus != POLAR_SPEED_SUCCESS) {
        if (needsComma) State += ", ";
        State += _("Polar");
        State += ": ";
        State += Polar::GetPolarStatusMessage(polarStatus);
        needsComma = true;
      }

      wxString gribError = routemapoverlay->GetGribError();
      if (gribError != wxEmptyString) {
        if (needsComma) State += ", ";
        State += gribError;
        needsComma = true;
      }

      if (routemapoverlay->LandCrossing()) {
        if (needsComma) State += ", ";
        State += _("Land");
        State += ": ";
        State += _("Failed");
        needsComma = true;
      }

      if (routemapoverlay->BoundaryCrossing()) {
        if (needsComma) State += ", ";
        State += _("Boundary");
        State += ": ";
        State += _("Failed");
      }
    }
    return;
  }
  // -----------------------------------------
  //  4. Waiting in queue state
  // -----------------------------------------
  if (wr->IsWaiting(routemapoverlay)) {
    State = _("Waiting...");
    return;
  }

  // -------------------------------------
  // 5. READY state (idle, not computed)
  // --------------------------------------
  State = _("Ready");
}



// MODERN

void WeatherRouting::RebuildList() {
  // Preserve selection
  std::vector<WeatherRoute*> selected;
  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
    if (item == -1) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));
    selected.push_back(wr);
  }

  // Preserve scroll position
  int top = m_panel->m_lWeatherRoutes->GetTopItem();

  // Clear and rebuild
  m_panel->m_lWeatherRoutes->Freeze();
  m_panel->m_lWeatherRoutes->DeleteAllItems();

  for (auto* wr : m_WeatherRoutes) {
    if (!wr->Filtered) {
      wxListItem item;
      item.SetId(m_panel->m_lWeatherRoutes->GetItemCount());
      item.SetData(wr);
      long idx = m_panel->m_lWeatherRoutes->InsertItem(item);
      UpdateItem(idx, true);
    }
  }

  // Restore selection
  for (long i = 0; i < m_panel->m_lWeatherRoutes->GetItemCount(); i++) {
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));

    if (std::find(selected.begin(), selected.end(), wr) != selected.end())
      m_panel->m_lWeatherRoutes->SetItemState(i, wxLIST_STATE_SELECTED,
                                              wxLIST_STATE_SELECTED);
  }

  // Restore scroll position
  if (top >= 0) m_panel->m_lWeatherRoutes->EnsureVisible(top);

  m_panel->m_lWeatherRoutes->Thaw();
}



/*********************************************************/
/*   10.Thread Lifecycle(Modern 3?Phase Model)     */
/*********************************************************/
// StopAll
//    Stops all route threads safely
//    by signaling workers to stop, waiting for worker
//    exit signal, and thencleaning up
// ResetAll
//    Resets all routes using the unified 3 phase lifecycle
//    Stops all threads, resets each overlay, then updates the UI
// WaitForAllRoutesToStop
//    Waits for all route threads to exit and be joined
//-------------------------
// Stop(RouteMapOverlay*)
//    Stops a single route thread safely
// Reset(RouteMapOverlay*)
//    Resets a single route using the unified 3 phase lifecycle
//-------------------------
// ResetSelected
//   Stops and resets only the selected RouteMapOverlay objects
//   then updates the UI
// WaitForRoutesToStop
//   Waits for the specified route threads to exit and be joined
//   by iterating over a list of RouteMapOverlay pointers

//------------------------------------------
//   10.1 Global
//------------------------------------------



// Option B : Replace with a no?op stub(temporary)
// the symbol around during cleanup  Now Stop() is the safety mechanism
     void WeatherRouting::WaitForAllRoutesToStop() {
      wxLogMessage("WeatherRouting::WaitForAllRoutesToStop - no-op (modern)");
    }


// ============================================================================
    // WeatherRouting::Stop
    // Modern deterministic shutdown of all RouteMapOverlay worker threads,
    // followed by lifecycle invariant verification.
// ========================================================================
    // Use  RouteMapOverlay::Stop() as the canonical per-overlay shutdown method
    // that handles signaling, waiting, joining, and cleanup internally
    // This ensures a consistent and safe shutdown process for each overlay,
    // and allows StopSelected() and StopAll() to simply call this method for
    // each overlay without needing to manage the complex shutdown logic themselves.
    // To stop one overlay  ov->Stop();



// ============================================================================
    // WeatherRouting::StopSelected
    // Modern deterministic shutdown of all RouteMapOverlay worker threads,
    // followed by lifecycle invariant verification.
// ========================================================================

void WeatherRouting::StopSelected() {
      if (m_shuttingDown) {
        wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
        return;
      }

      wxLogMessage("WR: StopSelected ? BEGIN");

      auto overlays = GetSelectedOverlays();
      if (overlays.empty()) {
        wxLogMessage("WR: StopSelected ? no routes selected");
        return;
      }

      for (auto* ov : overlays) {
        if (!ov) continue;

        wxLogMessage("WR: StopSelected ? stopping overlay=%p", ov);

        ov->Stop();           // stop + join + cleanup
        ov->DeleteThread();   // ensure thread pointer is null
        ov->ResetFinished();  // clear compute state
        ov->MarkDirty();      // force UI refresh
      }

      m_positionOnRoute = nullptr;

      UpdateStates();
      SaveXML(true);
      AssertThreadLifecycleInvariants();

      wxLogMessage("WR: StopSelected ? END");
    }


// ============================================================================
// WeatherRouting::StopAll
// Modern deterministic shutdown of all RouteMapOverlay worker threads,
// followed by lifecycle invariant verification.
// ============================================================================
void WeatherRouting::StopAll() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("WeatherRouting::StopAll - BEGIN");

  // ---------------------------------------------------------------------
  // 1. Stop each overlay deterministically
  // ---------------------------------------------------------------------
  for (auto* wr : m_WeatherRoutes) {
    if (!wr || !wr->routemapoverlay) continue;

    RouteMapOverlay* ov = wr->routemapoverlay;

    wxLogMessage("StopAll: calling Stop() on overlay=%p", ov);
    ov->Stop();  // handles signaling, waiting, joining, cleanup
  }

  // ---------------------------------------------------------------------
  // 2. Refresh UI state
  // ---------------------------------------------------------------------
  UpdateStates();

  // ---------------------------------------------------------------------
  // 3. Assert modern lifecycle invariants
  // ---------------------------------------------------------------------
  AssertThreadLifecycleInvariants();

  wxLogMessage("WeatherRouting::StopAll - END");
}


// ============================================================================
// WeatherRouting::Reset
// Modern per-overlay reset: ensure no worker, clear compute state, mark dirty,
// refresh UI, persist, and assert lifecycle invariants.
// ============================================================================
void WeatherRouting::Reset(RouteMapOverlay* ov) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  if (!ov) return;

  wxLogMessage("WeatherRouting::Reset - overlay=%p", ov);

  // Ensure no worker thread is running
  ov->Stop();          // safe even if no thread exists
  ov->DeleteThread();  // ensure thread pointer is null

  // Clear compute/finished state
  ov->ResetFinished();

  // Mark overlay dirty so dependent UI/computed fields refresh on demand
  ov->MarkDirty();

  // Refresh UI state and persist
  UpdateStates();
  SaveXML(true);

  // Assert lifecycle invariants
  AssertThreadLifecycleInvariants();
}



// ============================================================================
// WeatherRouting::ResetSelected
// Modern per-route reset: stop and reset only the selected overlays,
// refresh UI state, and assert lifecycle invariants.
// ============================================================================
void WeatherRouting::ResetSelected() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("============================================================");
  wxLogMessage("WeatherRouting::ResetSelected - BEGIN");

  // ---------------------------------------------------------------------
  // 1. Collect selected overlays (modern helper)
  // ---------------------------------------------------------------------
  std::vector<RouteMapOverlay*> overlays = GetSelectedOverlays();

  wxLogMessage("ResetSelected: %zu overlay(s) selected", overlays.size());

  if (overlays.empty()) {
    wxLogMessage("ResetSelected: no routes selected ? nothing to do");
    wxLogMessage("WeatherRouting::ResetSelected - END (no selection)");
    wxLogMessage(
        "============================================================");
    return;
  }

  // ---------------------------------------------------------------------
  // 2. Reset each selected overlay using the canonical per-overlay reset
  // ---------------------------------------------------------------------
  for (auto* ov : overlays) {
    if (!ov) {
      wxLogWarning("ResetSelected: encountered NULL overlay pointer");
      continue;
    }

    wxLogMessage("ResetSelected: invoking Reset() for overlay=%p", ov);
    Reset(ov);
  }

  // ---------------------------------------------------------------------
  // 3. Clear cursor highlight
  // ---------------------------------------------------------------------
  m_positionOnRoute = nullptr;

  // ---------------------------------------------------------------------
  // 4. Refresh UI state
  // ---------------------------------------------------------------------
  UpdateStates();
  SaveXML(true);

  // ---------------------------------------------------------------------
  // 5. Assert lifecycle invariants
  // ---------------------------------------------------------------------
  AssertThreadLifecycleInvariants();

  wxLogMessage("WeatherRouting::ResetSelected - END");
  wxLogMessage("============================================================");
}




// ============================================================================
// WeatherRouting::ResetAll
// Modern global reset: stop all overlays, reset compute state, refresh UI,
// and assert lifecycle invariants.
// ============================================================================
void WeatherRouting::ResetAll() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("WeatherRouting::ResetAll - BEGIN");

  // ---------------------------------------------------------------------
  // 1. Stop all worker threads
  // ---------------------------------------------------------------------
  StopAll();

  // ---------------------------------------------------------------------
  // 2. Reset each overlay using the modern lifecycle
  // ---------------------------------------------------------------------
  for (auto* wr : m_WeatherRoutes) {
    if (!wr || !wr->routemapoverlay) continue;

    RouteMapOverlay* ov = wr->routemapoverlay;

    ov->DeleteThread();   // ensure no worker exists
    ov->ResetFinished();  // clear compute state
    ov->MarkDirty();      // force UI to refresh computed fields
  }

  // ---------------------------------------------------------------------
  // 3. Clear cursor highlight
  // ---------------------------------------------------------------------
  m_positionOnRoute = nullptr;

  // ---------------------------------------------------------------------
  // 4. Refresh UI state
  // ---------------------------------------------------------------------
  UpdateStates();

  // ---------------------------------------------------------------------
  // 5. Autosave
  // ---------------------------------------------------------------------
  SaveXML(true);

  // ---------------------------------------------------------------------
  // 6. Assert modern lifecycle invariants
  // ---------------------------------------------------------------------
  AssertThreadLifecycleInvariants();

  wxLogMessage("WeatherRouting::ResetAll - END");
}



/
/*********************************************************/
/*   11.Compute Scheduler     */
/*********************************************************/
// StartAll
//   Begins processing all RouteMapOverlay objects
//   by populating the waiting list and starting the
//   compute scheduler timer.
// OnComputationTimer
//   Is the timer event handler that manages the compute
//   scheduling, worker startup, and UI updates.
// OnHideConfigurationTimer
//   Handles delayed hiding of the configuration dialog
//   after computations complete.
// FirstCurrentRouteMap
//   Returns the first RouteMapOverlay in the current
//   selection (or NULL if none).
// CurrentRouteMaps
//   Returns a list of all RouteMapOverlay objects
//   corresponding to the current selection in the UI.
//   If includeUnselected==true, returns ALL overlays.



void WeatherRouting::OnHideConfigurationTimer(wxTimerEvent& event) {
  m_ConfigurationDialog.Hide();
}


void WeatherRouting::OnComputationTimer(wxTimerEvent& event) {
  // Safety: UI must exist
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  // =========================================================
  // 1. CLEAN UP RUNNING OVERLAYS
  //
  // Each RouteMapOverlay owns its worker thread.
  // The scheduler NEVER joins or deletes threads directly.
  // Instead, it checks overlay state:
  //   - Running() means the worker thread is alive
  //   - IsThreadExited() means the worker thread has returned
  //   - Stop() performs the join + cleanup on the overlay
  //
  // This ensures thread lifecycle is race?free and deterministic.
  // =========================================================
  for (auto it = m_RunningRouteMaps.begin(); it != m_RunningRouteMaps.end();) {
    RouteMapOverlay* ov = *it;
    if (!ov) {
      it = m_RunningRouteMaps.erase(it);
      continue;
    }

    // Worker thread has exited: overlay must finalize its own cleanup.
    // Stop() joins the thread, clears m_Thread, sets m_Stopped, etc.
    if (ov->ThreadExited()) {
      ov->Stop();
    }

    // If overlay is no longer Running(), the worker thread is gone.
    // Remove it from the running list and update UI.
    if (!ov->Running()) {
      UpdateRouteMap(ov);  // WeatherRoute::Update() computes correct State
      it = m_RunningRouteMaps.erase(it);
    } else {
      // Still computing: update UI row
      UpdateRouteMap(ov);
      ++it;
    }
  }
  // =========================================================
  // 2. PROMOTE WAITING ? RUNNING
  //
  // Only the scheduler starts worker threads.
  // Concurrency limit is enforced here.
  //
  // ov->Start(error):
  //   - Creates worker thread
  //   - Sets Running() = true
  //   - Returns false if thread could not be created
  //
  // If Start() fails, overlay remains non?running and is NOT requeued.
  // =========================================================
  // _CRTDBG_REPORT_FLAG |= _CRTDBG_LEAK_CHECK_DF; 
  //  const int maxConcurrent = GetSettingsDialog().m_sMaxConcurrent->GetValue();

  const int maxConcurrent = 1;  // modern architecture: one thread at a time

  while ((int)m_RunningRouteMaps.size() < maxConcurrent &&
         !m_WaitingRouteMaps.empty()) {
    RouteMapOverlay* ov = m_WaitingRouteMaps.front();
    m_WaitingRouteMaps.pop_front();

    if (!ov) continue;

    wxString error;
    if (!ov->Start(error)) {
      // Worker thread could not be created.
      // UI will show the error via WeatherRoute::Update().
      wxLogMessage("OnComputationTimer: Failed to start overlay: %s",
                   error.mb_str());
      UpdateRouteMap(ov);
      continue;
    }

    // Worker thread successfully created.
    m_RunningRouteMaps.push_back(ov);
    UpdateRouteMap(ov);  // State becomes "Computing..."
  }
  // =========================================================
  // 3. GRIB REQUEST HANDLING
  //
  // Only one overlay at a time may request GRIB.
  // NeedsGrib() is set by the worker thread when it reaches a GRIB boundary.
  //
  // The scheduler:
  //   - detects the first overlay needing GRIB
  //   - sets m_RouteMapOverlayNeedingGrib
  //   - calls RequestGrib() (main?thread safe)
  //
  // Worker threads remain blocked until GRIB arrives.
  // =========================================================

  // OLD CODE  REMOVED FOR CLARITY
  // m_RouteMapOverlayNeedingGrib = nullptr;

  //for (auto* ov : m_RunningRouteMaps) {
  //  if (ov && ov->NeedsGrib()) {
  //    m_RouteMapOverlayNeedingGrib = ov;
  //    RequestGrib();
  //    break;
  //   }
  // }
  // =========================================================
  // 4. PROGRESS BAR UPDATE
  //
  // Progress = total - waiting - running
  // Clamped to [0, total].
  //
  // Worker threads update Finished() internally.
  // Scheduler updates progress only from main thread.
  // =========================================================
  if (m_panel->m_gProgress) {
    int done = m_RoutesToRun - (int)m_WaitingRouteMaps.size() -
               (int)m_RunningRouteMaps.size();

    if (done < 0) done = 0;
    if (done > (int)m_RoutesToRun) done = m_RoutesToRun;

    m_panel->m_gProgress->SetValue(done);
  }
  // =========================================================
  // 5. UPDATE DIALOGS
  //
  // Statistics, Report, and Plot dialogs are read?only views.
  // They must be updated from the main thread only.
  // =========================================================
  UpdateDialogs();
  // =========================================================
  // 6. UPDATE COMPUTE STATE (buttons, status text)
  //
  // Compute enabled when at least one route is Ready/NotComputed.
  // Stop enabled when at least one worker thread is alive.
  //
  // This function does NOT touch worker threads.
  // =========================================================
  UpdateComputeState();
  // =========================================================
  // 7. RESTART TIMER IF WORK REMAINS
  //
  // The scheduler runs as a one?shot timer.
  // It restarts itself only when:
  //   - at least one worker thread is alive, OR
  //   - at least one overlay is waiting to be started
  //
  // When both lists are empty, computation is complete.
  // =========================================================
  if (!m_RunningRouteMaps.empty() || !m_WaitingRouteMaps.empty()) {
    m_tCompute.Start(25, true);
  } else {
    m_bRunning = false;
  }
  AssertSchedulerInvariants();
}



// MODERN
RouteMapOverlay* WeatherRouting::FirstCurrentRouteMap() {
  // Find the first selected WeatherRoute in the list control
  long item = m_panel->m_lWeatherRoutes->GetNextItem(-1, wxLIST_NEXT_ALL,
                                                     wxLIST_STATE_SELECTED);

  if (item < 0) return nullptr;

  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
      wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

  return (wr && wr->routemapoverlay) ? wr->routemapoverlay : nullptr;
}
}

// COMPUTE CURRENT ROUTEMAPS






// ============================================================================
// WeatherRouting::ComputeAllRoutes
// Modern compute entry point: start computation on all overlays.
// No scheduler, no waiting lists, no running lists.
// ============================================================================
// MODERN
void WeatherRouting::ComputeAllRoutes() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("WeatherRouting::ComputeAllRoutes - BEGIN");

  // ---------------------------------------------------------------------
  // 1. Iterate over all overlays
  // ---------------------------------------------------------------------
  for (auto* ov : m_RouteMapOverlays) {
    if (!ov) continue;

    WeatherRoute* wr = ov->m_weatherRoute;
    if (!wr) continue;

    // Skip if already running
    if (ov->Running()) {
      wxLogMessage("ComputeAllRoutes: overlay=%p already running", ov);
      continue;
    }

    wxLogMessage("ComputeAllRoutes: starting overlay=%p", ov);

    // Ensure no stale worker thread exists
    ov->Stop();
    ov->DeleteThread();

    // Reset compute state
    wr->ClearComputedFields();
    ov->ResetFinished();
    ov->MarkDirty();

    // Launch computation thread

    // Launch computation thread
    wxString error;
    ov->Start(error);
  }

  // ---------------------------------------------------------------------
  // 2. Refresh UI state
  // ---------------------------------------------------------------------
  UpdateStates();

  // ---------------------------------------------------------------------
  // 3. Assert lifecycle invariants
  // ---------------------------------------------------------------------
  AssertThreadLifecycleInvariants();

  wxLogMessage("WeatherRouting::ComputeAllRoutes - END");
}




/*********************************************************/
/* 2  ROUTE / OVERLAY DELETION PIPELINE    */
/*********************************************************/
// DeleteRouteMaps
// Safely deletes the given list of RouteMapOverlay objects
// following a modern 4?phase lifecycle:
//   1. Signal all overlays to stop
//   2. Wait for all worker threads to exit
//   3. Remove overlays from scheduler lists
//   4. Remove overlays + WeatherRoute objects
//   5. Rebuild the wxListCtrl from scratch
//   6. UI updates


// ============================================================================
// WeatherRouting::OnDeleteSelected
// Modern delete handler: deletes only the selected routes.
// ============================================================================
// MODERN

void WeatherRouting::OnDeleteSelected(wxCommandEvent& event) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("OnDeleteSelected(): deleting selected routes");

  // Collect selected overlays using the modern selection helper
  std::vector<RouteMapOverlay*> selected = GetSelectedOverlays();
  if (selected.empty()) {
    wxLogMessage("OnDeleteSelected(): no selection");
    return;
  }

  // Convert to std::list for DeleteRouteMaps()
  std::list<RouteMapOverlay*> overlays(selected.begin(), selected.end());

  DeleteRouteMaps(overlays);
}


// ============================================================================
// WeatherRouting::OnDeleteAll
// Modern delete handler: deletes all routes.
// ============================================================================
// MODERN
void WeatherRouting::OnDeleteAll(wxCommandEvent& event) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("OnDeleteAll(): deleting all routes");

  DeleteAllRoutes();
}




// ============================================================================
// WeatherRouting::DeleteRouteMaps
// Modern batch deletion: delete each overlay using the canonical per-overlay
// deletion path (DeleteRouteMap). No scheduler, no waiting lists, no legacy UI.
//
// Notes:
//  ? DeleteRouteMap(ov) performs the full lifecycle shutdown:
//        Stop() ? DeleteThread() ? remove from lists ? delete WeatherRoute
//        ? rebuild list control ? UpdateStates() ? SaveXML()
//  ? This wrapper simply applies that canonical deletion to a group.
//  ? We keep a final invariant check at the batch boundary.
// ============================================================================
// MODERN

void WeatherRouting::DeleteRouteMaps(
    const std::list<RouteMapOverlay*>& overlays) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  if (overlays.empty()) return;

  wxLogMessage("WeatherRouting::DeleteRouteMaps - count=%zu", overlays.size());

  // ---------------------------------------------------------------------
  // 1. Apply canonical deletion to each overlay
  //    DeleteRouteMap() handles:
  //      ? stopping worker thread
  //      ? deleting thread object
  //      ? removing WeatherRoute + overlay from all lists
  //      ? rebuilding list control
  //      ? updating UI + saving XML
  // ---------------------------------------------------------------------
  for (auto* ov : overlays) {
    if (!ov) continue;
    DeleteRouteMap(ov);
  }

  // ---------------------------------------------------------------------
  // 2. Final lifecycle invariant check
  //    Ensures no stale threads, no dangling pointers, no partial cleanup.
  // ---------------------------------------------------------------------
  AssertThreadLifecycleInvariants();
}


// ============================================================================
// WeatherRouting::DeleteRouteMap
// Canonical per-overlay deletion. This performs the full, modern lifecycle:
//   ? deterministically stop worker thread
//   ? delete thread object
//   ? remove WeatherRoute + overlay from model + UI
//   ? clear any UI cursor state
//   ? refresh UI + persist XML
//   ? assert lifecycle invariants
//
// Notes:
//   ? No scheduler lists, no legacy flags, no waiting/running queues.
//   ? This is the ONLY correct place to delete a route + overlay.
// ============================================================================
// MODERN
void WeatherRouting::DeleteRouteMap(RouteMapOverlay* ov) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  if (!ov) return;

  wxLogMessage("WeatherRouting::DeleteRouteMap - overlay=%p", ov);

  // ---------------------------------------------------------------------
  // 1. Find owning WeatherRoute
  //    Modern architecture: WeatherRoute owns exactly one overlay.
  // ---------------------------------------------------------------------
  WeatherRoute* owner = nullptr;
  for (auto* wr : m_WeatherRoutes) {
    if (wr && wr->routemapoverlay == ov) {
      owner = wr;
      break;
    }
  }

  if (!owner) {
    wxLogMessage("DeleteRouteMap: no owning WeatherRoute found for overlay=%p",
                 ov);
    return;
  }

  // ---------------------------------------------------------------------
  // 2. Deterministically stop worker thread
  //    Stop() sets finished flag + joins thread.
  //    DeleteThread() ensures no stale thread pointer remains.
  // ---------------------------------------------------------------------
  ov->Stop();
  ov->DeleteThread();

  // ---------------------------------------------------------------------
  // 3. Remove from UI list control
  //    The list control stores WeatherRoute* as row data.
  // ---------------------------------------------------------------------
  if (m_panel && m_panel->m_lWeatherRoutes) {
    wxListCtrl* list = m_panel->m_lWeatherRoutes;

    long count = list->GetItemCount();
    for (long i = 0; i < count; i++) {
      WeatherRoute* wrItem =
          reinterpret_cast<WeatherRoute*>(wxUIntToPtr(list->GetItemData(i)));

      if (wrItem == owner) {
        list->DeleteItem(i);
        break;
      }
    }
  }

  // ---------------------------------------------------------------------
  // 4. Remove from model list
  // ---------------------------------------------------------------------
  m_WeatherRoutes.remove(owner);

  // ---------------------------------------------------------------------
  // 5. Destroy overlay + route
  //    Order matters: delete overlay first, then route.
  // ---------------------------------------------------------------------
  delete ov;
  owner->routemapoverlay = nullptr;
  delete owner;

  // ---------------------------------------------------------------------
  // 6. Clear any UI cursor highlight referencing this route
  // ---------------------------------------------------------------------
  m_positionOnRoute = nullptr;

  // ---------------------------------------------------------------------
  // 7. Refresh UI + persist
  //    Modern UI pipeline: UpdateStates() + SaveXML()
  // ---------------------------------------------------------------------
  UpdateStates();
  SaveXML(true);

  // ---------------------------------------------------------------------
  // 8. Assert lifecycle invariants
  // ---------------------------------------------------------------------
  AssertThreadLifecycleInvariants();
}




/*********************************************************/
/*    13.Batch Routing    */
/*********************************************************/
// GenerateBatch
//   Generates multiple weather routing configurations
//   based on user-defined parameters in the ConfigurationBatchDialog.
// --------------------------------------------------------------
// MODERN
void WeatherRouting::GenerateBatch() {
  // 1. Collect overlays for all *selected* WeatherRoutes
  std::list<RouteMapOverlay*> routemapoverlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay)
      routemapoverlays.push_back(wr->routemapoverlay);
  }

  if (routemapoverlays.empty()) return;

  // 2. Prepare progress dialog and batch timing parameters
  wxProgressDialog* progressdialog = NULL;
  int count = routemapoverlays.size(), c = 0;
  int times = 0;

  wxTimeSpan StartSpan, StartSpacingSpan;
  double days, hours;

  ConfigurationBatchDialog& dlg = m_ConfigurationBatchDialog;
  dlg.m_tStartDays->GetValue().ToDouble(&days);
  StartSpan = wxTimeSpan::Days(days);

  dlg.m_tStartHours->GetValue().ToDouble(&hours);
  StartSpan += wxTimeSpan::Seconds(3600 * hours);

  dlg.m_tStartSpacingDays->GetValue().ToDouble(&days);
  StartSpacingSpan = wxTimeSpan::Days(days);

  dlg.m_tStartSpacingHours->GetValue().ToDouble(&hours);
  StartSpacingSpan += wxTimeSpan::Seconds(3600 * hours);

  if (!StartSpacingSpan.GetSeconds().ToLong()) {
    wxMessageDialog mdlg(this, _("Zero time span forbidden, aborting."),
                         _("Weather Routing"), wxOK | wxICON_ERROR);
    mdlg.ShowModal();
    return;
  }

  wxDateTime StartTime = wxDateTime::Now(), EndTime = StartTime + StartSpan;

  for (wxDateTime start = StartTime; start <= EndTime;
       start += StartSpacingSpan)
    times++;

  int sources = 0;
  for (auto it = dlg.sources.begin(); it != dlg.sources.end(); it++)
    for (auto it2 = (*it)->destinations.begin();
         it2 != (*it)->destinations.end(); it2++)
      sources++;

  count *= sources;
  count *= dlg.m_lBoats->GetCount();

  if (count > 10) {
    progressdialog = new wxProgressDialog(
        _("Batch configuration"), _("Weather Routing"), count, this,
        wxPD_CAN_ABORT | wxPD_ELAPSED_TIME | wxPD_REMAINING_TIME);
  }

  // 3. Main batch generation loop
  for (auto* ov : routemapoverlays) {
    RouteMapConfiguration configuration = ov->GetConfiguration();

    EndTime = configuration.StartTime + StartSpan;

    for (; configuration.StartTime <= EndTime;
         configuration.StartTime += StartSpacingSpan) {
      for (auto it = dlg.sources.begin(); it != dlg.sources.end(); it++) {
        configuration.Start = (*it)->Name;

        for (auto it2 = (*it)->destinations.begin();
             it2 != (*it)->destinations.end(); it2++) {
          configuration.End = (*it2)->Name;

          for (unsigned int boatindex = 0; boatindex < dlg.m_lBoats->GetCount();
               boatindex++) {
            configuration.boatFileName = dlg.m_lBoats->GetString(boatindex);

            for (int windstrength = dlg.m_sWindStrengthMin->GetValue();
                 windstrength <= dlg.m_sWindStrengthMax->GetValue();
                 windstrength += dlg.m_sWindStrengthStep->GetValue()) {
              configuration.WindStrength = windstrength / 100.0;

              AddConfiguration(configuration);

              WeatherRoute* newWR = m_WeatherRoutes.back();
              RouteMapOverlay* newOV = newWR->routemapoverlay;

              newOV->LoadBoat();
              configuration = newOV->GetConfiguration();

              if (progressdialog && !progressdialog->Update(c++)) goto abort;
            }
          }
        }
      }
    }
  }

abort:
  // 4. Cleanup: delete the overlays used for batch generation
  for (auto* ov : routemapoverlays) DeleteRouteMap(ov);

  delete progressdialog;
}


/*********************************************************/
/*    14.Export / Track / Route Saving    */
/*********************************************************/
// OnSaveAsTrack
//   Saves the selected RouteMapOverlay as a GPX track.
// OnSaveAllAsTracks
//    Saves all RouteMapOverlay objects as GPX tracks.
// OnSaveAsRoute
//   Saves the selected RouteMapOverlay as a GPX route.
// ShowRouteSaveOptionsDialog
//   Shows a dialog to get route save options from the user.
//   and returns the selected options.
// OnExportRouteAsGPX
//   Currently disabled. Placeholder for future functionality.
// SaveRouteOptions
//   Struct holding route save options.
// SaveAsTrack
//   Saves the given RouteMapOverlay as a GPX track.
//   Applies simplification if requested. Prompts for filename.
// SaveAsRoute
//   Saves the given RouteMapOverlay as a GPX route.
// SaveSimplifiedRouteAsGPX
//   Saves a simplified version of the given RouteMapOverlay
//   as a GPX route, applying the specified maximum time penalty.
//   Prompts for filename.

// MODERN
void WeatherRouting::OnSaveAsTrack(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  if (overlays.empty()) return;

  // ---------------------------------------------------------------------
  // 2. Save each selected overlay as a track
  // ---------------------------------------------------------------------
  for (auto* ov : overlays) {
    if (!ov) continue;

    SaveAsTrack(*ov);
  }
}


// MODERN
void WeatherRouting::OnSaveAllAsTracks(wxCommandEvent& event) {
  const int count = m_panel->m_lWeatherRoutes->GetItemCount();

  for (int i = 0; i < count; i++) {
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));

    if (!wr || !wr->routemapoverlay) continue;

    SaveAsTrack(*wr->routemapoverlay);
  }
}

// MODERN
void WeatherRouting::OnSaveAsRoute(wxCommandEvent& event) {
  // 1. Collect overlays for all *selected* WeatherRoutes
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  // 2. If nothing is selected, warn the user
  if (overlays.empty()) {
    wxMessageDialog mdlg(this, _("No weather route selected"),
                         _("Weather Routing"), wxOK | wxICON_WARNING);
    mdlg.ShowModal();
    return;
  }

  // 3. Saving logic continues below (your existing SaveAsRoute handler)
}

// MODERN   Disable stub handler for future route export functionality
void WeatherRouting::OnExportRouteAsGPX(wxCommandEvent & event) {
    wxMessageDialog mdlg(this, _("Export Route As GPX is currently disabled."),
                         _("Weather Routing"), wxOK | wxICON_INFORMATION);
    mdlg.ShowModal();
}

// MODERN
WeatherRouting::SaveRouteOptions
  WeatherRouting::ShowRouteSaveOptionsDialog() {
    SaveRouteOptions options;
    options.dialogAccepted = false;

    // Create a dialog with save options.
    wxDialog dlg(this, wxID_ANY, _("Save Route Options"), wxDefaultPosition,
                 wxDefaultSize);
    wxBoxSizer* mainSizer = new wxBoxSizer(wxVERTICAL);

    // Add simplify route option.
    wxCheckBox* cbSimplifyRoute =
        new wxCheckBox(&dlg, wxID_ANY, _("Simplify Route (experimental)"));
    cbSimplifyRoute->SetValue(true);
    mainSizer->Add(cbSimplifyRoute, 0, wxALL | wxEXPAND, 5);

    // Create a panel for simplification options that will be shown/hidden.
    wxPanel* simplifyPanel = new wxPanel(&dlg, wxID_ANY);
    wxBoxSizer* simplifyPanelSizer = new wxBoxSizer(wxVERTICAL);

    // Add time penalty control.
    wxStaticText* timePenaltyLabel =
        new wxStaticText(simplifyPanel, wxID_ANY, _("Maximum Time Loss (%)"));
    simplifyPanelSizer->Add(timePenaltyLabel, 0, wxALL | wxEXPAND, 5);

    // Create a horizontal sizer for the spinner and text display
    wxBoxSizer* penaltySizer = new wxBoxSizer(wxHORIZONTAL);

    // Add a spinner control for precise 0.1% increments
    wxSpinCtrlDouble* spinnerTimePenalty = new wxSpinCtrlDouble(
        simplifyPanel, wxID_ANY, wxEmptyString, wxDefaultPosition,
        wxDefaultSize, wxSP_ARROW_KEYS, 0.0, 20.0, 5.0, 0.1);
    spinnerTimePenalty->SetDigits(1);  // Show one decimal place

    penaltySizer->Add(spinnerTimePenalty, 1, wxALL | wxEXPAND, 5);

    // Add percentage text
    wxStaticText* percentLabel =
        new wxStaticText(simplifyPanel, wxID_ANY, _("%"));
    penaltySizer->Add(percentLabel, 0, wxALL | wxALIGN_CENTER_VERTICAL, 5);

    simplifyPanelSizer->Add(penaltySizer, 0, wxALL | wxEXPAND, 5);

    simplifyPanel->SetSizer(simplifyPanelSizer);
    mainSizer->Add(simplifyPanel, 0, wxALL | wxEXPAND, 5);

    wxStdDialogButtonSizer* buttonSizer = new wxStdDialogButtonSizer();
    buttonSizer->AddButton(new wxButton(&dlg, wxID_OK, _("Save")));
    buttonSizer->AddButton(new wxButton(&dlg, wxID_CANCEL));
    buttonSizer->Realize();

    mainSizer->Add(buttonSizer, 0, wxALL | wxEXPAND, 10);

    dlg.SetSizer(mainSizer);
    mainSizer->Fit(&dlg);
    dlg.Centre();

    // Setup checkbox event to show/hide simplification panel.
    cbSimplifyRoute->Bind(
        wxEVT_CHECKBOX, [simplifyPanel, &dlg, mainSizer](wxCommandEvent&) {
          simplifyPanel->Show(simplifyPanel->IsShown() ? false : true);
          mainSizer->Fit(&dlg);
        });

    if (dlg.ShowModal() == wxID_OK) {
      options.dialogAccepted = true;
      options.simplifyRoute = cbSimplifyRoute->GetValue();
      options.maxTimePenalty = spinnerTimePenalty->GetValue() / 100.0;
    }
    return options;
  }

// MODERN
  void WeatherRouting::SaveAsTrack(RouteMapOverlay & routemapoverlay) {
    std::list<PlotData> plotdata = routemapoverlay.GetPlotData(false);

    if (plotdata.empty()) {
      wxMessageDialog mdlg(this, _("Empty routing, nothing to save\n"),
                           _("Weather Routing"), wxOK | wxICON_WARNING);
      mdlg.ShowModal();
      return;
    }

    PlugIn_Track* newPath = new PlugIn_Track;
    wxDateTime display_time = routemapoverlay.StartTime();
    if (GetSettingsDialog().m_cbUseLocalTime->GetValue())
      display_time = display_time.FromUTC();

    newPath->m_NameString =
        _("Weather Route ") + " (" + display_time.Format("%x %H:%M") + ")";

    // XXX double check time is really end time, not start time off by one.
    RouteMapConfiguration c = routemapoverlay.GetConfiguration();
    newPath->m_StartString = c.Start;
    newPath->m_EndString = c.End;
    newPath->m_GUID = GetNewGUID();

    for (auto const& it : plotdata) {
      PlugIn_Waypoint* newPoint = new PlugIn_Waypoint(
          it.lat, heading_resolve(it.lon), "circle", _("Weather Route Point"));

      newPoint->m_CreateTime = it.time;
      newPath->pWaypointList->Append(newPoint);
    }

// last point, missing if config didn't succeed
    const Position* p = routemapoverlay.GetDestinationPosition();
    if (p) {
      PlugIn_Waypoint* newPoint =
          new PlugIn_Waypoint(p->lat, heading_resolve(p->lon), "circle",
                              _("Weather Route Destination"));
      newPoint->m_CreateTime = routemapoverlay.EndTime();
      newPath->pWaypointList->Append(newPoint);
    }

    AddPlugInTrack(newPath);
    // not done PlugIn_Track DTOR
    newPath->pWaypointList->DeleteContents(true);
    newPath->pWaypointList->Clear();

    delete newPath;

    GetParent()->Refresh();

    wxMessageDialog mdlg(
        this,
        _("Routing has been saved as a track in the 'Route and "
          "Mark' Manager\n"),
        _("Weather Routing"), wxOK);
    mdlg.ShowModal();
  }


// MODERN
  void WeatherRouting::SaveAsRoute(RouteMapOverlay & routemapoverlay) {
    std::list<PlotData> plotdata = routemapoverlay.GetPlotData(false);

    if (plotdata.empty()) {
      wxMessageDialog mdlg(this, _("Empty routing, nothing to save\n"),
                           _("Weather Routing"), wxOK | wxICON_WARNING);
      mdlg.ShowModal();
      return;
    }

    PlugIn_Route_Ex* newRoute = new PlugIn_Route_Ex();
    wxDateTime display_time = routemapoverlay.StartTime();
    if (GetSettingsDialog().m_cbUseLocalTime->GetValue())
      display_time = display_time.FromUTC();

    newRoute->m_NameString =
        _("Weather Route ") + " (" + display_time.Format("%x %H:%M") + ")";

    RouteMapConfiguration c = routemapoverlay.GetConfiguration();
    newRoute->m_StartString = c.Start;
    newRoute->m_EndString = c.End;
    newRoute->m_isVisible = true;
    newRoute->m_GUID = GetNewGUID();

    for (auto const& it : plotdata) {
      PlugIn_Waypoint_Ex* newPoint = new PlugIn_Waypoint_Ex(
          it.lat, heading_resolve(it.lon), "circle", _("Weather Route Point"));
      // newPoint->m_PlannedSpeed = it.sog;
      newPoint->m_CreateTime = it.time;
      newRoute->pWaypointList->Append(newPoint);
    }

// last point, missing if config didn't succeed
    const Position* p = routemapoverlay.GetDestinationPosition();
    if (p) {
      PlugIn_Waypoint_Ex* newPoint =
          new PlugIn_Waypoint_Ex(p->lat, heading_resolve(p->lon), "circle",
                                 _("Weather Route Destination"));
      newPoint->m_CreateTime = routemapoverlay.EndTime();
      newRoute->pWaypointList->Append(newPoint);
    }


    AddPlugInRouteEx(newRoute);
    // Clean up waypoint list (ownership transferred to OpenCPN)
    newRoute->pWaypointList->DeleteContents(true);
    newRoute->pWaypointList->Clear();

    delete newRoute;

    GetParent()->Refresh();

    wxMessageDialog mdlg(
        this,
        _("Routing has been saved as a route in the 'Route and "
          "Mark' Manager\n"),
        _("Weather Routing"), wxOK);
    mdlg.ShowModal();
  }



  // MODERN

  void WeatherRouting::SaveSimplifiedRouteAsGPX(
      const RouteMapOverlay& ov, const std::list<Position*>& simplifiedRoute,
      const wxString& filename);





/*********************************************************/
/*    15. UI Update Pipeline (Unified, Deterministic   */
/*********************************************************/
/*
Update, RebuidList  Reset(overlay)- Key Roles
Reset(overlay)
    Clears the a RouteMapOverlay state
ResetSelected()
    Stops and clears only the selected RouteMapOverlay   objects, then
    updates their states in the UI.
ResetAll ()
    Stops and clears all RouteMapOverlay objects,
    then updates their states in the UI.
OnResetSelected()
    The event handler that calls ResetSelected().
OnSaveAsTrack()
    is the event handler that saves the selected routes as tracks.
ShowRouteSaveOptionsDialog()
   Shows a dialog to get route saving   options from the user.
OnSaveAsRoute()
   Event handler that saves the selected routes as routes. T
UI Related Functions:
   RefreshUI()
      refreshes the entire UI, including list controls and dialogs
   UpdateStates()
      walks all WeatherRoute objects, calls WeatherRoute::Update(stateonly=true),
      updates the list control row RebuidList()
      rebuilds the entire wxListCtrl that displays all routes.
      Heavier than UpdateStates()
   Rebuild
      also repopulates the whole table,refreshes the UI UpdateRouteMap(overlay)
      updates only the specified  RouteMapOverlay   */


//------------------------------------------
//   15.1 Core
//------------------------------------------

// UpdateCurrentConfigurations
  // Updates the current configurations in the UI.
  // Used in multiple places to refresh the list control and related dialogs
  // after changes.
  // MODERN

void WeatherRouting::UpdateCurrentConfigurations() {
    wxLogMessage("WeatherRouting::UpdateCurrentConfigurations()");

    if (m_shuttingDown) {
      wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
      return;
    }

    // Rebuild the WeatherRoutes list control
    if (m_panel && m_panel->m_lWeatherRoutes) {
      wxListCtrl* list = m_panel->m_lWeatherRoutes;
      list->DeleteAllItems();

      long index = 0;
      for (auto* wr : m_WeatherRoutes) {
        wxListItem item;
        item.SetId(index);
        item.SetData(reinterpret_cast<wxUIntPtr>(wr));
        list->InsertItem(item);
        UpdateItem(index, true);
        index++;
      }
    }

    // Modern UI update pipeline
    UpdateAllItems(true);
    UpdateDialogs();
    UpdateComputeState();

    if (GetParent()) GetParent()->Refresh();
  }

// MODERN
  void WeatherRouting::RefreshUI() {
    // 0. Sanity check: Ensure we have a panel and list control to refresh
    if (!m_panel || !m_panel->m_lWeatherRoutes) return;

    // 1. Refresh the entire routing table
    UpdateAllItems(true);

    // 2. Update all open dialogs (Statistics, Report, Plot)
    UpdateDialogs();

    // 3. Update compute-state UI
    UpdateComputeState();

    // 4. Refresh the main panel (list control + controls)
    m_panel->Refresh();

    // 5. Refresh the Routing Table panel (if present)
    if (m_RoutingTablePanel) {
      static_cast<RoutingTablePanel*>(m_RoutingTablePanel)->PopulateTable();
    }

    // 6. Trigger a parent window refresh
    if (GetParent()) GetParent()->Refresh();
  }



//------------------------------------------
//   15.2 Per?Route
//------------------------------------------

/* THE HEART OF THE WEATHER ROUTING ENGINE                         *
 * Promotes overelays from waiting to running, checks for completed threads *
 * Starts new worker threads as needed Monitors thread completion *
 * Requests Grib data as needed for running threads         *
 * Updates UI state as needed                         *
 * Refreshes  dialogs, route map dislay and statistics periodically      *
 * Detects when all routes are finished, stops the timer cleanly      *
 * Runs the scheduler, moves routes between lists, checks thread progress.
 * Scheduler purely a state machine, not an owner of thread lifetime. *
 * Everything else ? OnCompute(), StartCompute(), StopAll(), UpdateStates(),
 * even AddConfiguration() ? exists to feed this scheduler.
 * Without OnComputationTimer, no routing computations occur
 *.and the plugin is just a static UI
 * Don't call this directly, use StartCompute() to begin computations *
 * Don't screw with the lists while this is running.
 * Keeps the UI updated as routes progress.
 * UI updates are deterministic and centralized here.
 * Everything else just marks overlays dirty and lets this
 * scheduler handle the rest.
 * Don't call UpdateRouteMap() directly, it's called from here as needed.
 * Keeps the UI in sync with the model.
 */ 

// UpdateRouteMap
//   Updates only the specified RouteMapOverlay in the wxListCtrl.
//   Called when a RouteMapOverlay changes state or completes computation.
//   Efficient targeted update to keep the UI in sync with the model.
//   Does not rebuild the entire list, only the affected row.
//   Used by the computation scheduler to refresh the UI as routes progress.
//   Searches for the WeatherRoute associated with the given RouteMapOverlay,
//   then calls UpdateItem() to refresh that row in the wxListCtrl.
//   If the RouteMapOverlay is not found, does nothing.
//   This function is more efficient than UpdateAllItems() when only one
//   route needs to be updated.
//   Note: This function assumes that each RouteMapOverlay is unique
//   and associated with only one WeatherRoute.
// 
// UpdateItem  See 9.WeatherRoute::Update(Model Update Logic
//   Updates a single row in the wxListCtrl based on the WeatherRoute data.
// UpdateAllItems

// UpdateSelectedItem
//   Updates only the selected rows in the wxListCtrl.
//------------------------------------------

// MODERN

void WeatherRouting::UpdateRouteMap(RouteMapOverlay* routemapoverlay) {
    if (!m_panel || !m_panel->m_lWeatherRoutes) return;

    wxListCtrl* lc = m_panel->m_lWeatherRoutes;

    for (int i = 0; i < lc->GetItemCount(); i++) {
      WeatherRoute* weatherroute =
          reinterpret_cast<WeatherRoute*>(wxUIntToPtr(lc->GetItemData(i)));

      if (weatherroute && weatherroute->routemapoverlay == routemapoverlay) {
        weatherroute->Update(this, false);  // modern call
        UpdateItem(i, false);               // fast UI refresh
        return;
      }
    }
  }




// MODERN
  void WeatherRouting::UpdateSelectedItems(bool changed) {
    if (!m_panel || !m_panel->m_lWeatherRoutes) return;

    wxListCtrl* lc = m_panel->m_lWeatherRoutes;

    long item = -1;

    // Iterate through all selected rows
    for (;;) {
      item = lc->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
      if (item == -1) break;

      // Update the selected row
      UpdateItem(item, changed);
    }
  }



//------------------------------------------
//   15.3 Column Helpers
//------------------------------------------
// SetColumn
//   Sets the text of a specific column in the wxListCtrl for a given row.
// ClearComputedColumns
//   Clears all computed columns for a given row in the wxListCtrl.
// UpdateStaticColumns
//   Updates the static columns (Boat, StartType, Start, End, Visible) for
//   a given row based on the WeatherRoute data.
// UpdateComputedColumns
//   Updates the computed columns (AvgSpeed, MaxSpeed, etc.) for a given row
//   based on the WeatherRoute data.
//------------------------------------------


void WeatherRouting::SetColumn(long index, int col, const wxString& value) {
  if (columns[col] >= 0)
    m_panel->m_lWeatherRoutes->SetItem(index, columns[col], value);
}

void WeatherRouting::ClearComputedColumns(long index) {
  SetColumn(index, STARTTIME, "");
  SetColumn(index, ENDTIME, "");
  SetColumn(index, TIME, "");
  SetColumn(index, DISTANCE, "");
  SetColumn(index, AVGSPEED, "");
  SetColumn(index, MAXSPEED, "");
  SetColumn(index, AVGSPEEDGROUND, "");
  SetColumn(index, MAXSPEEDGROUND, "");
  SetColumn(index, AVGWIND, "");
  SetColumn(index, MAXWIND, "");
  SetColumn(index, MAXWINDGUST, "");
  SetColumn(index, AVGCURRENT, "");
  SetColumn(index, MAXCURRENT, "");
  SetColumn(index, AVGSWELL, "");
  SetColumn(index, MAXSWELL, "");
  SetColumn(index, UPWINDPERCENTAGE, "");
  SetColumn(index, PORTSTARBOARD, "");
  SetColumn(index, TACKS, "");
  SetColumn(index, JIBES, "");
  SetColumn(index, SAILPLANCHANGES, "");
  SetColumn(index, COMFORT, "");
}


//------------------------------------------------------------------
// UpdateStaticColumns sets the non-computed columns based on the WeatherRoute
// data. These columns typically include information that doesn't change during
// computation, This includes the boat name, start type, start and end
// locations, and visibility. This function is called when a new route is added
// or when the static information of a route changes. It ensures that the UI
// reflects the current state of the WeatherRoute's static properties
//------------------------------------------------------------------


// MODERN
void WeatherRouting::UpdateStaticColumns(long index, WeatherRoute* wr) {
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  // Visible icon
  if (columns[VISIBLE] >= 0) {
    list->SetItemImage(index, wr->routemapoverlay->m_bEndRouteVisible ? 0 : -1);
  }

  SetColumn(index, BOAT, wxFileName(wr->BoatFilename).GetName());
  SetColumn(index, STARTTYPE, wr->StartType);
  SetColumn(index, START, wr->Start);
  SetColumn(index, END, wr->End);
}


// MODERN

void WeatherRouting::UpdateComputedColumns(long index, WeatherRoute* wr) {
  SetColumn(index, AVGSPEED, wr->AvgSpeed);
  SetColumn(index, MAXSPEED, wr->MaxSpeed);
  SetColumn(index, AVGSPEEDGROUND, wr->AvgSpeedGround);
  SetColumn(index, MAXSPEEDGROUND, wr->MaxSpeedGround);
  SetColumn(index, AVGWIND, wr->AvgWind);
  SetColumn(index, MAXWIND, wr->MaxWind);
  SetColumn(index, MAXWINDGUST, wr->MaxWindGust);
  SetColumn(index, AVGCURRENT, wr->AvgCurrent);
  SetColumn(index, MAXCURRENT, wr->MaxCurrent);
  SetColumn(index, AVGSWELL, wr->AvgSwell);
  SetColumn(index, MAXSWELL, wr->MaxSwell);
  SetColumn(index, UPWINDPERCENTAGE, wr->UpwindPercentage);
  SetColumn(index, PORTSTARBOARD, wr->PortStarboard);
  SetColumn(index, TACKS, wr->Tacks);
  SetColumn(index, JIBES, wr->Jibes);
  SetColumn(index, SAILPLANCHANGES, wr->SailPlanChanges);
  SetColumn(index, COMFORT, wr->Comfort);
}



//------------------------------------------
//   16. Miscellaneous UI
//------------------------------------------
// Show
//   Shows or hides all plugin dialogs and menu items.
//   When hiding, saves the current visibility state of each dialog.
//   When showing, restores each dialog to its previous visibility state.
//   Also hides the routing table panel if it exists.
//   Returns the result of the base class Show() method.
// CopyDataFiles
//   Recursively copies data files from one directory to another.
//   Takes care to create destination directories as needed.
//   maintains the directory structure.
//   and logs each file copy operation.
// StopAllRoutes -deprecated-
//   Stops all active route computations.
//------------------------------------------

bool WeatherRouting::Show(bool show) {
  m_weather_routing_pi.ShowMenuItems(show);

if (show) {
    m_ConfigurationDialog.Show(m_bShowConfiguration);
    m_ConfigurationBatchDialog.Show(m_bShowConfigurationBatch);
    m_SettingsDialog.Show(m_bShowSettings);
    m_StatisticsDialog.Show(m_bShowStatistics);
    m_ReportDialog.Show(m_bShowReport);
    m_PlotDialog.Show(m_bShowPlot);
    m_FilterRoutesDialog.Show(m_bShowFilter);
    m_RoutePositionDialog.Show(m_bShowRoutePosition);
  } else {
    // Save + hide dialogs
    m_bShowConfiguration = m_ConfigurationDialog.IsShown();
    m_ConfigurationDialog.Hide();

    m_bShowConfigurationBatch = m_ConfigurationBatchDialog.IsShown();
    m_ConfigurationBatchDialog.Hide();

    m_bShowSettings = m_SettingsDialog.IsShown();
    m_SettingsDialog.Hide();

    m_bShowStatistics = m_StatisticsDialog.IsShown();
    m_StatisticsDialog.Hide();

    m_bShowReport = m_ReportDialog.IsShown();
    m_ReportDialog.Hide();

    m_bShowPlot = m_PlotDialog.IsShown();
    m_PlotDialog.Hide();

    m_bShowFilter = m_FilterRoutesDialog.IsShown();
    m_FilterRoutesDialog.Hide();

    m_bShowRoutePosition = m_RoutePositionDialog.IsShown();
    m_RoutePositionDialog.Hide();

    // Do NOT touch AUI panes here. // AUI owns visibility of the
    // RoutingTablePanel.
    // Hide routing table panel
  //  if (m_RoutingTablePanel) {
  //    wxAuiManager* mgr = ::GetFrameAuiManager();
  //    wxAuiPaneInfo& pane = mgr->GetPane(m_RoutingTablePanel);
  //    if (pane.IsOk() && pane.IsShown()) pane.Hide();
  //    mgr->Update();
  //  }

  }
  return WeatherRoutingBase::Show(show);
}



void WeatherRouting::CopyDataFiles(wxString from, wxString to) {
  if (from[from.Len() - 1] != '\\' && from[from.Len() - 1] != '/')
    from += wxFILE_SEP_PATH;
  if (to[to.Len() - 1] != '\\' && to[to.Len() - 1] != '/')
    to += wxFILE_SEP_PATH;

  if (!wxDirExists(to))
    wxFileName::Mkdir(to, wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL);

  wxDir dir(from);
  wxString next = wxEmptyString;
  bool b = dir.GetFirst(&next);
  while (b) {
    const wxString fileFrom = from + next;
    const wxString fileTo = to + next;
    if (wxDirExists(fileFrom))
      CopyDataFiles(fileFrom, fileTo);
    else {
      wxLogMessage("WeatherRouting copy file: " + fileFrom + " to " + fileTo);
      wxCopyFile(fileFrom, fileTo);
    }
    b = dir.GetNext(&next);
  }
}


/* ************************************************************************
 *   End of WeatherRouting.cpp
 * ***********************************************************************
 */
