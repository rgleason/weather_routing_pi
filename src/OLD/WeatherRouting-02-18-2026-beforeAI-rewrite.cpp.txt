/***************************************************************************
 *   Copyright (C) 2016 by Sean D'Epagnier                                 *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
 ***************************************************************************/


// Whenever positions  change  m_PositionPanel->PopulatePositions();
// Whenever routes change  m_RouteMapPanel->PopulateRoutes();

// ======================================================================



// ======================================================================


#include <wx/wx.h>
#include <wx/aui/aui.h>
#include <wx/imaglist.h>
#include <wx/progdlg.h>
#include <wx/dir.h>
#include <wx/log.h>
#include <wx/glcanvas.h>

#include <stdlib.h>
#include <math.h>
#include <cmath>
#include <time.h>
#include <algorithm>

#include "WRPanel.h"
#include "Utilities.h"
#include "Boat.h"
#include "BoatDialog.h"
#include "RouteMapOverlay.h"
#include "weather_routing_pi.h"
#include "WeatherRouting.h"
#include "RouteSimplifier.h"
#include "AboutDialog.h"
#include "icons.h"
#include "navobj_util.h"
#include "ocpn_plugin.h"
#include "Position.h"
#include "tinyxml.h"
#include "MemoryStatusDialog.h"
#include "RouteMapPanel.h"
#include "RoutingTablePanel.h"
// #include "WeatherRoutingConfigDialog.h"
//#include "WeatherRoutingPositionPanel.h"

wxDEFINE_EVENT(EVT_ROUTEMAP_UPDATE, wxThreadEvent);


// Declare the custom event for route map updates
// This event is used by RouteMapOverlay threads to notify WeatherRouting of
// progress. it is a thread-safe event and can be sent from any thread. The
// event handler.  Globally defined event type that worker threads can post and
// the WeatherRouting can Recieve. It is in the heart of the thread to UI pipeline.
// Also the main thread event handler for this event is the main point
// where the UI gets updated based on background thread progress, so it is a
// critical part of the plugin's architecture.




// Column names
const wxString WeatherRouting::column_names[NUM_COLS] = {_("Visible"),
                                                         _("Boat"),
                                                         _("Start Type"),
                                                         _("Start"),
                                                         _("Start Time"),
                                                         _("End"),
                                                         _("End Time"),
                                                         _("Time"),
                                                         _("Distance"),
                                                         _("Avg Speed"),
                                                         _("Max Speed"),
                                                         _("Avg Speed Ground"),
                                                         _("Max Speed Ground"),
                                                         _("Avg Wind"),
                                                         _("Max Wind"),
                                                         _("Max Wind Gust"),
                                                         _("Avg Current"),
                                                         _("Max Current"),
                                                         _("Avg Swell"),
                                                         _("Max Swell"),
                                                         _("Upwind %"),
                                                         _("Port/Starboard"),
                                                         _("Tacks"),
                                                         _("Jibes"),
                                                         _("Sail Plan Changes"),
                                                         _("Comfort"),
                                                         _("State")};


/**
 * Used for NEflag argument to toSDMM_Plugin function from ocpn_plugin.h.
 * @todo Should probably be declared there instead, and probably be a boolean.
 */
enum NEflag {
  LAT = 1,
  LON = 2,
};

/**
 * Used for precision argument to toSDMM_Plugin function from ocpn_plugin.h.
 **/

enum Precision {
  LO = 0,
  HI = 1,
};

/* XPM */
static const char* eye[] = {"20 20 7 1",
                            ". c none",
                            "# c #000000",
                            "a c #333333",
                            "b c #666666",
                            "c c #999999",
                            "d c #cccccc",
                            "e c #ffffff",
                            "....................",
                            "....................",
                            "....................",
                            "....................",
                            ".......######.......",
                            ".....#aabccb#a#.....",
                            "....#deeeddeebcb#...",
                            "..#aeeeec##aceaec#..",
                            ".#bedaeee####dbcec#.",
                            "#aeedbdabc###bcceea#",
                            ".#bedad######abcec#.",
                            "..#be#d######dadb#..",
                            "...#abac####abba#...",
                            ".....##acbaca##.....",
                            ".......######.......",
                            "....................",
                            "....................",
                            "....................",
                            "....................",
                            "...................."};



WeatherRoute::WeatherRoute(WeatherRouting* parent)
    : m_parent(parent), routemapoverlay(new RouteMapOverlay(parent, this)) {}


WeatherRoute::~WeatherRoute() { delete routemapoverlay; }

static int sortcol, sortorder = 1;
// sort callback. Sort by body.
#if wxCHECK_VERSION(2, 9, 0)
int wxCALLBACK SortWeatherRoutes(wxIntPtr item1, wxIntPtr item2, wxIntPtr list)
#else
int wxCALLBACK SortWeatherRoutes(long item1, long item2, long list)
#endif
{
  wxListCtrl* lc = (wxListCtrl*)list;

  wxListItem it1, it2;

  it1.SetId(lc->FindItem(-1, item1));
  it1.SetColumn(sortcol);

  it2.SetId(lc->FindItem(-1, item2));
  it2.SetColumn(sortcol);

  lc->GetItem(it1);
  lc->GetItem(it2);

  return sortorder * it1.GetText().Cmp(it2.GetText());
}


//==============================================================
// CONSTRUCTOR  weatherrouting
//==============================================================

WeatherRouting::WeatherRouting(wxWindow* parent, weather_routing_pi& plugin)
    : WeatherRoutingBase(parent),
      m_weather_routing_pi(plugin),
      m_ConfigurationDialog(*this),
      m_ConfigurationBatchDialog(this),
      m_CursorPositionDialog(this),
      m_RoutePositionDialog(this),
      m_BoatDialog(*this),
      m_SettingsDialog(this),
      m_StatisticsDialog(this),
      m_ReportDialog(*this),
      m_PlotDialog(*this),
      m_FilterRoutesDialog(this),
      m_RoutingTablePanel(nullptr),
      m_panel(NULL),
      m_bShowConfiguration(false), // ADD THIS
      m_bShowConfigurationBatch(false),
      m_bShowSettings(false),
      m_bShowStatistics(false),
      m_bShowReport(false),
      m_bShowPlot(false),
      m_bShowFilter(false),
      m_bShowRoutePosition(false)
{
  wxLogMessage("WR: ctor START");

  // Load configuration, settings, etc.
  wxLogMessage("WR: before LoadConfigurationAndData");
  LoadConfigurationAndData();
  wxLogMessage("WR: after LoadConfigurationAndData");

  // Create the overlay FIRST before calling InitializUI
  // since some UI elements depend on it(e.g.RoutePositionDialog)
  m_pRouteMapOverlay = new RouteMapOverlay(this, nullptr);

  // Build the UI
  wxLogMessage("WR: before InitializeUI");
  InitializeUI();
  wxLogMessage("WR: after InitializeUI");

  // Bind events AFTER panels exist
  wxLogMessage("WR: before BindEvents");
  BindEvents();
  wxLogMessage("WR: after BindEvents");

  // Any remaining initialization
  m_tAutoSaveXML.SetOwner(this);
  wxLogMessage("WR: ctor END");
}


//==============================================================
// LOAD CONFIGURATION AND PLUGIN DATA AND USER SETTINGS
//==============================================================

void WeatherRouting::LoadConfigurationAndData() {
  wxFileConfig* pConf = GetOCPNConfigObject();
  pConf->SetPath("/PlugIns/WeatherRouting");

  // ---------------------------------------------------------
  // 1. Determine standard paths
  // ---------------------------------------------------------
  m_default_configuration_path =
      weather_routing_pi::StandardPath() + "WeatherRoutingConfiguration.xml";

  wxString packagedCfg = GetPluginDataDir("weather_routing_pi") +
                         "/data/WeatherRoutingConfiguration.xml";

  // ---------------------------------------------------------
  // 2. Ensure boats/ and polars/ directories exist
  // ---------------------------------------------------------
  wxString boatsdir = weather_routing_pi::StandardPath() + "/boats";
  wxString polarsdir = weather_routing_pi::StandardPath() + "/polars";

  bool forceCopyBoats = !wxFileName::DirExists(boatsdir);
  bool forceCopyPolars = !wxFileName::DirExists(polarsdir);

  wxFileName fn;
  fn.Mkdir(weather_routing_pi::StandardPath(), wxS_DIR_DEFAULT,
           wxPATH_MKDIR_FULL);
  fn.Mkdir(boatsdir, wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL);
  fn.Mkdir(polarsdir, wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL);

  // ---------------------------------------------------------
  // 3. Copy boats/polars if directories were missing
  // ---------------------------------------------------------
  if (forceCopyBoats)
    CopyDataFiles(GetPluginDataDir("weather_routing_pi") + "/data/boats",
                  boatsdir);

  if (forceCopyPolars)
    CopyDataFiles(GetPluginDataDir("weather_routing_pi") + "/data/polars",
                  polarsdir);

  // ---------------------------------------------------------
  // 4. Handle versioned data updates (boats, polars, examples)
  // ---------------------------------------------------------
  int confVersion;
  pConf->Read("ConfigVersion", &confVersion, 0);

#ifndef __OCPN__ANDROID__
  int currentVersion = PLUGIN_VERSION_MAJOR * 100 + PLUGIN_VERSION_MINOR;

  if (confVersion < currentVersion) {
    wxString title = _("New or updated data available");
    wxString message = _(
        "A new version of the Weather Route plugin has been installed.\n\n"
        "\"Import new boats and polars\" will overwrite the standard boats\n"
        "and polars with newer data. If you have modified this data and not\n"
        "changed the names, your modifications will be overwritten.\n\n"
        "\"Import example configurations\" will overwrite your route\n"
        "configurations with a sample set showing how WeatherRouting works.\n");

    wxString choices[2] = {_("Import new boats and polars"),
                           _("Import example configurations")};

    wxMultiChoiceDialog dlg(this, message, title, 2, choices);

    // First-time users: select both options by default
    if (confVersion == 0) {
      wxArrayInt sel;
      sel.Add(0);
      sel.Add(1);
      dlg.SetSelections(sel);
    }

    if (dlg.ShowModal() == wxID_OK) {
      wxArrayInt result = dlg.GetSelections();

      for (size_t i = 0; i < result.GetCount(); i++) {
        if (result[i] == 0) {
          CopyDataFiles(GetPluginDataDir("weather_routing_pi") + "/data/boats",
                        boatsdir);
          CopyDataFiles(GetPluginDataDir("weather_routing_pi") + "/data/polars",
                        polarsdir);
        } else if (result[i] == 1) {
          if (wxFileName::FileExists(packagedCfg))
            wxCopyFile(packagedCfg, m_default_configuration_path);
        }
      }

      // Path may change after modal dialog
      pConf->SetPath("/PlugIns/WeatherRouting");
      pConf->Write("ConfigVersion", currentVersion);
    }
  }
#endif

  // ---------------------------------------------------------
  // 5. Load plugin settings
  // ---------------------------------------------------------
  m_SettingsDialog.LoadSettings();

  // ---------------------------------------------------------
  // 6. Read UI flags
  // ---------------------------------------------------------
  pConf->SetPath("/PlugIns/WeatherRouting");
  pConf->Read("DisableColPane", &m_disable_colpane, false);

#ifdef __OCPN__ANDROID__
  m_disable_colpane = true;
#endif
}

// For gribs    
RouteMapOverlay*& WeatherRouting::RouteMapOverlayNeedingGrib() {
  return m_RouteMapOverlayNeedingGrib;
}


//==============================================================
// INITIALIZE THE USER INTERFACE
//==============================================================


void WeatherRouting::InitializeUI() {
  // ---------------------------------------------------------
  // MAIN FRAME SETUP
  // ---------------------------------------------------------
  wxBoxSizer* topSizer = new wxBoxSizer(wxVERTICAL);

  // ---------------------------------------------------------
  // MENU BAR
  // ---------------------------------------------------------
  wxMenuBar* menuBar = new wxMenuBar;

  // FILE MENU
  wxMenu* fileMenu = new wxMenu;
  fileMenu->Append(ID_FILE_OPEN, _("Open"));
  fileMenu->Append(ID_FILE_SAVE, _("Save"));
  fileMenu->Append(ID_FILE_SAVEAS, _("Save As"));
  fileMenu->AppendSeparator();
  fileMenu->Append(ID_FILE_CLOSE, _("Close"));
  menuBar->Append(fileMenu, _("File"));

  // POSITION MENU
  wxMenu* positionMenu = new wxMenu;
  positionMenu->Append(ID_POSITION_NEW, _("New Position"));
  positionMenu->Append(ID_POSITION_EDIT, _("Edit Position"));
  positionMenu->Append(ID_POSITION_UPDATE_BOAT, _("Update Boat Position"));
  positionMenu->Append(ID_POSITION_DELETE, _("Delete"));
  positionMenu->Append(ID_POSITION_DELETE_ALL, _("Delete All"));
  menuBar->Append(positionMenu, _("Position"));

  // ROUTINGS MENU
  wxMenu* routingMenu = new wxMenu;
  routingMenu->Append(ID_ROUTING_NEW, _("New"));
  routingMenu->Append(ID_ROUTING_BATCH, _("Batch"));
  routingMenu->Append(ID_ROUTING_EDIT, _("Edit"));
  routingMenu->Append(ID_ROUTING_GOTO, _("Goto"));
  routingMenu->Append(ID_ROUTING_DELETE, _("Delete"));
  routingMenu->Append(ID_ROUTING_DELETE_ALL, _("Delete All"));
  routingMenu->AppendSeparator();
  routingMenu->Append(ID_ROUTING_COMPUTE, _("Compute"));
  routingMenu->Append(ID_ROUTING_COMPUTE_ALL, _("Compute All"));
  routingMenu->Append(ID_ROUTING_STOP, _("Stop"));
  routingMenu->Append(ID_ROUTING_RESET_ALL, _("Reset All"));
  routingMenu->AppendSeparator();
  routingMenu->Append(ID_ROUTING_SAVE_TRACK, _("Save as Track"));
  routingMenu->Append(ID_ROUTING_SAVE_ALL_TRACKS, _("Save All as Tracks"));
  routingMenu->Append(ID_ROUTING_SAVE_ROUTE, _("Save as Route"));
  routingMenu->Append(ID_ROUTING_EXPORT_GPX, _("Export Routing as GPX"));
  routingMenu->Append(ID_ROUTING_FILTER, _("Filter"));
  menuBar->Append(routingMenu, _("Routings"));

  // VIEW MENU
  wxMenu* viewMenu = new wxMenu;
  viewMenu->Append(ID_VIEW_SETTINGS, _("Settings"));
  viewMenu->Append(ID_VIEW_STATISTICS, _("Statistics"));
  viewMenu->Append(ID_VIEW_REPORT, _("Report"));
  viewMenu->Append(ID_VIEW_PLOT, _("Plot"));
  viewMenu->Append(ID_VIEW_CURSOR_POSITION, _("Cursor Position"));
  viewMenu->Append(ID_VIEW_ROUTE_POSITION, _("Route Position"));
  viewMenu->Append(ID_VIEW_ROUTING_TABLE, _("Weather Routing Table"));
  menuBar->Append(viewMenu, _("View"));

  // HELP MENU
  wxMenu* helpMenu = new wxMenu;
  helpMenu->Append(ID_HELP_INFORMATION, _("Information"));
  helpMenu->Append(ID_HELP_MANUAL, _("Manual"));
  helpMenu->Append(ID_HELP_ABOUT, _("About"));
  menuBar->Append(helpMenu, _("Help"));

  // ======================================================================
  // MAIN CONTENT AREA ? SINGLE PANEL UI (WRPanel)
  // ======================================================================

  // ---------------------------------------------------------
  // ROUTINGS PANEL (WRPanel)
  // ---------------------------------------------------------
  m_panel = new WRPanel(this, *this);
  topSizer->Add(m_panel, 1, wxEXPAND | wxALL, 5);

  // ---------------------------------------------------------
  // BUTTON ROW UNDER ROUTINGS PANEL
  // ---------------------------------------------------------
  wxBoxSizer* buttonRow = new wxBoxSizer(wxHORIZONTAL);

  m_btnCompute = new wxButton(this, ID_ROUTING_COMPUTE, _("Compute"));
  m_btnSaveTrack =
      new wxButton(this, ID_ROUTING_SAVE_TRACK, _("Save as Track"));
  m_btnSaveRoute =
      new wxButton(this, ID_ROUTING_SAVE_ROUTE, _("Save as Route"));
  m_btnExportGPX =
      new wxButton(this, ID_ROUTING_EXPORT_GPX, _("Export as GPX Route"));
  m_btnReset = new wxButton(this, ID_ROUTING_RESET, _("Reset"));
  m_btnGotoRouting = new wxButton(this, ID_GOTO_ROUTING, _("Goto Routing"));

  buttonRow->Add(m_btnCompute, 0, wxRIGHT, 5);
  buttonRow->Add(m_btnSaveTrack, 0, wxRIGHT, 5);
  buttonRow->Add(m_btnSaveRoute, 0, wxRIGHT, 5);
  buttonRow->Add(m_btnExportGPX, 0, wxRIGHT, 5);
  buttonRow->Add(m_btnReset, 0, wxRIGHT, 5);
  buttonRow->Add(m_btnGotoRouting, 0, wxRIGHT, 5);

  topSizer->Add(buttonRow, 0, wxALIGN_LEFT | wxALL, 5);

  // ---------------------------------------------------------
  // FINALIZE LAYOUT
  // ---------------------------------------------------------
  SetSizer(topSizer);
  Layout();


    // ======================================================================
  // EVENT BINDINGS FOR NEW UI
  // ======================================================================

  // ---------------------------------------------------------
  // MENU BINDINGS
  // ---------------------------------------------------------


  // FILE
  Bind(wxEVT_MENU, &WeatherRouting::OnFileOpen, this, ID_FILE_OPEN);
  Bind(wxEVT_MENU, &WeatherRouting::OnFileSave, this, ID_FILE_SAVE);
  Bind(wxEVT_MENU, &WeatherRouting::OnFileSaveAs, this, ID_FILE_SAVEAS);
  Bind(wxEVT_MENU, &WeatherRouting::OnFileClose, this, ID_FILE_CLOSE);

  // POSITION
//  Bind(wxEVT_MENU, &WeatherRouting::OnNewPosition, this, ID_POSITION_NEW);
//  Bind(wxEVT_MENU, &WeatherRouting::OnEditPosition, this, ID_POSITION_EDIT);
//Use onUpdateBoat?
//  Bind(wxEVT_MENU, &WeatherRouting::OnUpdateBoatPosition, this, ID_POSITION_UPDATE_BOAT);
//  Bind(wxEVT_MENU, &WeatherRouting::OnDeletePosition, this, ID_POSITION_DELETE);
//  Bind(wxEVT_MENU, &WeatherRouting::OnDeleteAllPositions, this, ID_POSITION_DELETE_ALL);
// Use OnGoto?	   
  Bind(wxEVT_MENU, &WeatherRouting::OnGotoRouting, this, ID_GOTO_ROUTING); 


  // ROUTINGS
  Bind(wxEVT_MENU, &WeatherRouting::OnNewRouting, this, ID_ROUTING_NEW);
  Bind(wxEVT_MENU, &WeatherRouting::OnBatchRouting, this, ID_ROUTING_BATCH);
 //We don't have this yet. 
// Bind(wxEVT_MENU, &WeatherRouting::OnEditRouting, this, ID_ROUTING_EDIT);  
  Bind(wxEVT_MENU, &WeatherRouting::OnGotoRouting, this, ID_ROUTING_GOTO);
  Bind(wxEVT_MENU, &WeatherRouting::OnDelete, this, ID_ROUTING_DELETE);
  Bind(wxEVT_MENU, &WeatherRouting::OnDeleteAll, this, ID_ROUTING_DELETE_ALL);

  Bind(wxEVT_MENU, &WeatherRouting::OnCompute, this, ID_ROUTING_COMPUTE);
  Bind(wxEVT_MENU, &WeatherRouting::OnComputeAll, this, ID_ROUTING_COMPUTE_ALL);
  Bind(wxEVT_MENU, &WeatherRouting::OnStop, this, ID_ROUTING_STOP);
  Bind(wxEVT_MENU, &WeatherRouting::OnResetAll, this, ID_ROUTING_RESET_ALL);
 //We don't have this yet.
//  Bind(wxEVT_MENU, &WeatherRouting::OnToggleVisibility, this, ID_TOGGLE_VISIBILITY);


//  Bind(wxEVT_MENU, &WeatherRouting::OnSaveAsTrack, this, ID_ROUTING_SAVE_TRACK);
// We don't have this yet.
//  Bind(wxEVT_MENU, &WeatherRouting::OnSaveAllTracks, this,ID_ROUTING_SAVE_ALL_TRACKS);


  Bind(wxEVT_MENU, &WeatherRouting::OnSaveAsRoute, this, ID_ROUTING_SAVE_ROUTE); 
//  Bind(wxEVT_MENU, &WeatherRouting::OnExportGPX, this, ID_ROUTING_EXPORT_GPX);  
//  Bind(wxEVT_MENU, &WeatherRouting::OnFilter, this, ID_ROUTING_FILTER);

  // VIEW
//  Bind(wxEVT_MENU, &WeatherRouting::OnSettings, this, ID_VIEW_SETTINGS);
  Bind(wxEVT_MENU, &WeatherRouting::OnStatistics, this, ID_VIEW_STATISTICS);
  Bind(wxEVT_MENU, &WeatherRouting::OnReport, this, ID_VIEW_REPORT);
  Bind(wxEVT_MENU, &WeatherRouting::OnPlot, this, ID_VIEW_PLOT);
  Bind(wxEVT_MENU, &WeatherRouting::OnCursorPosition, this,ID_VIEW_CURSOR_POSITION);
//  Bind(wxEVT_MENU, &WeatherRouting::OnRoutePosition, this, ID_VIEW_ROUTE_POSITION);

  //  Bind(wxEVT_MENU, &WeatherRouting::OnRoutingTable, this, ID_VIEW_ROUTING_TABLE);

  // HELP
  Bind(wxEVT_MENU, &WeatherRouting::OnInformation, this, ID_HELP_INFORMATION);
  Bind(wxEVT_MENU, &WeatherRouting::OnManual, this, ID_HELP_MANUAL);
  Bind(wxEVT_MENU, &WeatherRouting::OnAbout, this, ID_HELP_ABOUT);

  // ======================================================================
  // BUTTON BINDINGS (new button row)
  // ======================================================================

  m_btnCompute->Bind(wxEVT_BUTTON, &WeatherRouting::OnCompute, this);
  m_btnReset->Bind(wxEVT_BUTTON, &WeatherRouting::OnResetRouting, this);
  m_btnGotoRouting->Bind(wxEVT_BUTTON, &WeatherRouting::OnGotoRouting, this);

 // m_btnSaveTrack->Bind(wxEVT_BUTTON, &WeatherRouting::OnSaveAsTrack, this);
 // m_btnSaveRoute->Bind(wxEVT_BUTTON, &WeatherRouting::OnSaveAsRoute, this);
 // m_btnExportGPX->Bind(wxEVT_BUTTON, &WeatherRouting::OnExportGPX, this);
 
  // ======================================================================
  // LIST CONTROL BINDINGS
  // ======================================================================

  // POSITIONS LIST (left panel)
 // m_PositionPanel->m_lPositions->Bind(
 //     wxEVT_LEFT_DCLICK, &WeatherRouting::OnEditPositionClick, this);

//  m_PositionPanel->m_lPositions->Bind(
//      wxEVT_LIST_ITEM_SELECTED, &WeatherRouting::OnPositionSelected, this);

  // ROUTINGS LIST (right panel)
  m_panel->m_lWeatherRoutes->Bind(
      wxEVT_LEFT_DCLICK, &WeatherRouting::OnEditConfigurationClick, this);

 m_panel->m_lWeatherRoutes->Bind(
     wxEVT_LIST_COL_CLICK, &WeatherRouting::OnWeatherRouteSort, this);

//  m_panel->m_lWeatherRoutes->Bind(
//      wxEVT_LIST_ITEM_SELECTED, &WeatherRouting::OnWeatherRouteSelected, this);

}


//============================================================
// Bind all event handlers
//==============================================================

void WeatherRouting::BindEvents() {

  // ---------------------------------------------------------
  // System-Level Events
  // ---------------------------------------------------------
  // BIND OnRouteMapUpdate to EVT_ROUTEMAP_UPDATE
  //   // Route map update from RouteMapOverlay threads this is how
  // RouteMapOverlay notifies WeatherRouting of progress
  // It is a thread-safe event and can be sent from any thread
  // The event handler will be called in the main thread context, allowing safe
  // UI updates

  Bind(EVT_ROUTEMAP_UPDATE, &WeatherRouting::OnRouteMapUpdate, this);

#ifdef PLUGIN_USE_ASM
  Bind(EVT_MEMORY_ALERT_STOP, &WeatherRouting::OnMemoryAlertStop, this);
  Bind(EVT_MEMORY_AUTO_RESET, &WeatherRouting::OnMemoryAutoReset, this);
#endif

// ---------------------------------------------------------
  // Timers (modern, scheduler-free)
  // ---------------------------------------------------------

  m_tHideConfiguration.Connect(
      wxEVT_TIMER,
      wxTimerEventHandler(WeatherRouting::OnHideConfigurationTimer), nullptr,
      this);

  m_tAutoSaveXML.Connect(
      wxEVT_TIMER, wxTimerEventHandler(WeatherRouting::OnAutoSaveXMLTimer),
      nullptr, this);


  // ---------------------------------------------------------
  // UI Events
  // ---------------------------------------------------------
  if (m_colpane) {
    m_colpane->Connect(
        wxEVT_COLLAPSIBLEPANE_CHANGED,
        wxCollapsiblePaneEventHandler(WeatherRouting::OnCollPaneChanged),
        nullptr, this);
  }

  // Positions list
 // m_panel->m_lPositions->Connect(
 //     wxEVT_LEFT_DCLICK,
  //    wxMouseEventHandler(WeatherRouting::OnEditPositionClick), nullptr, this);

  // WeatherRoutes list
  m_panel->m_lWeatherRoutes->Connect(
      wxEVT_LEFT_DCLICK,
      wxMouseEventHandler(WeatherRouting::OnEditConfigurationClick), nullptr,
      this);

  m_panel->m_lWeatherRoutes->Connect(
      wxEVT_COMMAND_LIST_COL_CLICK,
      wxListEventHandler(WeatherRouting::OnWeatherRouteSort), nullptr, this);

  m_panel->m_lWeatherRoutes->Connect(
      wxEVT_COMMAND_LIST_ITEM_SELECTED,
      wxListEventHandler(WeatherRouting::OnWeatherRouteSelected), nullptr,
      this);

  m_panel->m_lWeatherRoutes->Connect(
      wxEVT_COMMAND_LIST_ITEM_DESELECTED,
      wxListEventHandler(WeatherRouting::OnWeatherRouteSelected), nullptr,
      this);

  // Buttons
  m_panel->m_bCompute->Connect(wxEVT_COMMAND_BUTTON_CLICKED,
                               wxCommandEventHandler(WeatherRouting::OnCompute),
                               nullptr, this);

  m_panel->m_bSaveAsTrack->Connect(
      wxEVT_COMMAND_BUTTON_CLICKED,
      wxCommandEventHandler(WeatherRouting::OnSaveAsTrack), nullptr, this);

  m_panel->m_bSaveAsRoute->Connect(
      wxEVT_COMMAND_BUTTON_CLICKED,
      wxCommandEventHandler(WeatherRouting::OnSaveAsRoute), nullptr, this);

  m_panel->m_bExportRoute->Connect(
      wxEVT_COMMAND_BUTTON_CLICKED,
      wxCommandEventHandler(WeatherRouting::OnExportRouteAsGPX), nullptr, this);
}


//==============================================================
// DESTRUCTOR  weatherrouting
//==============================================================

WeatherRouting::~WeatherRouting() {
  m_shuttingDown = true;
  wxLogMessage("~WeatherRouting() - BEGIN");

  // ---------------------------------------------------------
  // 1. Stop internal timers
  // ---------------------------------------------------------
  if (m_tAutoSaveXML.IsRunning()) m_tAutoSaveXML.Stop();

  // ---------------------------------------------------------
  // 2. Quiesce RoutingTablePanel early to prevent callbacks
  // ---------------------------------------------------------
  if (m_RoutingTablePanel) {
    m_RoutingTablePanel->Freeze();
    m_RoutingTablePanel->Disconnect();
  }

  // ---------------------------------------------------------
  // 3. Save settings and dialog geometry
  // ---------------------------------------------------------
  m_SettingsDialog.SaveSettings();

  wxFileConfig* pConf = GetOCPNConfigObject();
  pConf->SetPath("/PlugIns/WeatherRouting");

  wxPoint pos = GetPosition();
  pConf->Write("DialogX", pos.x);
  pConf->Write("DialogY", pos.y);
  pConf->Write("DialogWidth", m_size.x);
  pConf->Write("DialogHeight", m_size.y);

  if (m_panel && m_panel->m_splitter1)
    pConf->Write("DialogSplit", m_panel->m_splitter1->GetSashPosition());

  SaveXML(m_FileName.GetFullPath());

  // ---------------------------------------------------------
  // 4. Mark overlays finished (thread-safe)
  // ---------------------------------------------------------
  {
    wxMutexLocker lock(m_OverlayListMutex);

    for (auto* ov : m_RouteMapOverlays) {
      if (!ov) continue;

      ov->SetFinished(true);
      ov->m_Stopped = true;
    }
  }

  // ---------------------------------------------------------
  // 5. Stop overlay threads cleanly (modern Stop() replaces legacy
  // ---------------------------------------------------------
  for (auto* ov : m_RouteMapOverlays) {
    if (!ov) continue;

    if (ov->HasThread()) ov->Stop();  // joins internally, safe + modern
  }

  // ---------------------------------------------------------
  // 6. Delete WeatherRoute objects
  // ---------------------------------------------------------
  for (auto* wr : m_WeatherRoutes) delete wr;

  m_WeatherRoutes.clear();
  m_RouteMapOverlays.clear();

  // ---------------------------------------------------------
  // 7. Destroy RoutingTablePanel
  // ---------------------------------------------------------
  if (m_RoutingTablePanel) {
    wxAuiManager* mgr = ::GetFrameAuiManager();
    mgr->DetachPane(m_RoutingTablePanel);
    m_RoutingTablePanel->Destroy();
    m_RoutingTablePanel = nullptr;
  }

  wxLogMessage("~WeatherRouting() - END");
}



//==============================================================
// DESTRUCTOR  ENDING  weatherrouting
//==============================================================

//   Temoorary place for constants related to the routing table columns. These can be


//==============================================================
// RENDER   OPENCPN Render overlay drawing function
//==============================================================
// This function is called by OpenCPN to render the plugin's overlays on the
// map. it must be pure drawing code, and must not perform any computations or
// state changes. Render() must be pure drawing, not UI logic
// Positions UI is now driven by wr->Positions
// Global RouteMap::Positions is engine?internal only
// UI updates belong in :
//    PopulatePositions()
//    UpdateStates()
//    UpdateDialogs()
//    UpdateComputeState()
//This makes the rendering pipeline deterministic, side?effect?free,
// and aligned with your modern architectu


void WeatherRouting::Render(piDC& dc, PlugIn_ViewPort& vp) {
  // 1. Validate viewport
  if (!vp.bValid) return;

  // 2. Prepare OpenGL state (if using GL instead of wxDC)
  if (!dc.GetDC()) {
#ifndef __OCPN__ANDROID__
    glPushAttrib(GL_LINE_BIT | GL_ENABLE_BIT | GL_HINT_BIT);
    glEnable(GL_LINE_SMOOTH);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
#endif
    glEnable(GL_BLEND);
  }

  // 3. Determine GRIB timeline time
  wxDateTime time = m_ConfigurationDialog.m_GribTimelineTime;
  if (!time.IsValid()) time = wxDateTime::UNow();

  // 4. Update routing table highlight (UI only)
  if (m_RoutingTablePanel) m_RoutingTablePanel->UpdateTimeHighlight(time);

  // 5. Render all route overlays
  if (m_panel && m_panel->m_lWeatherRoutes) {
    wxListCtrl* list = m_panel->m_lWeatherRoutes;

    for (int i = 0; i < list->GetItemCount(); i++) {
      WeatherRoute* wr =
          reinterpret_cast<WeatherRoute*>(wxUIntToPtr(list->GetItemData(i)));

      if (wr && wr->routemapoverlay &&
          wr->routemapoverlay->m_bEndRouteVisible) {
        wr->routemapoverlay->Render(time, m_SettingsDialog, dc, vp, true);
      }
    }
  }

  // 6. Render batch configuration overlay
  m_ConfigurationBatchDialog.Render(dc, vp);

// 7. Restore OpenGL state
#ifndef __OCPN__ANDROID__
  if (!dc.GetDC()) glPopAttrib();
#endif
}


//==============================================================
// ANDROID GESTURE EVENT HANDLER
//==============================================================


#ifdef __OCPN__ANDROID__
void WeatherRouting::OnEvtPanGesture(wxQT_PanGestureEvent& event) {
  switch (event.GetState()) {
    case GestureStarted:
      m_startPos = GetPosition();
      m_startMouse = event.GetCursorPos();  // g_mouse_pos_screen;
      break;
    default: {
      wxPoint pos = event.GetCursorPos();
      int x = wxMax(0, pos.x + m_startPos.x - m_startMouse.x);
      int y = wxMax(0, pos.y + m_startPos.y - m_startMouse.y);
      int xmax = ::wxGetDisplaySize().x - GetSize().x;
      x = wxMin(x, xmax);
      int ymax =
          ::wxGetDisplaySize().y - GetSize().y;  // Some fluff at the bottom
      y = wxMin(y, ymax);

      Move(x, y);
      m_tDownTimer.Stop();
    } break;
  }
}
#endif






//==============================================================
// COMPUTE 
//=============================================================


// ============================================================================
// WeatherRouting::Start computation for selected routes
// Modern compute entry point: start computation only on selected overlays,
// using the per-overlay thread lifecycle. No scheduler, no waiting lists.
// ============================================================================
// Start(ov) is the modern entry point for starting computation on a single
// overlay. It is located in RouteMapOverlay and is called by ComputeSelectedRoute
// for each selected overlay. It is also called by the RouteMapOverlay context menu
// for starting/stopping individual overlays. It ensures that the overlay's thread
// is properly managed according to the new lifecycle rules (no scheduler, no
// waiting lists). It is the authoritative way to start computation on an overlay.
// ComputeSelectedRoute is the batch entry point for starting computation on
// all selected overlays. It calls Start(ov) for each selected overlay, and
// also performs UI updates and invariant checks after starting the threads.
// This ensures that the UI state is updated and lifecycle invariants are maintained.
// Call ov->Start() to start computation on // an individual overlay


// ============================================================================
// WeatherRouting::ComputeSelectedRoute
// Modern compute entry point: start computation only on selected overlays,
// using the per-overlay thread lifecycle. No scheduler, no waiting lists.
// ============================================================================
void WeatherRouting::ComputeSelectedRoute() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("WeatherRouting::ComputeSelectedRoute - BEGIN");

  // ---------------------------------------------------------------------
  // 1. Collect selected overlays
  // ---------------------------------------------------------------------
  std::vector<RouteMapOverlay*> overlays = GetSelectedOverlays();

  if (overlays.empty()) {
    wxMessageBox(_("No routes selected."), _("Weather Routing"),
                 wxOK | wxICON_INFORMATION, this);
    wxLogMessage("ComputeSelectedRoute: no selection");
    return;
  }

  // ---------------------------------------------------------------------
  // 2. Start computation for each selected overlay
  // ---------------------------------------------------------------------
  for (auto* ov : overlays) {
    if (!ov) continue;

    WeatherRoute* wr = ov->m_weatherRoute;
    if (!wr) continue;

    // Skip if already running
    if (ov->Running()) {
      wxLogMessage("ComputeSelectedRoute: overlay=%p already running", ov);
      continue;
    }

    wxLogMessage("ComputeSelectedRoute: starting overlay=%p", ov);

    // Ensure no stale worker thread exists
    ov->Stop();
    ov->DeleteThread();

    // Reset compute state
    wr->ClearComputedFields();
    ov->ResetFinished();
    ov->MarkDirty();

    // Launch computation thread
    wxString error;
    ov->Start(error);
  }

  // ---------------------------------------------------------------------
  // 3. Refresh UI state
  // ---------------------------------------------------------------------
  UpdateStates();

  // ---------------------------------------------------------------------
  // 4. Assert lifecycle invariants
  // ---------------------------------------------------------------------
  AssertThreadLifecycleInvariants();

  wxLogMessage("WeatherRouting::ComputeSelectedRoute - END");
}

// ============================================================================
// WeatherRouting::ComputeAllRoutes
// Modern compute entry point: start computation on all overlays.
// No scheduler, no waiting lists, no running lists.
// ============================================================================

 // REMOVED ComputeAllRoutes is the batch entry point for starting computation on
// all


// ============================================================================
//  SELECTION HELPERS
// ============================================================================
// WeatherRouting::GetSelectedOverlays
// Modern selection helper: returns the RouteMapOverlay* objects corresponding
// to the currently selected rows in the WeatherRoutes list control.
//
// Notes:
//  ? This function is *pure* ? it does not modify state, UI, or threads.
//  ? It is the authoritative way to determine which overlays are selected.
//  ? It replaces all legacy selection logic (no scheduler lists, no indices).
// ============================================================================
// MODERN

std::vector<RouteMapOverlay*> WeatherRouting::GetSelectedOverlays() const {
  std::vector<RouteMapOverlay*> result;

  // 1. Validate UI context
  if (!m_panel || !m_panel->m_lWeatherRoutes) return result;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  // 2. Enumerate selected rows
  long item = -1;
  for (;;) {
    item = list->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item < 0) break;

    // 3. Retrieve the WeatherRoute*
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(list->GetItemData(item));
    if (!wr) continue;

    RouteMapOverlay* rmo = wr->routemapoverlay;
    if (!rmo) continue;

    // 4. Append overlay
    result.push_back(rmo);
  }

  return result;
}


//--------------------------------------------------------------------
// WeatherRouting::GetSelectedRoute
//---------------------------------------------------------------------
// returns the WeatherRoute* corresponding to the first selected row in the
// WeatherRoutes list control, or nullptr if no selection. This is a helper for
// single-route operations (e.g., Edit Configuration) where we only care about
// the first selected route. It is a pure function that does not modify state,
// UI, or threads. It is the authoritative way to get the selected WeatherRoute*
// for single-route operations. It replaces legacy logic that might have been
// based on list indices or scheduler state.

// MODERN
WeatherRoute* WeatherRouting::GetSelectedRoute()
{
  // Ensure UI is valid
  if (!m_panel || !m_panel->m_lWeatherRoutes) return nullptr;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  // Get first selected row
  long item = list->GetNextItem(-1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
  if (item < 0) return nullptr;

  // Retrieve WeatherRoute* stored in row data
  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(list->GetItemData(item));

  return wr;
}


// -----------------------------------------------------------------------------
// OnWeatherRouteSelected  - event handler for when the user selects or deselects
// ----------------------------------------------------------------------------
// a route in the WeatherRoutes list control. It performs the following actions:
// 1. Collects all selected WeatherRoute objects (not just the clicked row)
// 2. Updates the Configuration dialog with the selected routes (multi-route
//   aware)
// 3. Updates the Statistics, Report, and Plot dialogs to reflect the selected
//  routes
// 4. Updates the Routing Table panel to show the first selected route (if any)
// 5. Updates the compute button, stop button, progress bar, and status text
//   based on the selected routes' states
// 6. Refreshes the parent window to update map highlights
// This event handler is designed to be robust and responsive, providing
// immediate
// feedback to the user when they select or deselect routes in the list control.
// It ensures that the UI state is consistent with the current selection and
// that
// all relevant dialogs and panels are updated accordingly.
// Note: This handler is called for both selection and deselection events, so it
// must handle the case where no routes are selected (e.g., when the user
// deselects all routes) and update the UI state appropriately (e.g., hide
// the Configuration dialog).
// Note: The handler uses the GetSelectedOverlays() helper function to determine
// which routes are currently selected, ensuring that it works correctly even
// if the user selects multiple routes or changes the selection in a non-linear
// way (e.g., using Ctrl+click or Shift+click).
// Note: The handler updates the Routing Table panel to show the first selected
// route, but it could be extended to show multiple routes or provide a way for
// the user to choose which route to display if multiple are selected.
// Note: The handler calls UpdateComputeState() to ensure that the compute and
// stop
// buttons are enabled or disabled based on the states of the selected routes,
// providing immediate feedback to the user about what actions are available for
// the current selection.
// Note: The handler refreshes the parent window at the end to ensure that any
// map highlights or other visual indicators of the selected routes are updated
// immediately, providing a responsive and interactive user experience.

// Modern

void WeatherRouting::OnWeatherRouteSelected(wxListEvent& event) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  // ---------------------------------------------------------------------
  // 1. Collect ALL selected WeatherRoutes (not just the clicked row)
  // ---------------------------------------------------------------------
  std::list<WeatherRoute*> selectedRoutes;

  long item = -1;
  while (true) {
    item = list->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr =
        reinterpret_cast<WeatherRoute*>(wxUIntToPtr(list->GetItemData(item)));

    if (wr) selectedRoutes.push_back(wr);
  }

  // ---------------------------------------------------------------------
  // 2. Update Configuration dialog (multi?route aware)
  // ---------------------------------------------------------------------
  if (selectedRoutes.empty()) {
    m_tHideConfiguration.Start(25, true);
  } else {
    m_tHideConfiguration.Stop();

    std::list<RouteMapConfiguration> configs;
    for (auto* wr : selectedRoutes) {
      if (wr->routemapoverlay)
        configs.push_back(wr->routemapoverlay->GetConfiguration());
    }

    m_ConfigurationDialog.SetConfigurations(configs);
  }

  // ---------------------------------------------------------------------
  // 3. Update Statistics, Report, Plot dialogs
  // ---------------------------------------------------------------------
  UpdateDialogs();

  // ---------------------------------------------------------------------
  // 4. Update Routing Table (first selected route only)
  // ---------------------------------------------------------------------
  if (m_RoutingTablePanel) {
    wxAuiManager* mgr = ::GetFrameAuiManager();
    wxAuiPaneInfo& pane = mgr->GetPane(m_RoutingTablePanel);

    if (pane.IsOk() && pane.IsShown() && !selectedRoutes.empty()) {
      WeatherRoute* wr = selectedRoutes.front();
      auto* panel = static_cast<RoutingTablePanel*>(m_RoutingTablePanel);

      panel->m_RouteMap = wr->routemapoverlay;
      panel->PopulateTable();
    }
  }

  // ---------------------------------------------------------------------
  // 5. Update compute button, stop button, progress bar, status text
  // ---------------------------------------------------------------------
  UpdateComputeState();

  // ---------------------------------------------------------------------
  // 6. Refresh parent window to update map highlights
  // ---------------------------------------------------------------------
  if (GetParent()) GetParent()->Refresh();
}



// --------------------------------------------------------------------
// WeatherRouting::GetRouteRow
// --------------------------------------------------------------------
// MODERN helper: returns the row index of the given WeatherRoute*

long WeatherRouting::GetRouteRow(WeatherRoute* wr) const {
  if (!wr || !m_panel || !m_panel->m_lWeatherRoutes) return -1;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  long count = list->GetItemCount();
  for (long row = 0; row < count; row++) {
    WeatherRoute* rowWR =
        reinterpret_cast<WeatherRoute*>(list->GetItemData(row));
    if (rowWR == wr) return row;
  }
  return -1;
}


void WeatherRouting::OnStopRouting(wxCommandEvent& event) { StopSelected(); }


void WeatherRouting::OnStopAllRoutings(wxCommandEvent& event) { StopAll(); }


void WeatherRouting::OnGotoRouting(wxCommandEvent& event) {
  auto overlays = GetSelectedOverlays();
  if (overlays.empty()) return;

  RouteMapOverlay* rmo = overlays.front();
  if (!rmo || !rmo->m_weatherRoute) return;

WeatherRoute* wr = rmo->m_weatherRoute;
  if (!wr || wr->routepoints.empty()) return;

  const auto& p = wr->routepoints.front();

  PlugIn_Position_Fix_Ex fix;
  fix.Lat = p.lat;
  fix.Lon = p.lon;
  fix.Cog = NAN;
  fix.Sog = NAN;
  fix.Var = NAN;
  fix.Hdt = NAN;
  fix.Hdm = NAN;
//  fix.Hdg = NAN;    Not in api118
  fix.FixTime = wxDateTime::Now().GetTicks();
//  JumpToPosition(fix);  Not  in api118
  JumpToPosition(fix.Lat, fix.Lon, 1.0);
}


void WeatherRouting::SaveColumnWidth(int col, int width) {
  m_ColumnWidths[col] = width;
  m_tAutoSaveXML.Start(5000, true);
}

int WeatherRouting::LoadColumnWidth(int col) const {
  auto it = m_ColumnWidths.find(col);
  return (it != m_ColumnWidths.end()) ? it->second : -1;
}


//==============================================================
// END OF NEW  STUFF
//=============================================================



//============================================================
//  SYSTEM LEVEL EVENT HANDLERS (RouteMapUpdate, Memory Alerts)
//============================================================
// OnPostionKeyDown:
//     Handle key events for positions list
//     Currently only handles Delete key to delete position
//     Other keys are passed to default handler
// OnLeftDown
//    On left mouse button down event handler for both weather routing lists
// OnLeftUp
//     On left mouse button up event handler for both weather routing lists
// OnDownTimer
//    Timer event handler for "press and hold" context menu popup
// OnMemoryAlertStop
//   Handler for memory alert stop event from ASM
// OnMemoryAutoReset
//  Handler for memory auto reset event from ASM
// OnLeftDClick
//    On left double click event handler for positions list
// OnRightUp
//   On right mouse button up event handler for both weather routing lists
//-------------------------------------------------------------

/*
void WeatherRouting::OnPositionKeyDown(wxListEvent& event) {
  // Ensure the new UI panel and list control exist
  if (!m_PositionPanel || !m_PositionPanel->m_lPositions) {
    event.Skip();
    return;
  }
  switch (event.GetKeyCode()) {
    case WXK_DELETE: {
      wxCommandEvent cmd;
      OnDeletePosition(cmd);
      break;
    }
    default:
      event.Skip();
  }
}
*/


// Shared mouse event handler for both weather routing lists (positions and
// routes) Handles "press and hold" timer for context menu popup
// Allow default selection behavior
void WeatherRouting::OnLeftDown(wxMouseEvent& event) {
  m_tDownTimer.Start(1200, true);
  m_downPos = event.GetPosition();
  event.Skip(); 
}

// Shared mouse event handler for both weather routing lists
// Stops the "press and hold" timer for context menu

void WeatherRouting::OnLeftUp(wxMouseEvent& event) { m_tDownTimer.Stop(); }


void WeatherRouting::OnDownTimer(wxTimerEvent&) {
  // Ensure the routing panel exists
  if (!m_panel) return;

  wxListCtrl* routes = m_panel->m_lWeatherRoutes;

  if (!routes) return;

  int flags = wxLIST_HITTEST_NOWHERE | wxLIST_HITTEST_ONITEM;

  // ---------------------------------------------------------
  // 1. Did the long?press occur on the ROUTINGS list?
  // ---------------------------------------------------------
  if (routes->HitTest(m_downPos, flags) != wxNOT_FOUND) {
    routes->PopupMenu(m_mContextMenu, m_downPos);
    return;
  }

  // ---------------------------------------------------------
  // Legacy Position?panel code removed.
  // The modern architecture has no m_PositionPanel or m_lPositions.
  // ---------------------------------------------------------
  // wxListCtrl* positions = m_PositionPanel->m_lPositions;
  // if (positions && positions->HitTest(m_downPos, flags) != wxNOT_FOUND) {
  //     positions->PopupMenu(m_mContextMenuPositions, m_downPos);
  //     return;
  // }
}


void WeatherRouting::OnRightUp(wxMouseEvent& event) {
  wxObject* obj = event.GetEventObject();

  // Right?click on ROUTINGS list
  if (m_panel && obj == m_panel->m_lWeatherRoutes) {
    m_panel->m_lWeatherRoutes->PopupMenu(m_mContextMenu, event.GetPosition());
    return;
  }

  // ---------------------------------------------------------------------
  // Legacy Position-panel code removed.
  // The modern architecture has no m_PositionPanel or m_lPositions.
  // ---------------------------------------------------------------------
  // if (m_PositionPanel && obj == m_PositionPanel->m_lPositions) {
  //     m_PositionPanel->m_lPositions->PopupMenu(m_mContextMenuPositions,
  //                                              event.GetPosition());
  //     return;
  // }

  // Otherwise let wxWidgets handle it
  event.Skip();
}



void WeatherRouting::OnMemoryAlertStop(wxCommandEvent& event) {
  wxLogMessage("WeatherRouting::OnMemoryAlertStop - BEGIN");

  // Phase 1: signal all workers to stop
  StopAll();

  // Phase 2: wait for all threads to exit
  WaitForAllRoutesToStop();

  // Phase 3: update UI to reflect stopped state
  RefreshUI();

  // Show the AlertStop dialog
  MemoryStatusDialog dlg(this, MemoryDialogMode::AlertStop);
  int r = dlg.ShowModal();

  // If user pressed Reset, perform a full reset
  if (r == wxID_RESET) {
    ResetAll();  // <-- correct call
  }

  wxLogMessage("WeatherRouting::OnMemoryAlertStop - END");
}


void WeatherRouting::OnMemoryAutoReset(wxCommandEvent& event) {
  wxLogMessage("WeatherRouting::OnMemoryAutoReset - BEGIN");

  // Phase 1: signal all workers to stop
  StopAll();

  // Phase 2: wait for all threads to exit
  WaitForAllRoutesToStop();

  // Phase 3: full reset of all overlays
  ResetAll();

  // Show informational dialog
  MemoryStatusDialog dlg(this, MemoryDialogMode::AutoReset);
  dlg.ShowModal();

  wxLogMessage("WeatherRouting::OnMemoryAutoReset - END");
}



/* ============================================================
   UTILITY FUNCTIONS
   ============================================================
   Stateless helpers used by routing and UI layers.
   These do not depend on WeatherRoute instance state.
   ============================================================ */

// Cursor position dialog message
//    Quick helper to set message in cursor position dialog
// Route position dialog message
//    Quick helper to set message in route position dialog
// CursorPRouteChanged
//    Callback when cursor route changes to update plot dialog
// UpdateRoutePositionDialog
//    Update route position dialog based on cursor position
// UpdateCursorPositionDialog



static void CursorPositionDialogMessage(CursorPositionDialog& dlg,
                                        wxString msg) {
  dlg.m_stPosition->SetLabel(msg);
  dlg.m_stPosition->Fit();
  dlg.m_stTime->SetLabel("");
  dlg.m_stPolar->SetLabel("");
  dlg.m_stSailChanges->SetLabel("");
  dlg.m_stTacks->SetLabel("");
  dlg.m_stJibes->SetLabel("");
  dlg.m_stSailPlanChanges->SetLabel("");
  dlg.m_stWeatherData->SetLabel("");
  dlg.Fit();
}

static void RoutePositionDialogMessage(RoutePositionDialog& dlg, wxString msg) {
  dlg.m_stPosition->SetLabel(msg);
  dlg.m_stPosition->Fit();
  dlg.m_stTime->SetLabel("");
  dlg.m_stPolar->SetLabel("");
  dlg.m_stSailChanges->SetLabel("");
  dlg.m_stTacks->SetLabel("");
  dlg.m_stJibes->SetLabel("");
  dlg.m_stSailPlanChanges->SetLabel("");
  dlg.m_stWeatherData->SetLabel("");
  dlg.Fit();
}


// -----------------------------------------------------------------------------
// GetAllOverlays()
// -----------------------------------------------------------------------------
// Returns a vector containing *every* RouteMapOverlay currently managed by the
// WeatherRouting plugin.
//
// ARCHITECTURAL ROLE
// -------------------
// This method provides a unified, authoritative way to enumerate all overlays
// regardless of selection state. It complements GetSelectedOverlays() and
// supports operations that must consider the entire overlay set:
//
//   ? Global reset / StopAll()
//   ? Batch configuration and batch compute
//   ? Diagnostics, logging, and memory monitoring
//   ? Rendering passes that need to inspect overlay state
//   ? Future multi-route editing workflows
//
// SOURCE OF TRUTH
// ---------------
// Overlays are stored in m_RouteMapOverlays, a vector owned by WeatherRouting.
// Access to this container is protected by m_OverlayListMutex to ensure
// thread-safe iteration, since overlays may be created, destroyed, or modified
// by worker threads.
//
// RETURN TYPE
// -----------
// A std::vector<RouteMapOverlay*> is returned because:
//   ? It preserves stable iteration order
//   ? It is easy to pass to algorithms and range-based loops
//   ? It avoids exposing internal container types
//
// SAFETY NOTES
// ------------
//  ? The mutex is locked only long enough to copy pointers out of the master
//    list, minimizing contention with worker threads.
//  ? Null pointers are not expected but are ignored defensively.
// -----------------------------------------------------------------------------

std::vector<RouteMapOverlay*> WeatherRouting::GetAllOverlays() {
  if (m_shuttingDown)
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
      return {};

  std::vector<RouteMapOverlay*> result;

  // Lock the master overlay list for safe iteration
  wxMutexLocker lock(m_OverlayListMutex);

  // Copy all overlay pointers into the result vector
  for (RouteMapOverlay* rmo : m_RouteMapOverlays) {
    if (rmo) result.push_back(rmo);
  }

  return result;
}


// -----------------------------------------------------------------------------
// GetSelectedOverlays()
// -----------------------------------------------------------------------------
// Returns a vector of all RouteMapOverlay objects currently selected in the
// Weather Routing list control.
//
// ARCHITECTURAL ROLE
// -------------------
// This method is the modern replacement for the old CurrentRouteMaps() API.
// The list control (m_lWeatherRoutes) is now the *authoritative source* of
// route selection state. All multi-route operations?cursor updates, batch
// configuration, multi-reset, and future multi-route editing?should use this
// method.
//
// WHY A VECTOR?
// -------------
//  ? Stable iteration order (matches UI order)
//  ? Easy to pass to algorithms and range-based loops
//  ? Avoids the overhead and ambiguity of std::list
//
// SELECTION MODEL
// ---------------
// The list control supports multi-selection. Each selected row stores a
// RouteMapOverlay* in its item data. This method extracts those pointers and
// returns them as a clean, ready-to-use container.
//
// FUTURE EXTENSIONS
// -----------------
//  ? Multi-route editing in ConfigurationDialog
//  ? Multi-route batch generation
//  ? Multi-route Reset() and Compute()
//  ? Selection-based rendering optimizations
//
// SAFETY NOTES
// ------------
//  ? If the panel or list control is missing (e.g., during early construction
//    or teardown), the method returns an empty vector.
//  ? Null item-data pointers are ignored defensively.
// -----------------------------------------------------------------------------




void WeatherRouting::CursorRouteChanged() {
  if (m_PlotDialog.IsShown() && m_PlotDialog.m_rbCursorRoute->GetValue())
    m_PlotDialog.SetRouteMapOverlay(FirstCurrentRouteMap());
}


void WeatherRouting::UpdateCursorPositionDialog() {
  CursorPositionDialog& dlg = m_CursorPositionDialog;

  // Dialog not yet visible ? nothing to do
  if (!dlg.IsShown()) return;

  // Panel or list control not ready yet
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  // No routes yet
  if (m_RouteMapOverlays.empty()) return;

  // Determine which WeatherRoute is selected
  long item = m_panel->m_lWeatherRoutes->GetNextItem(-1, wxLIST_NEXT_ALL,
                                                     wxLIST_STATE_SELECTED);

  if (item < 0) {
    CursorPositionDialogMessage(dlg, _("Select exactly 1 configuration"));
    return;
  }

  // Retrieve the WeatherRoute and its overlay
  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
      wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

  RouteMapOverlay* rmo = wr ? wr->routemapoverlay : nullptr;

  if (!rmo) {
    CursorPositionDialogMessage(dlg, _("No route map overlay available"));
    return;
  }

  const Position* p = rmo->GetLastCursorPosition();
  if (!p) {
    CursorPositionDialogMessage(dlg, _("Cursor outside computed route map"));
    return;
  }
  wxDateTime display_time = rmo->GetLastCursorTime();

  if (m_SettingsDialog.m_cbUseLocalTime->GetValue())
    display_time = display_time.FromUTC();

  dlg.m_stTime->SetLabel(display_time.Format("%x %H:%M"));

  RouteMapConfiguration configuration = rmo->GetConfiguration();
  auto latStr = toSDMM_PlugIn(NEflag::LAT, p->lat, Precision::HI);
  auto lonStr = toSDMM_PlugIn(NEflag::LON, p->lon, Precision::HI);
  dlg.m_stPosition->SetLabel(latStr + " " + lonStr);

  if (p->polar == -1)
    dlg.m_stPolar->SetLabel(wxEmptyString);
  else {
    wxFileName fn = configuration.boat.Polars[p->polar].FileName;
    dlg.m_stPolar->SetLabel(fn.GetFullName());
  }

  dlg.m_stSailChanges->SetLabel(wxString::Format("%d", p->SailChanges()));

  dlg.m_stTacks->SetLabel(wxString::Format("%d", p->tacks));
  dlg.m_stJibes->SetLabel(wxString::Format("%d", p->jibes));
  dlg.m_stSailPlanChanges->SetLabel(
      wxString::Format("%d", p->sail_plan_changes));

  wxString weatherdata;
  wxString grib = _("Grib") + " ";
  wxString climatology = _("Climatology") + " ";
  wxString data_deficient = _("Data Deficient") + " ";
  wxString wind = _("Wind") + " ";
  wxString current = _("Current") + " ";

  if (p->data_mask & DataMask::GRIB_WIND) weatherdata += grib + wind;
  if (p->data_mask & DataMask::CLIMATOLOGY_WIND)
    weatherdata += climatology + wind;
  if (p->data_mask & DataMask::DATA_DEFICIENT_WIND)
    weatherdata += data_deficient + wind;
  if (p->data_mask & DataMask::GRIB_CURRENT) weatherdata += grib + current;
  if (p->data_mask & DataMask::CLIMATOLOGY_CURRENT)
    weatherdata += climatology + current;
  if (p->data_mask & DataMask::DATA_DEFICIENT_CURRENT)
    weatherdata += data_deficient + current;

  dlg.m_stWeatherData->SetLabel(weatherdata);
  dlg.Fit();
}


// -----------------------------------------------------------------------------
  /* New method to display information on the weather route
   * (like starttime, finishtime, time, position, wind, speed, etc.)
   * based on cursor position of the user.
   * This is complementary with the plot chart.    */
// -----------------------------------------------------------------------------
void WeatherRouting::UpdateRoutePositionDialog(RoutePositionDialog & dlg) {
    // ---------------------------------------------------------------------
    // 1. Determine the first selected route map overlay
    //    The list control is the authoritative source of selection.
    // ---------------------------------------------------------------------
    RouteMapOverlay* rmo = FirstCurrentRouteMap();
    if (!rmo) {
      RoutePositionDialogMessage(dlg, _("No route selected"));
      return;
    }
    RouteMapConfiguration configuration = rmo->GetConfiguration();

    // ---------------------------------------------------------------------
    // 2. Determine the closest computed route point to the cursor
    //    getClosestRoutePositionFromCursor() fills PlotData with the
    //    interpolated or exact point along the route.
    // ---------------------------------------------------------------------
    PlotData data;
    Position* closestPosition = rmo->getClosestRoutePositionFromCursor(
        m_weather_routing_pi.m_cursor_lat, m_weather_routing_pi.m_cursor_lon,
        data);

    // Store the position for display in the dialog
    m_positionOnRoute = closestPosition;

    // If no discrete Position* exists but PlotData is valid,
    // fall back to a synthetic saved position
    if (!closestPosition && data.time.IsValid()) {
      m_positionOnRoute = &m_savedPosition;
      m_savedPosition = data;
    }

    // If still nothing, the cursor is outside the computed route map
    if (!m_positionOnRoute) {
      RoutePositionDialogMessage(dlg, _("Cursor outside computed route map"));
      return;
    }

    // ---------------------------------------------------------------------
    // 3. Trip time (start ? cursor)
    // ---------------------------------------------------------------------
    wxDateTime startTime = configuration.StartTime;
    wxDateTime cursorTime = data.time;

    // Convert to local time if requested
    if (m_SettingsDialog.m_cbUseLocalTime->GetValue()) {
      startTime = startTime.FromUTC();
      cursorTime = data.time.FromUTC();
    }

    // Display elapsed time
    wxString time = calculateTimeDelta(startTime, cursorTime);
    dlg.m_stTime->SetLabel(time);

    // ---------------------------------------------------------------------
    // 4. Position (lat/lon)
    // ---------------------------------------------------------------------
    auto latStr = toSDMM_PlugIn(NEflag::LAT, data.lat, Precision::HI);
    auto lonStr = toSDMM_PlugIn(NEflag::LON, data.lon, Precision::HI);
    dlg.m_stPosition->SetLabel(latStr + " " + lonStr);

    // ---------------------------------------------------------------------
    // 5. Polar file used at this point
    // ---------------------------------------------------------------------
    if (data.polar == -1) {
      dlg.m_stPolar->SetLabel(wxEmptyString);
    } else {
      wxFileName fn = configuration.boat.Polars[data.polar].FileName;
      dlg.m_stPolar->SetLabel(fn.GetFullName());
    }

    // ---------------------------------------------------------------------
    // 6. Maneuvers: tacks & jibes
    // ---------------------------------------------------------------------
    dlg.m_stTacks->SetLabel(wxString::Format("%d", data.tacks));
    dlg.m_stJibes->SetLabel(wxString::Format("%d", data.jibes));

    // ---------------------------------------------------------------------
    // 7. Boat speed (SOW/SOG)
    // ---------------------------------------------------------------------
    if (std::abs(data.stw - data.sog) > 0.1) {
      dlg.m_stBoatSpeed->SetLabel(wxString::Format(
          "%.1f knts (SOW), %.1f knts (SOG)", data.stw, data.sog));
    } else {
      dlg.m_stBoatSpeed->SetLabel(wxString::Format("%.1f knts", data.stw));
    }

    // ---------------------------------------------------------------------
    // 8. Boat course (COW/COG)
    // ---------------------------------------------------------------------
    if (std::abs(data.ctw - data.cog) >= 5) {
      dlg.m_stBoatCourse->SetLabel(wxString::Format(
          "%.0f T (COW), %.0f T (COG)", positive_degrees(data.ctw),
          positive_degrees(data.cog)));
    } else {
      dlg.m_stBoatCourse->SetLabel(
          wxString::Format("%.0f T", positive_degrees(data.ctw)));
    }

    // ---------------------------------------------------------------------
    // 9. True wind speed
    // ---------------------------------------------------------------------
    dlg.m_stTWS->SetLabel(wxString::Format("%.0f knts", data.twsOverWater));

    // ---------------------------------------------------------------------
    // 10. True wind angle (port/starboard)
    // ---------------------------------------------------------------------
    double windDirection = heading_resolve(data.ctw - data.twdOverWater);
    wxString windDirectionLabel =
        windDirection <= 0
            ? wxString::Format("%.0f starboard", fabs(windDirection))
            : wxString::Format("%.0f port", fabs(windDirection));
    dlg.m_stTWA->SetLabel(windDirectionLabel);

    // ---------------------------------------------------------------------
    // 11. Apparent wind speed
    // ---------------------------------------------------------------------
    float apparentWindSpeed =
        Polar::VelocityApparentWind(data.stw, windDirection, data.twsOverWater);
    dlg.m_stAWS->SetLabel(wxString::Format("%.0f knts", apparentWindSpeed));

    // ---------------------------------------------------------------------
    // 12. Apparent wind angle (port/starboard)
    // ---------------------------------------------------------------------
    float apparentWindDirection = Polar::DirectionApparentWind(
        apparentWindSpeed, data.stw, windDirection, data.twsOverWater);

    wxString apparentWindDirectionLabel =
        apparentWindDirection <= 0
            ? wxString::Format("%.0f starboard", fabs(apparentWindDirection))
            : wxString::Format("%.0f port", fabs(apparentWindDirection));
    dlg.m_stAWA->SetLabel(apparentWindDirectionLabel);

    // ---------------------------------------------------------------------
    // 13. Waves & wind gusts
    // ---------------------------------------------------------------------
    dlg.m_stWaves->SetLabel(wxString::Format("%.0f m", data.WVHT));
    dlg.m_stWindGust->SetLabel(wxString::Format("%.0f knts", data.VW_GUST));

    // ---------------------------------------------------------------------
    // 14. Climatology / GRIB data mask summary
    // ---------------------------------------------------------------------
    wxString weatherdata;
    wxString grib = _("Grib") + " ";
    wxString climatology = _("Climatology") + " ";
    wxString data_deficient = _("Data Deficient") + " ";
    wxString wind = _("Wind") + " ";
    wxString current = _("Current") + " ";

    if (closestPosition) {
      dlg.m_stSailChanges->SetLabel(
          wxString::Format("%d", closestPosition->SailChanges()));

      if (closestPosition->data_mask & DataMask::GRIB_WIND)
        weatherdata += grib + wind;
      if (closestPosition->data_mask & DataMask::CLIMATOLOGY_WIND)
        weatherdata += climatology + wind;
      if (closestPosition->data_mask & DataMask::DATA_DEFICIENT_WIND)
        weatherdata += data_deficient + wind;

      if (closestPosition->data_mask & DataMask::GRIB_CURRENT)
        weatherdata += grib + current;
      if (closestPosition->data_mask & DataMask::CLIMATOLOGY_CURRENT)
        weatherdata += climatology + current;
      if (closestPosition->data_mask & DataMask::DATA_DEFICIENT_CURRENT)
        weatherdata += data_deficient + current;

      dlg.m_stWeatherData->SetLabel(weatherdata);
    }

    // ---------------------------------------------------------------------
    // 15. Fit dialog to updated content
    // ---------------------------------------------------------------------
    dlg.Fit();
  }



// -----------------------------------------------------------------------------
   // This is the parameterless version that uses the member dialog instance
  // It can be called from anywhere in the code without needing to pass the
  // dialog reference
  // -----------------------------------------------------------------------------
  void WeatherRouting::UpdateRoutePositionDialog() {
    // Dialog not yet visible ? nothing to do
    if (!m_RoutePositionDialog.IsShown()) return;

    // Panel or list control not ready yet ? bail out
    if (!m_panel || !m_panel->m_lWeatherRoutes) return;

    // No overlays yet ? nothing meaningful to show
    if (m_RouteMapOverlays.empty()) return;

    UpdateRoutePositionDialog(m_RoutePositionDialog);
  }



// clean, compact way to bail out of a function when something fail
// Store the error code.Jump to a cleanup label at the bottom of the function.
// This makes the macro behave like a single statement, so you can safely write:
// if(!OpenXML()) FAIL(1);     without breaking the if block.
// plugin has several functions that:open files, parse XML,
// allocate objects, need cleanup on failure

#define FAIL(X)  \
  do {           \
    error = X;   \
    goto failed; \
  } while (0)


/*********************************************************/
/*   3. Invariants Violation  Guardrails                 */
/*********************************************************/

void WeatherRouting::AssertAllInvariants() {
  AssertThreadLifecycleInvariants();
}


void WeatherRouting::AssertThreadLifecycleInvariants() {
  for (auto* ov : m_RouteMapOverlays) {
    if (!ov) continue;

    if (ov->HasThread()) {
      wxASSERT_MSG(ov->m_Thread != nullptr,
                   "Overlay reports HasThread() but m_Thread is null");
    }

    if (ov->Running()) {
      wxASSERT_MSG(ov->HasThread(),
                   "Overlay reports Running() but HasThread() is false");
    }

    if (ov->Finished()) {
      wxASSERT_MSG(!ov->HasThread(),
                   "Overlay reports Finished() but thread still exists");
    }

    if (ov->m_Stopped) {
      wxASSERT_MSG(!ov->HasThread(),
                   "Overlay reports m_Stopped but thread still exists");
    }
  }
}


/*********************************************************/
/*   3. Initialization Helper                              */
/*********************************************************/

//   Event bindings
//  NOTE: Heavy lifting initialization is in Initialize()
//   to keep constructor clean
//  This method is called by Initialize() after
//    the plugin environment is fully ready for use.
//  This funcion starts the compute timer if there is work to do.
//   Alternatively, StartCompute() can be called
//  from other places when new work is added.
//*********************************************************/



/******************************************************************/
/*  4. Top?Level Thread and UI Syncrhonization and Event Handlers */
/******************************************************************/

//-----------------------------------------------------------------
//   4.1 EVT_ROUTEMAP_UPDATE Handler(UI Choke Point)
//-----------------------------------------------------------------
// This is the single choke point for all UI updates.
// All worker-thread completions funnel through this event.
// Ensures UpdateStates(), UpdateDialogs(), and UpdateComputeState()
// run on the main thread in a race-free, deterministic order.
// NOTE: This event is posted by worker threads when they complete
// their computations. All UI updates MUST occur here!!!
// Implements the "UI Update" step in the worker thread workflow diagram.
// So that all UI updates are centralized, consistent, and thread-safe.
// Stops doing global Update() calls on the list control, and instead updates
// only the specific row(s) that changed, based on the RouteMapOverlay* passed
// in the event payload. Also triggers updates to dependent dialogs and buttons,
//-----------------------------------------------------------------

void WeatherRouting::OnRouteMapUpdate(wxThreadEvent& event) {
  wxLogMessage("WeatherRouting::OnRouteMapUpdate - BEGIN");

  // Identify which overlay triggered the event
  RouteMapOverlay* ov = event.GetPayload<RouteMapOverlay*>();
  if (!ov) {
    wxLogMessage("WeatherRouting::OnRouteMapUpdate - no payload");
    return;
  }

  // Update only this overlay?s row in the list control
  UpdateRouteMap(ov);

  // Update dependent dialogs (statistics, plot, report)
  UpdateDialogs();

  // Update compute/stop buttons and progress
  UpdateComputeState();

  // Trigger chart redraw
  if (GetParent()) GetParent()->Refresh();

  wxLogMessage("WeatherRouting::OnRouteMapUpdate - END");
}


//-----------------------------------------------------------------
// Core UI Update Methods
//-----------------------------------------------------------------
// UpdateStates
//   Walks all WeatherRoute objects, checks their associated
//   RouteMapOverlay state, updates WeatherRoute fields,
//   and refreshes the corresponding wxListCtrl row if needed.
// UpdateDialogs
//   Updates all open dialogs (Statistics, Report, Plot)
//   with the current RouteMapOverlay data.
// UpdateComputeState
//   Updates the Compute button, Stop button, progress bar,
//   and status text based on the current state of all
//   RouteMapOverlay objects.


void WeatherRouting::UpdateStates() {
  if (m_shuttingDown) return;

  int index = 0;

  for (auto* wr : m_WeatherRoutes) {
    RouteMapOverlay* ov = wr->routemapoverlay;

    int newState = 0;  // numeric lifecycle state
    wxString detail;   // detailed diagnostic message
    bool changed = false;

    if (!ov) {
      newState = 0;  // Not Computed
      detail = _("No overlay");
    } else if (!ov->Valid()) {
      newState = 4;  // Error
      detail = _("Invalid Start/End");

      wxString err = ov->GetError();
      wxString werr = ov->GetWeatherForecastError();
      if (!err.IsEmpty())
        detail += ": " + err;
      else if (!werr.IsEmpty())
        detail += ": " + werr;
    } else if (ov->HasThread()) {
      newState = 2;  // Computing
      detail = _("Computing...");
    } else if (ov->m_Stopped) {
      newState = 4;  // Error
      detail = _("Stopped");
    } else if (ov->Finished()) {
      if (ov->ReachedDestination()) {
        newState = 3;  // Complete
        detail = _("Complete");
      } else {
        newState = 4;  // Error
        detail = _("Failed: ");

        bool comma = false;

        wxString werr = ov->GetWeatherForecastError();
        if (!werr.IsEmpty()) {
          detail += _("GRIB: ") + werr;
          comma = true;
        }

        PolarSpeedStatus ps = ov->GetPolarStatus();
        if (ps != POLAR_SPEED_SUCCESS) {
          if (comma) detail += ", ";
          detail += _("Polar: ") + Polar::GetPolarStatusMessage(ps);
          comma = true;
        }

        wxString gerr = ov->GetGribError();
        if (!gerr.IsEmpty()) {
          if (comma) detail += ", ";
          detail += gerr;
          comma = true;
        }

        if (ov->LandCrossing()) {
          if (comma) detail += ", ";
          detail += _("Land: Failed");
          comma = true;
        }

        if (ov->BoundaryCrossing()) {
          if (comma) detail += ", ";
          detail += _("Boundary: Failed");
        }
      }
    } else {
      newState = 1;  // Ready
      detail = _("Ready");
    }

    // Update model if changed
    if (wr->State != newState || wr->StateDetail != detail) {
      wr->State = newState;
      wr->StateDetail = detail;
      changed = true;
    }

    if (changed) UpdateItem(index, true);

    index++;
  }
}


void WeatherRouting::UpdateDialogs() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  long item = -1;
  while (true) {
    item = list->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr =
        reinterpret_cast<WeatherRoute*>(wxUIntToPtr(list->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  // ---------------------------------------------------------------------
  // 2. Statistics Dialog
  // ---------------------------------------------------------------------
  if (m_StatisticsDialog.IsShown()) {
    m_StatisticsDialog.SetRouteMapOverlays(overlays);
    m_StatisticsDialog.Refresh();
  }

  // ---------------------------------------------------------------------
  // 3. Report Dialog
  // ---------------------------------------------------------------------
  if (m_ReportDialog.IsShown()) {
    m_ReportDialog.SetRouteMapOverlays(overlays);
    m_ReportDialog.Refresh();
  }

  // ---------------------------------------------------------------------
  // 4. Plot Dialog (uses only the first selected overlay)
  // ---------------------------------------------------------------------
  if (m_PlotDialog.IsShown()) {
    RouteMapOverlay* first = overlays.empty() ? nullptr : overlays.front();
    m_PlotDialog.SetRouteMapOverlay(first);
    m_PlotDialog.Refresh();
  }
}

void WeatherRouting::UpdateComputeState() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  if (!m_panel) return;

  // Count how many overlays are in each state
  int computing = 0;
  int ready = 0;
  int notComputed = 0;
  int complete = 0;

  for (auto* wr : m_WeatherRoutes) {
    RouteMapOverlay* ov = wr->routemapoverlay;

    if (!ov) {
      notComputed++;
      continue;
    }

    if (ov->HasThread()) {
      computing++;
    } else if (ov->Finished() && ov->ReachedDestination()) {
      complete++;
    } else if (ov->Finished()) {
      ready++;
    } else {
      notComputed++;
    }
  }


  // --- Compute button logic ---
  bool canCompute = (ready > 0 || notComputed > 0);
  m_panel->m_bCompute->Enable(canCompute);

  // --- Stop button logic ---
  bool canStop = (computing > 0);
  m_panel->SetStopButtonEnabled(canStop);

  // --- Progress bar ---
  int total = m_WeatherRoutes.size();
  int done = complete + ready;

  m_panel->m_gProgress->SetRange(total);
  m_panel->m_gProgress->SetValue(done);

  // --- Status text ---
  wxString status;

  if (computing > 0)
    status = _("Computing routes");
  else if (complete > 0)
    status = _("Routes computed");
  else if (ready > 0)
    status = _("Ready");
  else
    status = _("Not computed");

  m_panel->SetStatusText(status);
}


//-----------------------------------------------------------------
// ComputeStateString
//   Helper to convert internal state code to user-friendly string for UI
//   display.
//-----------------------------------------------------------------

wxString WeatherRouting::ComputeStateString(int state) const {
  switch (state) {
    case 0:
      return _("Not Computed");
    case 1:
      return _("Ready");
    case 2:
      return _("Computing");
    case 3:
      return _("Complete");
    default:
      return _("Unknown");
  }
}



//-----------------------------------------------------------------
// UpdateItem (Rows)
//-----------------------------------------------------------------
// UpdateStates() decides whether to call UpdateItem(index, true)
// UpdateItem() always writes the full row
// The list control is cheap to update
// The changed flag is only used by the caller to avoid unnecessary calls
// "Changed" flag controls whether UpdateItem is called
// UpdateItem does not need to know why it was called

void WeatherRouting::UpdateItem(long row, bool refreshState) {
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(list->GetItemData(row));
  if (!wr) return;

  RouteMapOverlay* ov = wr->routemapoverlay;

  // ---------------------------------------------------------
  // Column 0: Visibility
  // ---------------------------------------------------------
  bool visible = (ov && ov->m_bEndRouteVisible);
  list->SetItem(row, VISIBLE, visible ? _("X") : _(""));

  // ---------------------------------------------------------
  // Column 1: Boat
  // ---------------------------------------------------------
  list->SetItem(row, BOAT, wr->BoatFilename);

  // ---------------------------------------------------------
  // Column 2: Start Type
  // ---------------------------------------------------------
  wxString startType = wr->Start ? _("Position") : _("Boat");
  list->SetItem(row, STARTTYPE, startType);

  // ---------------------------------------------------------
  // Column 3: Start (user?entered name from configuration)
  // ---------------------------------------------------------
  wxString startStr;

  if (ov) {
    const RouteMapConfiguration& config = ov->GetConfiguration();
    startStr = config.Start;  // <-- authoritative user-entered name
  }

  list->SetItem(row, START, startStr);

  // ---------------------------------------------------------
  // Column 4: Start Time
  // ---------------------------------------------------------
  wxString startTimeStr =
      wr->StartTime.IsValid() ? wr->StartTime.FormatISOCombined(' ') : _("");
  list->SetItem(row, STARTTIME, startTimeStr);

  // ---------------------------------------------------------
  // Column 5: End  (user?entered name from configuration)
  // ---------------------------------------------------------
  wxString endStr;

  if (ov) {
    const RouteMapConfiguration& config = ov->GetConfiguration();
    endStr = config.End;  // <-- authoritative user-entered name
  }

  list->SetItem(row, END, endStr);

  // ---------------------------------------------------------
  // Column 6: End Time
  // ---------------------------------------------------------
  wxString endTimeStr =
      wr->EndTime.IsValid() ? wr->EndTime.FormatISOCombined(' ') : _("");
  list->SetItem(row, ENDTIME, endTimeStr);

  // ---------------------------------------------------------
  // Column 7: Duration
  // ---------------------------------------------------------
  wxString durationStr;
  if (wr->StartTime.IsValid() && wr->EndTime.IsValid()) {
    wxTimeSpan span = wr->EndTime - wr->StartTime;
    durationStr = span.Format("%H:%M");
  }
  list->SetItem(row, TIME, durationStr);


  // ---------------------------------------------------------
  // Column 8: Distance
  // ---------------------------------------------------------
  wxString distanceStr;
  if (ov) {
    double dist = ov->RouteInfo(RouteMapOverlay::DISTANCE);
    distanceStr = wxString::Format("%.1f", dist);
  }
  list->SetItem(row, DISTANCE, distanceStr);


  // ---------------------------------------------------------
  // Column 9: Avg Speed
  // ---------------------------------------------------------
  wxString avgSpeedStr =
      ov ? wxString::Format("%.1f", ov->RouteInfo(RouteMapOverlay::AVGSPEED))
         : _("");
  list->SetItem(row, AVGSPEED, avgSpeedStr);

  // ---------------------------------------------------------
  // Column 10: Max Speed
  // ---------------------------------------------------------
  wxString maxSpeedStr =
      ov ? wxString::Format("%.1f", ov->RouteInfo(RouteMapOverlay::MAXSPEED))
         : _("");
  list->SetItem(row, MAXSPEED, maxSpeedStr);

  // ---------------------------------------------------------
  // Column 11: Avg Speed Ground
  // ---------------------------------------------------------
  wxString avgSpeedGroundStr =
      ov ? wxString::Format("%.1f",
                            ov->RouteInfo(RouteMapOverlay::AVGSPEEDGROUND))
         : _("");
  list->SetItem(row, AVGSPEEDGROUND, avgSpeedGroundStr);

  // ---------------------------------------------------------
  // Column 12: Max Speed Ground
  // ---------------------------------------------------------
  wxString maxSpeedGroundStr =
      ov ? wxString::Format("%.1f",
                            ov->RouteInfo(RouteMapOverlay::MAXSPEEDGROUND))
         : _("");
  list->SetItem(row, MAXSPEEDGROUND, maxSpeedGroundStr);

  // ---------------------------------------------------------
  // Column 13: Avg Wind
  // ---------------------------------------------------------
  wxString avgWindStr =
      ov ? wxString::Format("%.1f", ov->RouteInfo(RouteMapOverlay::AVGWIND))
         : _("");
  list->SetItem(row, AVGWIND, avgWindStr);

  // ---------------------------------------------------------
  // Column 14: Max Wind
  // ---------------------------------------------------------
  wxString maxWindStr =
      ov ? wxString::Format("%.1f", ov->RouteInfo(RouteMapOverlay::MAXWIND))
         : _("");
  list->SetItem(row, MAXWIND, maxWindStr);

  // ---------------------------------------------------------
  // Column 15: Max Wind Gust
  // ---------------------------------------------------------
  wxString maxWindGustStr =
      ov ? wxString::Format("%.1f", ov->RouteInfo(RouteMapOverlay::MAXWINDGUST))
         : _("");
  list->SetItem(row, MAXWINDGUST, maxWindGustStr);

  // ---------------------------------------------------------
  // Column 16: Avg Current
  // ---------------------------------------------------------
  wxString avgCurrentStr =
      ov ? wxString::Format("%.1f", ov->RouteInfo(RouteMapOverlay::AVGCURRENT))
         : _("");
  list->SetItem(row, AVGCURRENT, avgCurrentStr);

  // ---------------------------------------------------------
  // Column 17: Max Current
  // ---------------------------------------------------------
  wxString maxCurrentStr =
      ov ? wxString::Format("%.1f", ov->RouteInfo(RouteMapOverlay::MAXCURRENT))
         : _("");
  list->SetItem(row, MAXCURRENT, maxCurrentStr);

  // ---------------------------------------------------------
  // Column 18: Avg Swell
  // ---------------------------------------------------------
  wxString avgSwellStr =
      ov ? wxString::Format("%.1f", ov->RouteInfo(RouteMapOverlay::AVGSWELL))
         : _("");
  list->SetItem(row, AVGSWELL, avgSwellStr);

  // ---------------------------------------------------------
  // Column 19: Max Swell
  // ---------------------------------------------------------
  wxString maxSwellStr =
      ov ? wxString::Format("%.1f", ov->RouteInfo(RouteMapOverlay::MAXSWELL))
         : _("");
  list->SetItem(row, MAXSWELL, maxSwellStr);

  // ---------------------------------------------------------
  // Column 20: Upwind %
  // ---------------------------------------------------------
  wxString upwindStr =
      ov ? wxString::Format("%.1f%%",
                            ov->RouteInfo(RouteMapOverlay::PERCENTAGE_UPWIND))
         : _("");
  list->SetItem(row, UPWINDPERCENTAGE, upwindStr);

  // ---------------------------------------------------------
  // Column 21: Port/Starboard %
  // ---------------------------------------------------------
  if (ov) {
    double ps = ov->RouteInfo(RouteMapOverlay::PORT_STARBOARD);
    list->SetItem(row, PORTSTARBOARD,
                  wxString::Format("%.0f/%.0f", ps, 100 - ps));
  } else {
    list->SetItem(row, PORTSTARBOARD, _(""));
  }

  // ---------------------------------------------------------
  // Column 22: Tacks
  // ---------------------------------------------------------
  wxString tacksStr =
      ov ? wxString::Format("%.0f", ov->RouteInfo(RouteMapOverlay::TACKS))
         : _("");
  list->SetItem(row, TACKS, tacksStr);

  // ---------------------------------------------------------
  // Column 23: Jibes
  // ---------------------------------------------------------
  wxString jibesStr =
      ov ? wxString::Format("%.0f", ov->RouteInfo(RouteMapOverlay::JIBES))
         : _("");
  list->SetItem(row, JIBES, jibesStr);

  // ---------------------------------------------------------
  // Column 24: Sail Plan Changes
  // ---------------------------------------------------------
  wxString sailPlanStr =
      ov ? wxString::Format("%.0f",
                            ov->RouteInfo(RouteMapOverlay::SAIL_PLAN_CHANGES))
         : _("");
  list->SetItem(row, SAILPLANCHANGES, sailPlanStr);

  // ---------------------------------------------------------
  // Column 25: Comfort
  // ---------------------------------------------------------
  wxString comfortStr = ov ? RouteMapOverlay::sailingConditionText(
                                 ov->RouteInfo(RouteMapOverlay::COMFORT))
                           : _("");
  list->SetItem(row, COMFORT, comfortStr);

  // ---------------------------------------------------------
  // Column 26: State
  // ---------------------------------------------------------
  if (refreshState) {
    wxString stateStr = ComputeStateString(wr->State);
    if (!wr->StateDetail.IsEmpty()) stateStr += " - " + wr->StateDetail;

    list->SetItem(row, STATE, stateStr);
  }
}



//-----------------------------------------------------------------
// UpdateAllItems
//-----------------------------------------------------------------
// Updates all rows

void WeatherRouting::UpdateAllItems(bool changed) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  if (m_WeatherRoutes.empty()) return;

  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  lc->Freeze();

  int index = 0;
  for (auto* wr : m_WeatherRoutes) {
    UpdateItem(index++, changed);
  }

  if (changed) {
    for (int c = 0; c < NUM_COLS; c++) {
      if (columns[c] >= 0) lc->SetColumnWidth(columns[c], wxLIST_AUTOSIZE);
    }
  }

  lc->Thaw();
}


//-----------------------------------------------------------------
// UpdateColumns   
//-----------------------------------------------------------------
// Rebuilds the columns in the wxListCtrl based on user settings and updates all
// rows to reflect any changes (eg. local/UTC switch for time columns)
// Called when user changes column visibility settings or local/UTC time setting
// or when loading from XML to ensure correct columns are shown
// and all data is up to date
// MODERN IMPLEMENTATION

void WeatherRouting::UpdateColumns() {
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;
  list->DeleteAllColumns();

  for (int i = 0; i < NUM_COLS; i++) {
    if (GetSettingsDialog().m_cblFields->IsChecked(i)) {
      columns[i] = list->GetColumnCount();
      wxString name = _(column_names[i]);

      if (i == STARTTIME || i == ENDTIME) {
        name += " (";
        name += GetSettingsDialog().m_cbUseLocalTime->GetValue() ? _("local")
                                                                 : "UTC";
        name += ")";
      }

      list->InsertColumn(columns[i], name);
      list->SetColumnWidth(columns[i], wxLIST_AUTOSIZE);
    } else {
      columns[i] = -1;
    }
  }

  int index = 0;
  for (auto* wr : m_WeatherRoutes) {
    list->SetItemPtrData(index, (wxUIntPtr)wr);
    wr->Update(this);  // update utc/local time strings
    UpdateItem(index, true);
    index++;
  }
  wxListEvent dummy;
  OnWeatherRouteSelected(dummy);   ;  // update dialogs if visible
}



// -----------------------------------------------------------------
// UpdateConfigurations
// -----------------------------------------------------------------
// Updates the Start/End dropdowns in the ConfigurationDialog based on the
// currently selected WeatherRoute. Called when user selects a different route
// in the list control, and when the ConfigurationDialog is opened. The dialog
// itself also calls this method on open to ensure it is always up to date with
// the current selection. The method safely handles cases where no route is
// selected or where the selected route has no overlay, in which case it simply
// clears the dropdowns and returns without error.

void WeatherRouting::UpdateConfigurations() {
  auto overlays = GetSelectedOverlays();
  if (overlays.size() != 1) return;

  WeatherRoute* wr = overlays[0]->m_weatherRoute;
  if (!wr) return;

  // ---------------------------------------------------------------------
  // Legacy Position-panel code removed.
  // The modern architecture uses Start/End waypoint GUIDs instead of
  // per-route "Positions" lists. ConfigurationDialog no longer receives
  // source names from wr->Positions.
  // ---------------------------------------------------------------------
  // m_ConfigurationDialog.ClearSources();
  //
  // for (const WeatherPoint& p : wr->Positions)
  //     m_ConfigurationDialog.AddSource(p.Name);
  //
  // m_ConfigurationDialog.Update();

  // Nothing to update here until the new waypoint-based configuration
  // dialog is implemented.
}





//-----------------------------------------------------------------------
// Update method for WeatherRoute (Time)
//-----------------------------------------------------------------------
// The state machine now lives in:WeatherRouting::UpdateStates()
// This method is purely for updating computed fields based on the current
// state of the RouteMapOverlay UpdateColumns() calls wr->Update(this)
// which updates the time strings based on the UTC local toggle
// then UpdateItem() writes those strings into the list control





//-----------------------------------------------------------------
// End of Core UI Update Methods
//-----------------------------------------------------------------



//----------------------------------
//   4.1 File / Session
//----------------------------------
// OnOpen
//    Opens an existing weather routing configuration XML file.
// OnSave
//    Saves the current configuration to the existing XML file.
// OnSaveAs
//    Saves the current configuration to a new XML file.
//----------------------------------


void WeatherRouting::OnOpen(wxCommandEvent& event) {
  wxString error;
  wxFileDialog openDialog(
      this, _("Select Configuration"), m_FileName.GetPath(),
      m_FileName.GetName(),
      wxT("XML files (*.xml)|*.XML;*.xml|All files (*.*)|*.*"), wxFD_OPEN);

  if (openDialog.ShowModal() == wxID_OK) {
    wxCommandEvent event;
//    OnDeleteAllPositions(event);
    OnDeleteAll(event);
    OpenXML(openDialog.GetPath());
  }
}

void WeatherRouting::OnSave(wxCommandEvent& event) {
  if (m_FileName.GetFullPath().IsEmpty()) {
    // No file path set yet, behave like Save As
    OnSaveAs(event);
    return;
  }

  SaveXML(m_FileName.GetFullPath());
  m_tAutoSaveXML
      .Stop();  // Stop any pending auto-save since we just manually saved
}

void WeatherRouting::OnSaveAs(wxCommandEvent& event) {
  wxString error;
  wxFileDialog saveDialog(
      this, _("Select Configuration"), m_FileName.GetPath(),
      m_FileName.GetName(),
      wxT("XML files (*.xml)|*.XML;*.xml|All files (*.*)|*.*"),
      wxFD_SAVE | wxFD_OVERWRITE_PROMPT);

  if (saveDialog.ShowModal() == wxID_OK) {
    // Use wxFileDialog::AppendExtension to ensure the file has the .xml
    // extension
    wxString filename =
        wxFileDialog::AppendExtension(saveDialog.GetPath(), "*.xml");

    SaveXML(filename);
    m_tAutoSaveXML
        .Stop();  // Stop any pending auto-save since we just manually saved
  }
}


/***********************************************************************
 * WeatherRouting Close Handlers
 *
 * WeatherRouting implements two different OnClose() handlers:
 *
 *   1. void OnClose(wxCloseEvent& event)
 *   2. void OnClose(wxCommandEvent& event)
 *
 * These two handlers serve different purposes and MUST NOT call each
 * other recursively. Their responsibilities are intentionally distinct:
 *
 * --------------------------------------------------------------------
 * 1. OnClose(wxCloseEvent&)
 * --------------------------------------------------------------------
 * Triggered when the user clicks the window managers X button or
 * when wxWidgets attempts to close the panel programmatically.
 *
 * OpenCPN plugins must NEVER allow their main panel to be destroyed
 * by a wxCloseEvent. The panel is owned by OpenCPN, not the plugin.
 *
 * Therefore:
 *   - We VETO the close request to prevent destruction.
 *   - We forward the intent to the command-version handler so the
 *     plugin can hide itself cleanly.
 *
 * This keeps the plugin alive and prevents crashes or dangling pointers.
 *
 * --------------------------------------------------------------------
 * 2. OnClose(wxCommandEvent&)
 * --------------------------------------------------------------------
 * Triggered when the plugin itself decides to close/hide the panel
 * (toolbar button, menu item, or forwarded from the wxCloseEvent
 * handler above).
 *
 * This handler performs the *actual* close behavior:
 *   - Hide the panel (never destroy it)
 *   - Stop computations safely
 *   - Persist visibility state
 *   - Update menus and refresh UI
 *
 * This is the correct OpenCPN plugin pattern: hide, don?t destroy.
 *
 * --------------------------------------------------------------------
 * Summary
 * --------------------------------------------------------------------
 * wxCloseEvent  -  Veto + forward to command handler
 * wxCommandEvent -  Perform safe hide + state updates
 *
 * This separation ensures:
 *   - No recursion
 *   - No accidental destruction
 *   - Clean shutdown of computations
 *   - Correct persistence of UI state
 *   - Full compatibility with OpenCPN?s plugin lifecycle
 ***********************************************************************/


void WeatherRouting::OnClose(wxCommandEvent& event) {
  // handler for your plugin?s own ?Close/Hide? command.
  // Hide the panel instead of destroying it.
  // This is the standard OpenCPN plugin pattern.
  Hide();

  // Persist window state (size, position, visibility)
  wxFileConfig* pConf = GetOCPNConfigObject();
  if (pConf) {
    pConf->SetPath("/Plugins/WeatherRouting");
    pConf->Write("Visible", false);
  }

  // Stop any running computations safely
  StopAll();

  // Update menus and toolbar buttons
  SetEnableConfigurationMenu();

  // Ensure UI refreshes cleanly
  GetParent()->Refresh();
}

void WeatherRouting::OnClose(wxCloseEvent& event) {
  // Window Manager close or plugin hide command received.
  // Prevent wxWidgets from destroying the panel.
  // OpenCPN owns this window; plugins must never allow destruction here.
  event.Veto();

  // Convert the window-manager close (clicking ?X?) into the same behavior
  // as pressing the plugin?s own ?close/hide? command.
  wxCommandEvent cevent;
  OnClose(cevent);  // Call the command-version safely

  // No event.Skip() here ? we?ve handled the close fully.
}
void WeatherRouting::OnAutoSaveXMLTimer(wxTimerEvent&) { AutoSaveXML(); }

void WeatherRouting::AutoSaveXML() { SaveXML(m_FileName.GetFullPath()); }


//----------------------------------
//   4.2 Route Creation / Deletion
//----------------------------------
// OnNew
//    Creates a new routing configuration.
// OnRenderedTimer
//    Sets initial sash position after rendering starts.
// OnSize
//    Handles resizing of the main panel.
// OnCollPaneChanged
//    Handles changes to the collapsible pane state.
// OnDelete
//    Deletes selected routing configurations.
// OnDeleteAll
//    Deletes all routing configurations
// OnEditPosition - Seen in Position Management section
//    Edits the selected position. See 6. Position Management section. 
//----------------------------------


void WeatherRouting::OnNew(wxCommandEvent& event) {
  // Create an empty configuration object
  RouteMapConfiguration configuration;

  // Pass the configuration into the dialog
  m_ConfigurationDialog.SetConfiguration(configuration);

  // Show the dialog (no arguments allowed)
  if (m_ConfigurationDialog.ShowModal() != wxID_OK) {
    // User cancelled
    return;
  }

  // Retrieve the updated configuration from the dialog
  configuration = m_ConfigurationDialog.GetConfiguration();

  // Add the new configuration to the model + UI
  if (!AddConfiguration(configuration)) {
    wxMessageDialog mdlg(this, _("Failed to create new routing configuration."),
                         _("Weather Routing"), wxOK | wxICON_ERROR);
    mdlg.ShowModal();
    return;
  }

  // Update menus and UI state
  SetEnableConfigurationMenu();
}

void WeatherRouting::OnRenderedTimer(wxTimerEvent&) {
  // don't do it until the window system is up and running
  if (GetClientSize().GetWidth() > 20) {
    if (!sashpos) sashpos = GetClientSize().GetWidth() / 5;
    m_panel->m_splitter1->SetSashPosition(sashpos, true);
    Disconnect(wxEVT_IDLE, wxTimerEventHandler(WeatherRouting::OnRenderedTimer),
               NULL, this);
  }
}

void WeatherRouting::OnSize(wxSizeEvent& event) {
  if (m_colpane && m_colpane->IsExpanded()) {
    Update();
    Layout();
    m_size = GetSize();
  } else {
    if (m_colpane) Fit();
  }
  event.Skip();
}

//-
void WeatherRouting::OnCollPaneChanged(wxCollapsiblePaneEvent& event) {
  if (m_colpane && m_colpane->IsExpanded())
    SetSize(m_size);
  else if (m_colpane)
    Fit();
  Update();
  Layout();
}


//----------------------------------
//   4.3 Reset
//----------------------------------
// OnReset  
// .. Resets a route
// OnResetSelected
//    Resets selected routes.
// OnResetAll
//    Resets all routes.
//----------------------------------

//void WeatherRouting::OnReset(wxCommandEvent& event)
//  { ResetAll();
//}

void WeatherRouting::OnResetSelected(wxCommandEvent& event) {
  ResetSelected();
}

void WeatherRouting::OnResetAll(wxCommandEvent& event) {
   m_StatisticsDialog.SetRunTime(m_RunTime = wxTimeSpan(0));
   ResetAll();
}


//----------------------------------
//   4.4 Compute / Stop
//----------------------------------
// OnCompute
//   build waiting list from selected routes
// OnComputeAll
//   build waiting list from all routes

// OnComputeAll
//    Starts route computation for all routes.
// OnStop
//    Stops route computation for selected routes.
// RouteMapOverlay
//  each overlay has its own thread and state machine
// Start
//   create worker threads
// Stop
//   signal worker threads to stop, but do not wait for them here. The threads
// StartCompute
//  Keep small prevents subtle bugs and makes the scheduler predictable.

//----------------------------------

void WeatherRouting::OnCompute(wxCommandEvent& event) {
#ifdef PLUGIN_USE_ASM
  // If the address space monitor is active and memory is critically low,
  // route computation is disabled to prevent instability.
  if (m_addressSpaceMonitor && m_addressSpaceMonitor->IsComputationDisabled()) {
    wxMessageBox(
        _("Route computation is currently disabled due to high memory usage.\n"
          "Use Reset All or wait until memory is available."),
        _("Weather Routing - Memory Alert"), wxOK | wxICON_WARNING);
    return;
  }
#endif

  wxUnusedVar(event);
  wxLogMessage(
      "OnCompute(): Computing selected routes (modern, no scheduler).");

  // 1. Collect overlays for all *selected* WeatherRoutes
  std::list<RouteMapOverlay*> selectedOverlays;

  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay)
      selectedOverlays.push_back(wr->routemapoverlay);
  }

  // If nothing is selected, there is nothing to compute
  if (selectedOverlays.empty()) return;

  // 2. For each selected overlay, reset state and start computation directly
  for (auto* ov : selectedOverlays) {
    if (!ov) continue;

    wxString error;

    // Ensure clean state before starting
    ov->Stop();
    ov->DeleteThread();
    if (ov->m_weatherRoute) ov->m_weatherRoute->ClearComputedFields();
    ov->ResetFinished();
    ov->MarkDirty();

    ov->Start(error);
  }

  // 3. Refresh UI to reflect new computation state
  UpdateStates();
  UpdateDialogs();
  UpdateComputeState();
}


void WeatherRouting::OnComputeAll(wxCommandEvent& event) {
#ifdef PLUGIN_USE_ASM
  if (m_addressSpaceMonitor && m_addressSpaceMonitor->IsComputationDisabled()) {
    wxMessageBox(
        _("Route computation is currently disabled due to high memory usage.\n"
          "Use Reset All or wait until memory is available."),
        _("Weather Routing - Memory Alert"), wxOK | wxICON_WARNING);
    return;
  }
#endif

  wxUnusedVar(event);
  wxLogMessage("OnComputeAll(): Computing ALL routes (modern, no scheduler).");

  // Directly compute all routes using the modern lifecycle
  ComputeAllRoutes();

  // Refresh UI
  UpdateStates();
  UpdateDialogs();
  UpdateComputeState();
}




void WeatherRouting::OnStop(wxCommandEvent& event) {
  wxLogMessage("OnStop(): stopping selected routes");

  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  //    The list control is the authoritative source of selection.
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> selectedOverlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    // Retrieve the WeatherRoute associated with this row
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay)
      selectedOverlays.push_back(wr->routemapoverlay);
  }

  // If nothing is selected, nothing to stop
  if (selectedOverlays.empty()) return;

  // ---------------------------------------------------------------------
  // 2. Signal each selected overlay to stop
  //    Stop(ov) sets the overlay's stop flag; the scheduler timer
  //    will handle cleanup and thread shutdown.
  // ---------------------------------------------------------------------
  for (auto* ov : selectedOverlays) {
    if (!ov) continue;
    Stop(ov);
  }

  // ---------------------------------------------------------------------
  // 3. Update UI state (buttons, labels, progress bar, etc.)
  // ---------------------------------------------------------------------
  UpdateComputeState();

  // Optional: debug-only invariant check could go here
}




//------------------------------------------
//   4.5 Selection / Sorting / Interaction
//------------------------------------------- List Includes Control Event Handlers --
// 
// OnWeatherRouteSelected
//    Updates the configuration dialog when the user selects a route.
// OnWeatherPositionSelected
//    Updates the position dialog when the user selects a position.
// OnWeatherRouteSort
//    Sorts the weather routes list when the user clicks a column header.
// OnWeatherRoutesListLeftDown
//    Handles clicks on the visibility column to toggle route visibility.
// OnWeatherRouteKeyDown
//    Handles delete key to remove selected routes.
// OnListLabelEdit
//   Handles in-place editing of route names and positions.(NOT USED)
//
//
// -----------------------------------------
// OnPositionKeyDown
// OnRouteSelected
// OnCursorRouteChanged if event driven
//------------------------------------------




// ============================================================================
// WeatherRouting::OnWeatherRoutesListLeftDown
// Modern visibility-toggle handler for the WeatherRoutes list control.
// ============================================================================

void WeatherRouting::OnWeatherRoutesListLeftDown(wxMouseEvent& event) {
  // Preserve long?press behavior for context menu
  OnLeftDown(event);

  // Ensure the modern panel exists
  if (!m_panel || !m_panel->m_lWeatherRoutes) {
    event.Skip();
    return;
  }

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  wxPoint pos = event.GetPosition();
  int flags = 0;

  // Determine which row was clicked
  long index = list->HitTest(pos, flags);
  if (index < 0) {
    event.Skip();
    return;
  }

  // ---------------------------------------------------------------------
  // 1. Check if the Visibility column exists
  // ---------------------------------------------------------------------
  if (columns[VISIBLE] >= 0) {
    int col = columns[VISIBLE];

    int minx = 0;
    int maxx = list->GetColumnWidth(col);

    // -----------------------------------------------------------------
    // 2. Did the user click inside the Visibility column?
    // -----------------------------------------------------------------
    if (event.GetX() >= minx && event.GetX() < maxx) {
      // Retrieve the WeatherRoute* stored in the row
      WeatherRoute* wr =
          reinterpret_cast<WeatherRoute*>(list->GetItemData(index));

      if (!wr || !wr->routemapoverlay) {
        event.Skip();
        return;
      }

      // -----------------------------------------------------------------
      // 3. Toggle visibility
      // -----------------------------------------------------------------
      wr->routemapoverlay->m_bEndRouteVisible =
          !wr->routemapoverlay->m_bEndRouteVisible;

      // -----------------------------------------------------------------
      // 4. Update the row in the UI
      // -----------------------------------------------------------------
      UpdateItem(index, false);

      // -----------------------------------------------------------------
      // 5. Refresh the chart
      // -----------------------------------------------------------------
      RequestRefresh(GetParent());

      // We handled the click ? do not let wxWidgets re?select the row
      return;
    }
  }

  // Allow default selection behavior for all other columns
  event.Skip();
}



void WeatherRouting::OnWeatherRouteKeyDown(wxListEvent& event) {
  // Ensure the new UI panel and list control exist
  if (!m_panel || !m_panel->m_lWeatherRoutes) {
    event.Skip();
    return;
  }

  switch (event.GetKeyCode()) {
    case WXK_DELETE: {
      wxCommandEvent cmd;
      OnDelete(cmd);
      break;
    }
    default:
      event.Skip();
  }
}



//------------------------------------------
//   4.6 Navigation
//------------------------------------------
// OnGoTo
//    Jumps the chart to show all selected routes.



void WeatherRouting::OnGoTo(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // 1. Collect all valid RouteMapOverlays from m_WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  for (auto* wr : m_WeatherRoutes) {
    if (!wr || !wr->routemapoverlay) continue;

    RouteMapConfiguration cfg = wr->routemapoverlay->GetConfiguration();
    if (std::isnan(cfg.StartLat)) continue;  // skip invalid routes

    overlays.push_back(wr->routemapoverlay);
  }

  if (overlays.empty()) return;

  // ---------------------------------------------------------------------
  // 2. Compute centroid of all selected route start/end points
  // ---------------------------------------------------------------------
  double avg_lat = 0, avg_lonx = 0, avg_lony = 0, total = 0;

  for (auto* ov : overlays) {
    RouteMapConfiguration cfg = ov->GetConfiguration();
    if (std::isnan(cfg.StartLat)) continue;

    avg_lat += cfg.StartLat + cfg.EndLat;
    avg_lonx += cos(deg2rad(cfg.StartLon)) + cos(deg2rad(cfg.EndLon));
    avg_lony += sin(deg2rad(cfg.StartLon)) + sin(deg2rad(cfg.EndLon));

    total += 2;
  }

  avg_lat /= total;
  avg_lonx /= total;
  avg_lony /= total;

  double avg_lon = rad2deg(atan2(avg_lony, avg_lonx));

  // ---------------------------------------------------------------------
  // 3. Compute maximum distance from centroid to determine zoom level
  // ---------------------------------------------------------------------
  double max_distance = 0;

  for (auto* ov : overlays) {
    RouteMapConfiguration cfg = ov->GetConfiguration();
    if (std::isnan(cfg.StartLat)) continue;

    double distance;

    DistanceBearingMercator_Plugin(avg_lat, avg_lon, cfg.StartLat, cfg.StartLon,
                                   NULL, &distance);
    max_distance = wxMax(max_distance, distance);

    DistanceBearingMercator_Plugin(avg_lat, avg_lon, cfg.EndLat, cfg.EndLon,
                                   NULL, &distance);
    max_distance = wxMax(max_distance, distance);
  }

  // ---------------------------------------------------------------------
  // 4. Jump to the computed centroid with appropriate zoom
  // ---------------------------------------------------------------------
  if (max_distance > 1e-4) {
    JumpToPosition(avg_lat, avg_lon, .125 / max_distance);
  } else {
    wxMessageDialog mdlg(this, _("Cannot goto invalid route(s)."),
                         _("Weather Routing"), wxOK | wxICON_ERROR);
    mdlg.ShowModal();
  }
}

/* ============================================================
   UI UPDATE & DISPLAY SYNCHRONIZATION
   ------------------------------------------------------------
   Functions that refresh dialog state, map overlays, and
   presentation logic. These do not compute routing results.
   They only reflect current state into the UI.
   ============================================================ */
// UpdateDisplaySettings
//    Updates the display settings of all route map overlays
//    to reflect changes in global display options.
//    Called when global display settings change.
//    Marks all overlays for update and requests a refresh.
//------------------------------------------------------------


void WeatherRouting::UpdateDisplaySettings() {
  for (int i = 0; i < m_panel->m_lWeatherRoutes->GetItemCount(); i++) {
    WeatherRoute* weatherroute = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));
    weatherroute->routemapoverlay->m_UpdateOverlay = true;
  }

  GetParent()->Refresh();
}


/* ============================================================
   UI REACTION HANDLERS
   ------------------------------------------------------------
   Functions that respond to UI state changes (dialogs, radio
   buttons, selections) and update overlays or dialogs.
   These do not compute routing or modify configuration.
   ============================================================ */

double WeatherRouting::ComputeRouteDistance(const Position* dest) {
  double total = 0.0;

  const Position* p = dest;
  while (p && p->parent) {
    const Position* q = static_cast<const Position*>(p->parent);
    total += p->Distance(q);
    p = q;
  }

  return total;
}


// ============================================================================
// WeatherRouting::PopulatePositions
// Rebuilds the positions list control based on the currently selected
// WeatherRoute.
// ============================================================================
// Modern implementation of positions list population.

/*
void WeatherRouting::PopulatePositions() {
  if (!m_PositionPanel || !m_PositionPanel->m_lPositions) return;

  wxListCtrl* list = m_PositionPanel->m_lPositions;

   // Determine which route is selected
  WeatherRoute* wr = GetSelectedRoute();
  if (!wr) {
    list->DeleteAllItems();
    return;
  }

  list->Freeze();
  list->DeleteAllItems();

  // Populate rows from wr->Positions
  int index = 0;
  for (const WeatherPoint& p : wr->Positions) {
    long row = list->InsertItem(list->GetItemCount(), p.Name);

    list->SetItem(row, POSITION_LAT,
                  toSDMM_PlugIn(NEflag::LAT, p.lat, Precision::HI));

    list->SetItem(row, POSITION_LON,
                  toSDMM_PlugIn(NEflag::LON, p.lon, Precision::HI));

    // Store the index so edit/delete handlers can find the right element
    list->SetItemPtrData(row, (wxUIntPtr)index);
    index++;
  }

  list->Thaw();
}
*/




// ============================================================================
// WeatherRouting::AddConfiguration
// Creates a new WeatherRoute + RouteMapOverlay, applies configuration,
// loads start/end positions (if GUID present), inserts into UI, and autosaves.
// ============================================================================
// Modern implementation
bool WeatherRouting::AddConfiguration(RouteMapConfiguration& configuration) {
  wxLogMessage("WR: AddConfiguration() - BEGIN");

  // ---------------------------------------------------------------------
  // 1. Create WeatherRoute + Overlay (modern constructor)
  // ---------------------------------------------------------------------
  WeatherRoute* weatherroute = new WeatherRoute(this);
  weatherroute->routemapoverlay = new RouteMapOverlay(this, weatherroute);

  RouteMapOverlay* ov = weatherroute->routemapoverlay;
  ov->SetConfiguration(configuration);
  ov->ResetFinished();  // clean initial state

  // ---------------------------------------------------------------------
  // 2. Load start/end positions if a Route GUID is provided
  // ---------------------------------------------------------------------
  if (!configuration.RouteGUID.IsEmpty()) {
    std::unique_ptr<PlugIn_Route> rte =
        GetRoute_Plugin(configuration.RouteGUID);

    if (rte && rte->pWaypointList) {
      wxPlugin_WaypointListNode* pwpnode = rte->pWaypointList->GetFirst();

      if (pwpnode) {
        // Start waypoint
        PlugIn_Waypoint* pwp = pwpnode->GetData();

        // ---------------------------------------------------------------------
        // Legacy Position-panel code removed.
        // Old versions added a "Position" row to the left panel.
        // The modern architecture uses waypoint GUIDs only.
        // ---------------------------------------------------------------------
        // AddPosition(weatherroute, pwp->m_lat, pwp->m_lon,
        //             pwp->m_MarkName, pwp->m_GUID, false);

        configuration.Start = pwp->m_MarkName;
        configuration.StartGUID = pwp->m_GUID;
        configuration.StartLat = pwp->m_lat;
        configuration.StartLon = pwp->m_lon;

        // End waypoint (walk to last)
        while (pwpnode->GetNext()) pwpnode = pwpnode->GetNext();

        pwp = pwpnode->GetData();

        // ---------------------------------------------------------------------
        // Legacy Position-panel code removed.
        // ---------------------------------------------------------------------
        // AddPosition(weatherroute, pwp->m_lat, pwp->m_lon,
        //             pwp->m_MarkName, pwp->m_GUID, false);

        configuration.End = pwp->m_MarkName;
        configuration.EndGUID = pwp->m_GUID;
        configuration.EndLat = pwp->m_lat;
        configuration.EndLon = pwp->m_lon;
      }
    }
  }

  // ---------------------------------------------------------------------
  // 3. Insert into model list
  // ---------------------------------------------------------------------
  m_WeatherRoutes.push_back(weatherroute);

  // ---------------------------------------------------------------------
  // 4. Insert into the list control (modern UI)
  // ---------------------------------------------------------------------
  if (m_panel && m_panel->m_lWeatherRoutes) {
    wxListCtrl* list = m_panel->m_lWeatherRoutes;

    wxListItem item;
    long index = list->InsertItem(list->GetItemCount(), item);

    list->SetItemPtrData(index, (wxUIntPtr)weatherroute);

    // Update UI row
    UpdateItem(index, true);
  }

  // ---------------------------------------------------------------------
  // 5. Autosave
  // ---------------------------------------------------------------------
  SaveXML(m_FileName.GetFullPath());

  wxLogMessage("WR: AddConfiguration() - END");
  return true;
}








// ============================================================================
// WeatherRouting::UpdateBoatFilename
// Reapplies configuration + resets overlays whose boat file matches.
// ============================================================================
// Modern implementation

void WeatherRouting::UpdateBoatFilename(const wxString& boatFileName) {
  wxLogMessage("WR: UpdateBoatFilename() - BEGIN (%s)", boatFileName.mb_str());

  if (!m_panel || !m_panel->m_lWeatherRoutes)
      return;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  long count = list->GetItemCount();

  for (long i = 0; i < count; i++) {
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(list->GetItemData(i));
    if (!wr || !wr->routemapoverlay) continue;

    RouteMapOverlay* ov = wr->routemapoverlay;
    RouteMapConfiguration c = ov->GetConfiguration();

    if (c.boatFileName == boatFileName) {
      wxLogMessage("WR: Updating route %ld for boat file change", i);

      // Update configuration
      c.boatFileName = boatFileName;
      ov->SetConfiguration(c);

      // Modern reset lifecycle
      ov->Stop();
      ov->DeleteThread();
      ov->ResetFinished();

      // Update UI row
      UpdateItem(i, true);
    }
  }

  // Autosave
  SaveXML(m_FileName.GetFullPath());

  wxLogMessage("WR: UpdateBoatFilename() - END");
}






//------------------------------------------
//   4.7 Dialogs EVENT HANDLERS ? Configuration / Settings Dialogs
//------------------------------------------
//
// --- Button Command Event Handlers ---
// OnUpdateBoat
//    Updates the "Boat" position to the current boat location
//    This is called when the user requests to update the boat position
// OnDelete          See 6 Route Creation / Deletion
// OnDeletePosition  See 6 Position Management

// --------------------------------------------------------------------------
// OnEditConfiguration  
// --------------------------------------------------------------------------
//    Opens the Configuration dialog for the selected route(s)
//    This is the main edit function for configurations.
// Modern implementation  supports multiple selection.
    
void WeatherRouting::OnEditConfiguration() {
  wxLogMessage(
      "OnEditConfiguration(): Editing configuration for selected routes.");

  // 1. Collect configurations from selected WeatherRoutes
  std::list<RouteMapConfiguration> selectedConfigs;

  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (!wr || !wr->routemapoverlay) continue;

    selectedConfigs.push_back(wr->routemapoverlay->GetConfiguration());
  }

  // If nothing is selected, nothing to edit
  if (selectedConfigs.empty()) return;

  // 2. Populate and show the configuration dialog
  m_ConfigurationDialog.SetConfigurations(selectedConfigs);
  m_ConfigurationDialog.Show();
}


// --------------------------------------------------------------------------
// OnEditConfigurationClick - Mouse Event Wrapper
// ------------------------------------------------------------------------
// Opens the Configuration dialog for the selected route(s)
// This is the main edit function for configurations.
// Modern implementation of the Edit Configuration handler that supports
// multiple selection.
// Modern 


void WeatherRouting::OnEditConfigurationClick(wxMouseEvent& event) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  // Forward as a menu command, just like OnEditPositionClick
  wxCommandEvent cmd(wxEVT_MENU, ID_ROUTING_EDIT);
  OnEditConfiguration(cmd);

  event.Skip();
}


// --------------------------------------------------------------------------
// OnEditPositionClick Mouse Event Wrapper
// ------------------------------------------------------------------------

/*
void WeatherRouting::OnEditPositionClick(wxMouseEvent& event) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxCommandEvent cmd(wxEVT_MENU, ID_POSITION_EDIT);
  OnEditPosition(cmd);

  event.Skip();
}
*/





// --------------------------------------------------------------------------
// OnEditConfiguration - Menu Event Wrapper
// --------------------------------------------------------------------------
// Modern 
void WeatherRouting::OnEditConfiguration(wxCommandEvent& event) {
  OnEditConfiguration();  // call the internal logic
}





//--------------------------------------------------------------------------
// OnUpdateBoat
// -------------------------------------------------------------------------
//    Updates the boat position in the positions list when the boat moves.
// Modern

// MODERN WRAPPER
void WeatherRouting::OnUpdateBoatPosition(wxCommandEvent& event) {
  OnUpdateBoat(event);  // forward to the unified handler
}



// MODERN IMPLEMENTATION
void WeatherRouting::OnUpdateBoat(wxCommandEvent& event) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  // ---------------------------------------------------------------------
  // 1. Get the active WeatherRoute
  // ---------------------------------------------------------------------
  WeatherRoute* wr = GetSelectedRoute();
  if (!wr) {
    wxLogMessage("OnUpdateBoat: no route selected");
    return;
  }

  // ---------------------------------------------------------------------
  // 2. Get the new boat position from the plugin
  // ---------------------------------------------------------------------
  double lat = m_weather_routing_pi.m_boat_lat;
  double lon = m_weather_routing_pi.m_boat_lon;

  // ---------------------------------------------------------------------
  // 3. Find an existing ?Boat? position in this route
  // ---------------------------------------------------------------------
  bool found = false;
  for (auto& pos : wr->Positions) {
    if (pos.Name == _("Boat")) {
      pos.lat = lat;
      pos.lon = lon;
      found = true;
      break;
    }
  }
  // ---------------------------------------------------------------------
  // 4. If no Boat position exists, create one
  // ---------------------------------------------------------------------
  if (!found) {
    WeatherPoint p;
    p.Name = _("Boat");
    p.lat = lat;
    p.lon = lon;
    p.GUID = wxEmptyString;

    wr->Positions.push_back(p);
  }

  // ---------------------------------------------------------------------
  // 5. Mark overlay dirty so the route recomputes
  // ---------------------------------------------------------------------
  if (wr->routemapoverlay) wr->routemapoverlay->MarkDirty();

  // ---------------------------------------------------------------------
  // 6. Refresh UI using the modern pipeline
  // ---------------------------------------------------------------------
 // PopulatePositions();   // refresh the positions list
  UpdateStates();        // recompute route state
  UpdateDialogs();       // update stats/report/plot dialogs
  UpdateComputeState();  // update compute/stop buttons

  // ---------------------------------------------------------------------
  // 7. Autosave
  // ---------------------------------------------------------------------
  SaveXML(m_FileName.GetFullPath());
}







//------------------------------------------
// -- Dialog Interaction Handlers --
//
// OnSettings
//    Opens the Settings dialog on request from the menu.
// OnFilter 
//    Opens the Filter Routes dialog on request from the menu.
// OnStatistics
//    Opens the Statistics dialog on request from the menu.
// OnReport
//    Opens the Report dialog on request from the menu.
// OnCursorPosition
//    Toggles the Cursor Position dialog on request from the menu.
// OnRoutePosition
//    Toggles the Route Position dialog on request from the menu.
// OnBatch
//    Opens the Batch Configuration dialog on request from the menu.
//  OnUpdateBoat
//    Updates the "Boat" position to the current boat location

//------------------------------------------


void WeatherRouting::OnSettings(wxCommandEvent& event) {
  m_SettingsDialog.Show();
}

void WeatherRouting::OnFilter(wxCommandEvent& event) {
  m_FilterRoutesDialog.Show();
}

void WeatherRouting::OnStatistics(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // Collect overlays for all selected WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  if (overlays.empty()) return;

  m_StatisticsDialog.SetRouteMapOverlays(overlays);
  m_StatisticsDialog.Show();
}


// ---------------------------------------------------------------------
// Collect overlays for all selected WeatherRoutes
// ---------------------------------------------------------------------
void WeatherRouting::OnReport(wxCommandEvent& event) {
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  if (overlays.empty()) return;

  m_ReportDialog.SetRouteMapOverlays(overlays);
  m_ReportDialog.Show();
}

void WeatherRouting::OnCursorPosition(wxCommandEvent& event) {
  m_CursorPositionDialog.Show(!m_CursorPositionDialog.IsShown());
  UpdateCursorPositionDialog();
}

void WeatherRouting::OnRoutePosition(wxCommandEvent& event) {
  m_RoutePositionDialog.Show(!m_RoutePositionDialog.IsShown());
  UpdateRoutePositionDialog();
}

void WeatherRouting::OnBatch(wxCommandEvent& event) {
  if (m_ConfigurationBatchDialog.IsShown()) return;

  // Reset the batch UI dialog (UI only, not engine state)
  m_ConfigurationBatchDialog.Reset();
  m_ConfigurationBatchDialog.Show();
}


  // ---------------------------------------------------------------------
// Use the *first selected* WeatherRoute for plotting
// ---------------------------------------------------------------------
void WeatherRouting::OnPlot(wxCommandEvent& event) {

  long item = m_panel->m_lWeatherRoutes->GetNextItem(-1, wxLIST_NEXT_ALL,
                                                     wxLIST_STATE_SELECTED);

  if (item < 0) return;

  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
      wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

  if (!wr || !wr->routemapoverlay) return;

  m_PlotDialog.SetRouteMapOverlay(wr->routemapoverlay);
  m_PlotDialog.Show();
}


//-----------------------------------------------------------
//   4.8  UI Commands: Help / Information / Auxiliary Dialogs
//-----------------------------------------------------------
// OnWeatherTable
//    This function opens the Weather Routing Table panel.
//    and adds it to the AUI manager if not already present.
//    upon user request from the menu.
// OnManual
//    This function opens the Weather Routing User Manual
//    in the default web browser upon user request from the menu.
// OnInformation
//   This function opens the Weather Routing Information
//   HTML file in the default web browser upon user request from the menu.
// OnAbout
//   This function opens the About dialog upon user request from the menu.
//-----------------------------------------------------------

void WeatherRouting::OnWeatherTable(wxCommandEvent& event) {
  AddRoutingPanel();
}

void WeatherRouting::OnManual(wxCommandEvent& event) {
  wxLaunchDefaultBrowser(
      "https://opencpn.org/wiki/dokuwiki/"
      "doku.php?id=opencpn:opencpn_user_manual:plugins:weather:weather_"
      "routing");
}

void WeatherRouting::OnInformation(wxCommandEvent& event) {
  wxString infolocation = GetPluginDataDir("weather_routing_pi") + "/data/" +
                          _("WeatherRoutingInformation.html");
  wxLaunchDefaultBrowser("file://" + infolocation);
}

void WeatherRouting::OnAbout(wxCommandEvent& event) {
  AboutDialog dlg(GetParent());
  dlg.ShowModal();
}



/*********************************************************/
/*   5. XML Load / Save                              */
/*********************************************************/





bool WeatherRouting::OpenXML(wxString filename, bool reportfailure) {
  wxLogMessage("WR: OpenXML() entered");

  TiXmlDocument doc;
  wxString error;

  wxProgressDialog* progressdialog = NULL;
  wxDateTime start = wxDateTime::UNow();

  wxString lastboatFileName;
  Boat lastboat;

  // ------------------------------------------------------------
  // 1. Load document
  // ------------------------------------------------------------
  if (!doc.LoadFile(filename.mb_str())) {
    error = _("Failed to load file.");
    if (reportfailure) {
      wxMessageDialog mdlg(this, error, _("Weather Routing"),
                           wxOK | wxICON_ERROR);
      mdlg.ShowModal();
    }
    delete progressdialog;
    return false;
  }

  // ------------------------------------------------------------
  // 2. Root element + name validation
  // ------------------------------------------------------------
  TiXmlElement* rootElem = doc.RootElement();
  if (!rootElem) {
    error = _("Invalid xml file");
    if (reportfailure) {
      wxMessageDialog mdlg(this, error, _("Weather Routing"),
                           wxOK | wxICON_ERROR);
      mdlg.ShowModal();
    }
    delete progressdialog;
    return false;
  }

  TiXmlHandle root(rootElem);
  wxString rootName = wxString::FromUTF8(root.Element()->Value());
  wxLogMessage("ROOT ELEMENT = %s", rootName.mb_str());

  // Accept historical root names
  if (rootName != "OpenCPNWeatherRoutingConfiguration" &&
      rootName != "WeatherRoutingConfiguration" &&
      rootName != "OpenCPNWeatherRouting") {
    error = _("Invalid xml file");
    if (reportfailure) {
      wxMessageDialog mdlg(this, error, _("Weather Routing"),
                           wxOK | wxICON_ERROR);
      mdlg.ShowModal();
    }
    delete progressdialog;
    return false;
  }

  // ------------------------------------------------------------
  // 3. Count nodes for progress dialog
  // ------------------------------------------------------------
  int count = 0;
  for (TiXmlElement* e = root.FirstChild().Element(); e;
       e = e->NextSiblingElement())
    count++;

  // ------------------------------------------------------------
  // 4. Iterate children
  // ------------------------------------------------------------
  int i = 0;
  for (TiXmlElement* e = root.FirstChild().Element(); e;
       e = e->NextSiblingElement(), i++) {
    // Progress dialog logic
    if (progressdialog) {
      if (!progressdialog->Update(i)) {
        delete progressdialog;
        return true;
      }
    } else {
      wxDateTime now = wxDateTime::UNow();
      if ((now - start).GetMilliseconds() > 250 && i < count / 2) {
        progressdialog = new wxProgressDialog(
            _("Load"), _("Weather Routing"), count, this,
            wxPD_CAN_ABORT | wxPD_ELAPSED_TIME | wxPD_REMAINING_TIME);
      }
    }

    // ---------------------------------------------------------------------
    // Ignore legacy <Position> nodes (old global list)
    // ---------------------------------------------------------------------
    if (!strcmp(e->Value(), "Position")) {
      wxLogMessage("Skipping legacy <Position> node");
      continue;
    }

    // ---------------------------------------------------------------------
    // Load <Configuration> blocks
    // ---------------------------------------------------------------------
    if (!strcmp(e->Value(), "Configuration")) {
      RouteMapConfiguration configuration;

      configuration.RouteGUID = wxString::FromUTF8(e->Attribute("GUID"));

      configuration.StartType =
          (RouteMapConfiguration::StartDataType)AttributeInt(
              e, "StartType", RouteMapConfiguration::START_FROM_POSITION);

      // ---------------------------------------------------------------------
      // Legacy Position-panel code removed.
      // Old versions used <Position> nodes and a global Positions list.
      // The modern architecture uses per-route Start/End waypoint GUIDs.
      // ---------------------------------------------------------------------
      // (Removed)
      // for (size_t i = 0; i < wr->Positions.size(); ++i)
      //     AddPositionRow(i);
      //
      // m_ConfigurationDialog.RemoveSource(name);
      // m_ConfigurationBatchDialog.RemoveSource(name);
      //
      // UpdateConfigurations();
      // MarkRouteDirty(wr);

      // Continue loading the rest of the <Configuration> block...

  // Keep configuration dialogs in sync if they still use position names
 // m_ConfigurationDialog.RemoveSource(name);
 // m_ConfigurationBatchDialog.RemoveSource(name);

  // Update dependent UI / configuration and persist
  UpdateConfigurations();
  MarkRouteDirty(wr);  // marks overlay dirty and saves XML
}


/*
void WeatherRouting::OnDeleteAllPositions(wxCommandEvent& event) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  // Collect selected overlays (may be one or many)
  std::vector<RouteMapOverlay*> overlays = GetSelectedOverlays();
  if (overlays.empty()) {
    wxLogMessage("OnDeleteAllPositions: no routes selected");
    return;
  }

  // Clear positions for each selected route
  for (auto* ov : overlays) {
    if (!ov || !ov->m_weatherRoute) continue;

    WeatherRoute* wr = ov->m_weatherRoute;
    wr->Positions.clear();
    MarkRouteDirty(wr);  // clear compute state + persist
  }

  // Clear configuration dialogs? sources if they are still driven by positions
  m_ConfigurationDialog.ClearSources();
  m_ConfigurationBatchDialog.ClearSources();

  // Clear the UI list for positions
 // if (m_PositionPanel && m_PositionPanel->m_lPositions)
 //   m_PositionPanel->m_lPositions->DeleteAllItems();

  // Optionally also refresh route configurations
  UpdateConfigurations();
}
*/


void WeatherRouting::OnDelete(wxCommandEvent& event) {
  // 1. Determine which overlays/routes are selected
  auto overlays = GetSelectedOverlays();
  if (overlays.empty()) return;

  // 2. Stop all computations before deleting anything
  StopAll();

  // 3. Delete the selected overlays/routes safely
  std::list<RouteMapOverlay*> overlayList(overlays.begin(), overlays.end());
  DeleteRouteMaps(overlayList);

  // 4. Update UI state
  UpdateStates();
  UpdateDialogs();

  // 5. Refresh the chart
  RequestRefresh(GetParent());

  // 6. Schedule autosave
  m_tAutoSaveXML.Start(5000, true);
}




/*********************************************************/
/*   7. Configuration Management                          */
/*********************************************************/
// DefaultConfiguration
//   Creates a default configuration based on first two positions
//   and standard settings.
//   Used when creating a new route from scratch.
//   The default boat is Boat.xml from the standard boats directory.
//   If less than two positions exist, lat/lon are set to 0.
//   The start time is set to now, with a delta time of 1 hour.
//   Other settings are hard-coded defaults.
//   Returns the created RouteMapConfiguration object.
// AddConfiguration
//   Adds a new configuration to the list of weather routes.
//   If the configuration has a RouteGUID, it retrieves the route
//   and sets the start and end positions accordingly.
//   Creates a new WeatherRoute and RouteMapOverlay for the configuration.
//   Updates the UI list and enables relevant menu items.
//   Schedules an auto-save of the XML file.
//   Returns true if the configuration was added successfully.
// UpdateConfigurations
//   Updates all existing weather routes with their current configurations.
//   This is typically called after positions have been modified.
//   It retrieves the configuration from each RouteMapOverlay,
//   sets it back to update start/end positions, and then updates the route.
//   No return value.
// UpdateBoatFileName
//   Updates the boat file name for all existing weather routes.
//   This is called when the standard boats directory changes.
//   It sets the boat file name in each RouteMapOverlay's configuration
//   to the new standard path. No return value.
// SetEnableConfigurationMenu
//   Enables or disables the configuration menu items.
//  This is used to prevent user interaction during long operations.
//   It sets the enabled state of the configuration menu and batch menu.
//   No return value.
//----------------------------------------------------------



void WeatherRouting::OnDefaultConfiguration(wxCommandEvent& event) {
  // Empty handler is fine ? menu item reserved for future use
}


RouteMapConfiguration WeatherRouting::DefaultConfiguration() {
  RouteMapConfiguration configuration;

  // ---------------------------------------------------------------------
  // 1. Legacy per-route Positions removed.
  // The modern architecture uses Start/End waypoint GUIDs instead of
  // wr->Positions. DefaultConfiguration() must NOT depend on Positions.
  // ---------------------------------------------------------------------
  WeatherRoute* wr = GetSelectedRoute();

  // (Removed)
  // if (wr && !wr->Positions.empty()) {
  //     const WeatherPoint& p = wr->Positions.front();
  //     configuration.Start = p.Name;
  //     configuration.StartLat = p.lat;
  //     configuration.StartLon = p.lon;
  // } else {
  //     configuration.StartLat = 0;
  //     configuration.StartLon = 0;
  // }

  // Default start (until waypoint-based selection is added)
  configuration.StartLat = 0;
  configuration.StartLon = 0;

  configuration.StartTime = wxDateTime::Now();
  configuration.DeltaTime = 3600;

  // (Removed)
  // if (wr && wr->Positions.size() >= 2) {
  //     const WeatherPoint& p = wr->Positions[1];
  //     configuration.End = p.Name;
  //     configuration.EndLat = p.lat;
  //     configuration.EndLon = p.lon;
  // } else {
  //     configuration.EndLat = 0;
  //     configuration.EndLon = 0;
  // }

  // Default end (until waypoint-based selection is added)
  configuration.EndLat = 0;
  configuration.EndLon = 0;

  // ---------------------------------------------------------------------
  // 2. Default boat
  // ---------------------------------------------------------------------
  configuration.boatFileName = weather_routing_pi::StandardPath() + "boats" +
                               wxFileName::GetPathSeparator() + "Boat.xml";

  // ---------------------------------------------------------------------
  // 3. Default routing parameters
  // ---------------------------------------------------------------------
  configuration.Integrator = RouteMapConfiguration::NEWTON;

  configuration.MaxDivertedCourse = 90;
  configuration.MaxCourseAngle = 180;
  configuration.MaxSearchAngle = 120;
  configuration.MaxTrueWindKnots = 50;
  configuration.MaxApparentWindKnots = 50;

  configuration.MaxSwellMeters = 20.;
  configuration.MaxLatitude = 90;
  configuration.TackingTime = 0;
  configuration.JibingTime = 0;
  configuration.SailPlanChangeTime = 0;
  configuration.WindVSCurrent = 0;

  configuration.AvoidCycloneTracks = false;
  configuration.CycloneMonths = 1;
  configuration.CycloneDays = 0;

  configuration.UseGrib = true;
  configuration.ClimatologyType = RouteMapConfiguration::MOST_LIKELY;
  configuration.AllowDataDeficient = false;
  configuration.WindStrength = 1;

  configuration.DetectLand = true;
  configuration.SafetyMarginLand = 0.;
  configuration.DetectBoundary = false;
  configuration.Currents = false;
  configuration.OptimizeTacking = false;
  configuration.InvertedRegions = false;
  configuration.Anchoring = false;

  configuration.FromDegree = 0;
  configuration.ToDegree = 180;
  configuration.ByDegrees = 5;

  return configuration;
}



void WeatherRouting::AddRoutingPanel() {
  // ---------------------------------------------------------------------
  // 1. Determine the first selected WeatherRoute
  //    The list control is the authoritative source of selection.
  // ---------------------------------------------------------------------
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* lc = m_panel->m_lWeatherRoutes;

  long item = lc->GetNextItem(-1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
  if (item < 0) return;  // No selection ? nothing to show

  WeatherRoute* wr =
      reinterpret_cast<WeatherRoute*>(wxUIntToPtr(lc->GetItemData(item)));

  if (!wr || !wr->routemapoverlay) return;

  RouteMapOverlay* ov = wr->routemapoverlay;

  // ---------------------------------------------------------------------
  // 2. Create the RoutingTablePanel if needed
  // ---------------------------------------------------------------------
  if (!m_RoutingTablePanel) {
    wxWindow* parent = m_weather_routing_pi.GetParentWindow();

    m_RoutingTablePanel = new RoutingTablePanel(parent, *this, ov);

    wxAuiManager* mgr = ::GetFrameAuiManager();
    wxAuiPaneInfo pane = wxAuiPaneInfo()    
                             .Name("Weather Routing Table")
                             .Caption("Weather Routing Table")
                             .CaptionVisible(true)
                             .Float()
                             .FloatingPosition(100, 100)
                             .FloatingSize(700, 400)
                             .Dockable(true)
                             .Movable(true)
                             .CloseButton(true);

    mgr->AddPane(m_RoutingTablePanel, pane);

#if OCPN_API_VERSION_MAJOR > 1 || \
    (OCPN_API_VERSION_MAJOR == 1 && OCPN_API_VERSION_MINOR >= 20)
    PI_ColorScheme cs = GetAppColorScheme();
    static_cast<RoutingTablePanel*>(m_RoutingTablePanel)->SetColorScheme(cs);
#endif

    mgr->Update();
  }

  // ---------------------------------------------------------------------
  // 3. Update existing panel with the selected route
  // ---------------------------------------------------------------------
  else {
    auto* panel = static_cast<RoutingTablePanel*>(m_RoutingTablePanel);
    panel->m_RouteMap = ov;
    panel->PopulateTable();

    wxAuiManager* mgr = ::GetFrameAuiManager();
    wxAuiPaneInfo& pane = mgr->GetPane(m_RoutingTablePanel);

    if (!pane.IsShown()) {
      pane.Show(true);
      mgr->Update();
    }
  }
}


/*********************************************************/
/*   8. Route List Management (Model + wxListCtrl ) */
/*********************************************************/
// AddRouteToList
//   Add a new WeatherRoute to the internal model and the wxListCtrl
//   then populate its row via UpdateItem()
// RemoveRouteFromList
//   Remove a WeatherRoute from the internal model and the wxListCtrl
//   using the unified Reset(overlay) lifecycle for safe teardown
//   then refresh remaining rows with UpdateItem()
//-----------------------------------------------------  
// RemoveSelectedRoutes
//   Remove all selected WeatherRoutes from the internal model and the
//   wxListCtrl then refresh remaining rows with UpdateItem()
// RemoveAllRoutes
//   Remove all WeatherRoutes from the internal model and the wxListCtrl
//   using the unified Reset(overlay) lifecycle for safe teardown
//   then refresh UI state with UpdateDialogs()
//-----------------------------------------------------
// SelectRouteInList
//   Select a WeatherRoute in the wxListCtrl given its pointer
//   clearing any previous selection
//   used after adding a new route to highlight it
//   or when the user requests selection via context menu
//   or when a route computation finishes
//   or when the user double-clicks a route to edit it
//   or when the user requests selection via external code
//  then refresh UI state with UpdateDialogs()

//------------------------------------------
//   8.1 Add / Remove
//------------------------------------------

// Modern unified route addition logic
void WeatherRouting::AddRouteToList(WeatherRoute* wr) {
  if (!wr) return;

  // Add to internal model
  m_WeatherRoutes.push_back(wr);

  // Determine the new row index
  long index = m_panel->m_lWeatherRoutes->GetItemCount();

  // Insert a new row with the route pointer as item data
  wxListItem item;
  item.SetId(index);
  item.SetData(reinterpret_cast<wxUIntPtr>(wr));
  item.SetText("");  // first column text (STATE will be filled by UpdateItem)
  m_panel->m_lWeatherRoutes->InsertItem(item);

  // Initialize all columns to empty strings
  for (int c = 0; c < NUM_COLS; c++) {
    if (columns[c] >= 0)
      m_panel->m_lWeatherRoutes->SetItem(index, columns[c], "");
  }

  // Now populate the row using the unified update pipeline
  UpdateItem(index, true);
}



// Modern unified route removal logic using the canonical Reset(overlay)
// lifecycle

void WeatherRouting::RemoveRouteFromList(long index) {
  if (index < 0 || index >= (long)m_WeatherRoutes.size()) return;

  // 1. Locate the WeatherRoute in the model
  auto it = m_WeatherRoutes.begin();
  std::advance(it, index);
  WeatherRoute* wr = *it;

  // 2. Delete the overlay using the unified lifecycle
  if (wr && wr->routemapoverlay) {
    DeleteRouteMap(wr->routemapoverlay);
  }

  // 3. Delete the WeatherRoute object
  delete wr;
  m_WeatherRoutes.erase(it);

  // 4. Remove the row from the UI list control
  m_panel->m_lWeatherRoutes->DeleteItem(index);

  // 5. Reindex remaining rows
  long count = m_panel->m_lWeatherRoutes->GetItemCount();
  auto it2 = m_WeatherRoutes.begin();
  for (long i = 0; i < count; i++, ++it2) {
    m_panel->m_lWeatherRoutes->SetItemData(i,
                                           reinterpret_cast<wxUIntPtr>(*it2));
  }

  // 6. Refresh UI rows
  for (long i = 0; i < count; i++) UpdateItem(i, true);

  // 7. Global UI refresh pipeline
  UpdateDialogs();
  UpdateComputeState();
  if (GetParent()) GetParent()->Refresh();
}



// RemoveSelectedRoutes
//   Remove all selected WeatherRoutes from the internal model and the
// MODERN
void WeatherRouting::RemoveSelectedRoutes() {
  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  if (!lc) return;

  // Collect selected indices (descending order avoids index shifting)
  std::vector<long> selected;
  long item = -1;

  for (;;) {
    item = lc->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item == -1) break;
    selected.push_back(item);
  }

  if (selected.empty()) return;

  std::sort(selected.begin(), selected.end(), std::greater<long>());

  // Remove each selected route using the unified lifecycle
  for (long idx : selected) RemoveRouteFromList(idx);

  // Refresh remaining rows
  long count = lc->GetItemCount();
  for (long i = 0; i < count; i++) UpdateItem(i, true);

  // Update dialogs and UI state
  UpdateDialogs();
  GetParent()->Refresh();
}


// RemoveAllRoutes
// MODERN
void WeatherRouting::RemoveAllRoutes() {
  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  if (!lc) return;

  if (m_WeatherRoutes.empty()) return;

  // Freeze UI to avoid flicker during mass deletion
  lc->Freeze();

  // 1. Reset each overlay using the canonical 3?phase lifecycle
  for (WeatherRoute* wr : m_WeatherRoutes) {
    if (wr && wr->routemapoverlay) {
      Reset(wr->routemapoverlay);  // unified, safe teardown
    }
  }

  // 2. Delete all WeatherRoute objects
  for (WeatherRoute* wr : m_WeatherRoutes) {
    delete wr;
  }

  // 3. Clear the model
  m_WeatherRoutes.clear();

  // 4. Clear the UI list control
  lc->DeleteAllItems();

  // 5. Thaw UI
  lc->Thaw();

  // 6. Refresh dialogs and UI state
  UpdateDialogs();
  GetParent()->Refresh();
}



//------------------------------------------
//   8.2 Selection
//------------------------------------------

// SelectRouteInList
// MODERN 

void
    WeatherRouting::SelectRouteInList(WeatherRoute* wr) {
  if (!wr) return;

  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  if (!lc) return;

  // Find the index of this WeatherRoute in the model
  long index = -1;

  long i = 0;
  for (auto it = m_WeatherRoutes.begin(); it != m_WeatherRoutes.end();
       ++it, ++i) {
    if (*it == wr) {
      index = i;
      break;
    }
  }

  if (index == -1) return;  // Not found

  // Clear any previous selection (wxListCtrl has no UnselectAll)
  long item = -1;
  while (true) {
    item = lc->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item == -1) break;
    lc->SetItemState(item, 0, wxLIST_STATE_SELECTED);
  }

  // Select the row
  lc->SetItemState(index, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);

  // Ensure it is visible
  lc->EnsureVisible(index);
}


//------------------------------------------
//   8.3 Column / WeatherRouting  Table Management
//------------------------------------------

void WeatherRouting::RebuildListControlColumns() {
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* lc = m_panel->m_lWeatherRoutes;

  // Freeze UI to avoid flicker
  lc->Freeze();

  // 1. Remove all existing columns
  lc->DeleteAllColumns();

  // 2. Rebuild the columns[] mapping based on user settings
  int colIndex = 0;
  for (int i = 0; i < NUM_COLS; i++) {
    if (m_SettingsDialog.m_cblFields->IsChecked(i)) {
      columns[i] = colIndex;

      wxString name = column_names[i];

      // Add "(local)" or "(UTC)" to time columns
      if (i == STARTTIME || i == ENDTIME) {
        name += " (";
        if (m_SettingsDialog.m_cbUseLocalTime->GetValue())
          name += _("local");
        else
          name += _("UTC");
        name += ")";
      }

      lc->InsertColumn(colIndex, name);
      lc->SetColumnWidth(colIndex, wxLIST_AUTOSIZE);
      colIndex++;
    } else {
      columns[i] = -1;  // column hidden
    }
  }

  // 3. Rebuild all rows (item data + values)
  long count = lc->GetItemCount();
  lc->DeleteAllItems();

  long index = 0;
  for (auto wr : m_WeatherRoutes) {
    wxListItem item;
    item.SetId(index);
    item.SetData(reinterpret_cast<wxUIntPtr>(wr));
    item.SetText("");  // STATE column will be filled by UpdateItem
    lc->InsertItem(item);

    UpdateItem(index, true);
    index++;
  }

  // 4. Thaw UI
  lc->Thaw();
}



/*************************************************************************/
/*     9.WeatherRoute::Update(Model Update Logic)  full 1?30?2026 version */
/**************************************************************************/
// Update
//   Update the WeatherRoute fields from the RouteMapOverlay
//   Called when the RouteMapOverlay has new data
//   Typically after a computation step or completion
//   Update can be full or state only
//   If stateonly == true, only the State field is updated
//   Used when only the State may have changed (eg. Started, Stopped, Error
//   Finished, etc.)
//   If stateonly == false, all fields are updated
//   Used when the route has new data (eg. after a computation step or
//   completion)
// UpdateItem
//   Displays the WeatherRoute fields in the wxListCtrl
//   Called after WeatherRoute::Update to refresh the UI
// RebuildList
//   Rebuilds the wxListCtrl columns based on user settings
//   Called when user changes column visibility settings
// ------------------------------------------------------------
// THIS IS THE MODERNIZED, FULLY REFACTORED WeatherRoute::Update METHOD

void WeatherRoute::Update(WeatherRouting * wr, bool stateonly) {
  wxLogMessage("WR: WeatherRoute::Update() entered");

  if (!routemapoverlay) return;

  // ------------------------------------------------------------
  // 1. On full update, sync basic model fields from configuration
  // ------------------------------------------------------------
  if (!stateonly) {
    RouteMapConfiguration configuration = routemapoverlay->GetConfiguration();

    BoatFilename = configuration.boatFileName;
    Start = configuration.Start;
    End = configuration.End;
    StartTime = configuration.StartTime;
    EndTime = routemapoverlay->EndTime();

    // Clear any cached/computed fields if you ever add them again
    ClearComputedFields();
  }

  // ------------------------------------------------------------
  // 2. Compute numeric state code (int) for the model
  // ------------------------------------------------------------
  if (!routemapoverlay->Valid()) {
    // e.g. 0 = Not Computed, 1 = Ready, 2 = Computing, 3 = Complete, 4 = Error
    State = 4;  // Error / Invalid
    return;
  }

  if (routemapoverlay->Running()) {
    State = 2;  // Computing
    return;
  }

  if (routemapoverlay->m_Stopped) {
    State = 4;  // Error / Stopped
    return;
  }

  if (routemapoverlay->Finished()) {
    if (routemapoverlay->ReachedDestination())
      State = 3;  // Complete
    else
      State = 1;  // Ready but not fully successful
    return;
  }

  // Idle / not yet computed
  State = 1;  // Ready
}

// Added overload for state-only updates to get it compiling
// without needing to change all existing calls to Update()

void WeatherRoute::Update(WeatherRouting * wr) {
  Update(wr, /*stateonly=*/false);
}





// MODERN

void WeatherRouting::RebuildList() {
  // Preserve selection
  std::vector<WeatherRoute*> selected;
  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
    if (item == -1) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));
    selected.push_back(wr);
  }

  // Preserve scroll position
  int top = m_panel->m_lWeatherRoutes->GetTopItem();

  // Clear and rebuild
  m_panel->m_lWeatherRoutes->Freeze();
  m_panel->m_lWeatherRoutes->DeleteAllItems();

  for (auto* wr : m_WeatherRoutes) {
    if (!wr->Filtered) {
      wxListItem item;
      item.SetId(m_panel->m_lWeatherRoutes->GetItemCount());
      item.SetData(wr);
      long idx = m_panel->m_lWeatherRoutes->InsertItem(item);
      UpdateItem(idx, true);
    }
  }

  // Restore selection
  for (long i = 0; i < m_panel->m_lWeatherRoutes->GetItemCount(); i++) {
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));

    if (std::find(selected.begin(), selected.end(), wr) != selected.end())
      m_panel->m_lWeatherRoutes->SetItemState(i, wxLIST_STATE_SELECTED,
                                              wxLIST_STATE_SELECTED);
  }

  // Restore scroll position
  if (top >= 0) m_panel->m_lWeatherRoutes->EnsureVisible(top);

  m_panel->m_lWeatherRoutes->Thaw();
}



/*********************************************************/
/*   10.Thread Lifecycle(Modern 3?Phase Model)     */
/*********************************************************/
// StopAll
//    Stops all route threads safely
//    by signaling workers to stop, waiting for worker
//    exit signal, and thencleaning up
// ResetAll
//    Resets all routes using the unified 3 phase lifecycle
//    Stops all threads, resets each overlay, then updates the UI
//-------------------------
// Stop(RouteMapOverlay*)
//    Stops a single route thread safely
// Reset(RouteMapOverlay*)
//    Resets a single route using the unified 3 phase lifecycle
//-------------------------
// ResetSelected
//   Stops and resets only the selected RouteMapOverlay objects
//   then updates the UI


//------------------------------------------
//   10.1 Global
//------------------------------------------




// ============================================================================
    // WeatherRouting::Stop
    // Modern deterministic shutdown of all RouteMapOverlay worker threads,
    // followed by lifecycle invariant verification.
// ========================================================================
    // Use  RouteMapOverlay::Stop() as the canonical per-overlay shutdown method
    // that handles signaling, waiting, joining, and cleanup internally
    // This ensures a consistent and safe shutdown process for each overlay,
    // and allows StopSelected() and StopAll() to simply call this method for
    // each overlay without needing to manage the complex shutdown logic themselves.
    // To stop one overlay  ov->Stop();



// ============================================================================
// WeatherRouting::StopSelected
// Modern deterministic shutdown of all RouteMapOverlay worker threads,
// followed by lifecycle invariant verification.
// ========================================================================

void WeatherRouting::StopSelected() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("WR: StopSelected ? BEGIN");

  auto overlays = GetSelectedOverlays();
  if (overlays.empty()) {
    wxLogMessage("WR: StopSelected ? no routes selected");
    return;
  }

  for (auto* ov : overlays) {
    if (!ov) continue;

    wxLogMessage("WR: StopSelected ? stopping overlay=%p", ov);

    ov->Stop();           // full lifecycle stop (signal + join + cleanup)
    ov->ResetFinished();  // clear compute state
    ov->MarkDirty();      // force UI refresh
  }

  m_positionOnRoute = nullptr;

  UpdateStates();
  UpdateDialogs();
  UpdateComputeState();

  AssertThreadLifecycleInvariants();

  wxLogMessage("WR: StopSelected ? END");
}



// ============================================================================
// WeatherRouting::StopAll
// Modern deterministic shutdown of all RouteMapOverlay worker threads,
// followed by lifecycle invariant verification.
// ============================================================================
void WeatherRouting::StopAll() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("WeatherRouting::StopAll - BEGIN");

  // ---------------------------------------------------------------------
  // 1. Stop each overlay deterministically
  // ---------------------------------------------------------------------
  for (auto* wr : m_WeatherRoutes) {
    if (!wr || !wr->routemapoverlay) continue;

    RouteMapOverlay* ov = wr->routemapoverlay;

    wxLogMessage("StopAll: calling Stop() on overlay=%p", ov);
    ov->Stop();  // handles signaling, waiting, joining, cleanup
  }

  // ---------------------------------------------------------------------
  // 2. Refresh UI state
  // ---------------------------------------------------------------------
  UpdateStates();

  // ---------------------------------------------------------------------
  // 3. Assert modern lifecycle invariants
  // ---------------------------------------------------------------------
  AssertThreadLifecycleInvariants();

  wxLogMessage("WeatherRouting::StopAll - END");
}


// ============================================================================
// WeatherRouting::Reset
// Modern per-overlay reset: ensure no worker, clear compute state, mark dirty,
// refresh UI, persist, and assert lifecycle invariants.
// ============================================================================
void WeatherRouting::Reset(RouteMapOverlay* ov) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  if (!ov) return;

  wxLogMessage("WeatherRouting::Reset - overlay=%p", ov);

  // Ensure no worker thread is running
  ov->Stop();          // safe even if no thread exists
  ov->DeleteThread();  // ensure thread pointer is null

  // Clear compute/finished state
  ov->ResetFinished();

  // Mark overlay dirty so dependent UI/computed fields refresh on demand
  ov->MarkDirty();

  // Refresh UI state and persist
  UpdateStates();
  SaveXML(m_FileName.GetFullPath());

  // Assert lifecycle invariants
  AssertThreadLifecycleInvariants();
}



// ============================================================================
// WeatherRouting::ResetSelected
// Modern per-route reset: stop and reset only the selected overlays,
// refresh UI state, and assert lifecycle invariants.
// ============================================================================
void WeatherRouting::ResetSelected() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("============================================================");
  wxLogMessage("WeatherRouting::ResetSelected - BEGIN");

  // ---------------------------------------------------------------------
  // 1. Collect selected overlays (modern helper)
  // ---------------------------------------------------------------------
  std::vector<RouteMapOverlay*> overlays = GetSelectedOverlays();

  wxLogMessage("ResetSelected: %zu overlay(s) selected", overlays.size());

  if (overlays.empty()) {
    wxLogMessage("ResetSelected: no routes selected ? nothing to do");
    wxLogMessage("WeatherRouting::ResetSelected - END (no selection)");
    wxLogMessage(
        "============================================================");
    return;
  }

  // ---------------------------------------------------------------------
  // 2. Reset each selected overlay using the canonical per-overlay reset
  // ---------------------------------------------------------------------
  for (auto* ov : overlays) {
    if (!ov) {
      wxLogWarning("ResetSelected: encountered NULL overlay pointer");
      continue;
    }

    wxLogMessage("ResetSelected: invoking Reset() for overlay=%p", ov);
    Reset(ov);
  }

  // ---------------------------------------------------------------------
  // 3. Clear cursor highlight
  // ---------------------------------------------------------------------
  m_positionOnRoute = nullptr;

  // ---------------------------------------------------------------------
  // 4. Refresh UI state
  // ---------------------------------------------------------------------
  UpdateStates();
  SaveXML(m_FileName.GetFullPath());


  // ---------------------------------------------------------------------
  // 5. Assert lifecycle invariants
  // ---------------------------------------------------------------------
  AssertThreadLifecycleInvariants();

  wxLogMessage("WeatherRouting::ResetSelected - END");
  wxLogMessage("============================================================");
}




// ============================================================================
// WeatherRouting::ResetAll
// Modern global reset: stop all overlays, reset compute state, refresh UI,
// and assert lifecycle invariants.
// ============================================================================
void WeatherRouting::ResetAll() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("WeatherRouting::ResetAll - BEGIN");

  // 1. Stop all worker threads
  StopAll();

  // 2. Reset each overlay using the modern lifecycle
  for (auto* wr : m_WeatherRoutes) {
    if (!wr || !wr->routemapoverlay) continue;

    RouteMapOverlay* ov = wr->routemapoverlay;

    ov->ResetFinished();  // clear compute state
    ov->MarkDirty();      // force UI to refresh computed fields
  }

  // 3. Clear cursor highlight
  m_positionOnRoute = nullptr;

  // 4. Refresh UI state
  UpdateStates();
  UpdateDialogs();
  UpdateComputeState();

  // 5. Assert modern lifecycle invariants
  AssertThreadLifecycleInvariants();

  wxLogMessage("WeatherRouting::ResetAll - END");
}




/*********************************************************/
/*   11.Compute Scheduler     */
/*********************************************************/


// OnHideConfigurationTimer
//   Handles delayed hiding of the configuration dialog
//   after computations complete.
// FirstCurrentRouteMap
//   Returns the first RouteMapOverlay in the current
//   selection (or NULL if none).
// CurrentRouteMaps
//   Returns a list of all RouteMapOverlay objects
//   corresponding to the current selection in the UI.
//   If includeUnselected==true, returns ALL overlays.



void WeatherRouting::OnHideConfigurationTimer(wxTimerEvent& event) {
  m_ConfigurationDialog.Hide();
}



// MODERN
RouteMapOverlay* WeatherRouting::FirstCurrentRouteMap() {
  // Find the first selected WeatherRoute in the list control
  long item = m_panel->m_lWeatherRoutes->GetNextItem(-1, wxLIST_NEXT_ALL,
                                                     wxLIST_STATE_SELECTED);

  if (item < 0) return nullptr;

  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
      wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

  return (wr && wr->routemapoverlay) ? wr->routemapoverlay : nullptr;
}


// COMPUTE CURRENT ROUTEMAPS






// ============================================================================
// WeatherRouting::ComputeAllRoutes
// Modern compute entry point: start computation on all overlays.
// No scheduler, no waiting lists, no running lists.
// ============================================================================
// MODERN
void WeatherRouting::ComputeAllRoutes() {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("WeatherRouting::ComputeAllRoutes - BEGIN");

  // 1. Iterate over all overlays
  for (auto* ov : m_RouteMapOverlays) {
    if (!ov) continue;

    WeatherRoute* wr = ov->m_weatherRoute;
    if (!wr) continue;

    // Skip if already running
    if (ov->Running()) {
      wxLogMessage("ComputeAllRoutes: overlay=%p already running", ov);
      continue;
    }

    wxLogMessage("ComputeAllRoutes: starting overlay=%p", ov);

    // Ensure no stale worker thread exists
    ov->Stop();

    // Reset compute state
    wr->ClearComputedFields();
    ov->ResetFinished();
    ov->MarkDirty();

    // Launch computation thread
    wxString error;
    ov->Start(error);
  }

  // 2. Refresh UI state
  UpdateStates();

  // 3. Assert lifecycle invariants
  AssertThreadLifecycleInvariants();

  wxLogMessage("WeatherRouting::ComputeAllRoutes - END");
}




/*********************************************************/
/* 2  ROUTE / OVERLAY DELETION PIPELINE    */
/*********************************************************/
// DeleteRouteMaps
// Safely deletes the given list of RouteMapOverlay objects
// following a modern 4?phase lifecycle:
//   1. Signal all overlays to stop
//   2. Wait for all worker threads to exit
//   3. Remove overlays from scheduler lists
//   4. Remove overlays + WeatherRoute objects
//   5. Rebuild the wxListCtrl from scratch
//   6. UI updates


// ============================================================================
// WeatherRouting::OnDeleteSelected
// Modern delete handler: deletes only the selected routes.
// ============================================================================
// MODERN

void WeatherRouting::OnDeleteSelected(wxCommandEvent& event) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("OnDeleteSelected(): deleting selected routes");

  // Collect selected overlays using the modern selection helper
  std::vector<RouteMapOverlay*> selected = GetSelectedOverlays();
  if (selected.empty()) {
    wxLogMessage("OnDeleteSelected(): no selection");
    return;
  }

  // Convert to std::list for DeleteRouteMaps()
  std::list<RouteMapOverlay*> overlays(selected.begin(), selected.end());

  DeleteRouteMaps(overlays);
}


// ============================================================================
// WeatherRouting::OnDeleteAll
// Modern delete handler: deletes all routes.
// ============================================================================
// MODERN
void WeatherRouting::OnDeleteAll(wxCommandEvent& event) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  wxLogMessage("OnDeleteAll(): deleting all routes");

  // Collect all overlays
  std::list<RouteMapOverlay*> overlays;
  for (auto* wr : m_WeatherRoutes) {
    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  DeleteRouteMaps(overlays);
}



// ============================================================================
// WeatherRouting::DeleteRouteMaps
// Modern batch deletion: delete each overlay using the canonical per-overlay
// deletion path (DeleteRouteMap). No scheduler, no waiting lists, no legacy UI.
//
// Notes:
//  ? DeleteRouteMap(ov) performs the full lifecycle shutdown:
//        Stop() ? DeleteThread() ? remove from lists ? delete WeatherRoute
//        ? rebuild list control ? UpdateStates() ? SaveXML()
//  ? This wrapper simply applies that canonical deletion to a group.
//  ? We keep a final invariant check at the batch boundary.
// ============================================================================
// MODERN

void WeatherRouting::DeleteRouteMaps( const std::list<RouteMapOverlay*>& overlays) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  if (overlays.empty()) return;

  wxLogMessage("WeatherRouting::DeleteRouteMaps - count=%zu", overlays.size());

  // ---------------------------------------------------------------------
  // 1. Apply canonical deletion to each overlay
  //    DeleteRouteMap() handles:
  //      ? stopping worker thread
  //      ? deleting thread object
  //      ? removing WeatherRoute + overlay from all lists
  //      ? rebuilding list control
  //      ? updating UI + saving XML
  // ---------------------------------------------------------------------
  for (auto* ov : overlays) {
    if (!ov) continue;
    DeleteRouteMap(ov);
  }

  // ---------------------------------------------------------------------
  // 2. Final lifecycle invariant check
  //    Ensures no stale threads, no dangling pointers, no partial cleanup.
  // ---------------------------------------------------------------------
  AssertThreadLifecycleInvariants();
}


// ============================================================================
// WeatherRouting::DeleteRouteMap
// Canonical per-overlay deletion. This performs the full, modern lifecycle:
//   ? deterministically stop worker thread
//   ? delete thread object
//   ? remove WeatherRoute + overlay from model + UI
//   ? clear any UI cursor state
//   ? refresh UI + persist XML
//   ? assert lifecycle invariants
//
// Notes:
//   ? No scheduler lists, no legacy flags, no waiting/running queues.
//   ? This is the ONLY correct place to delete a route + overlay.
// ============================================================================
// MODERN
void WeatherRouting::DeleteRouteMap(RouteMapOverlay* ov) {
  if (m_shuttingDown) {
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  }

  if (!ov) return;

  wxLogMessage("WeatherRouting::DeleteRouteMap - overlay=%p", ov);

  // ---------------------------------------------------------------------
  // 1. Find owning WeatherRoute
  //    Modern architecture: WeatherRoute owns exactly one overlay.
  // ---------------------------------------------------------------------
  WeatherRoute* owner = nullptr;
  for (auto* wr : m_WeatherRoutes) {
    if (wr && wr->routemapoverlay == ov) {
      owner = wr;
      break;
    }
  }

  if (!owner) {
    wxLogMessage("DeleteRouteMap: no owning WeatherRoute found for overlay=%p",
                 ov);
    return;
  }

  // ---------------------------------------------------------------------
  // 2. Deterministically stop worker thread
  //    Stop() sets finished flag + joins thread.
  //    DeleteThread() ensures no stale thread pointer remains.
  // ---------------------------------------------------------------------
  ov->Stop();
  ov->DeleteThread();

  // ---------------------------------------------------------------------
  // 3. Remove from UI list control
  //    The list control stores WeatherRoute* as row data.
  // ---------------------------------------------------------------------
  if (m_panel && m_panel->m_lWeatherRoutes) {
    wxListCtrl* list = m_panel->m_lWeatherRoutes;

    long count = list->GetItemCount();
    for (long i = 0; i < count; i++) {
      WeatherRoute* wrItem =
          reinterpret_cast<WeatherRoute*>(wxUIntToPtr(list->GetItemData(i)));

      if (wrItem == owner) {
        list->DeleteItem(i);
        break;
      }
    }
  }

  // ---------------------------------------------------------------------
  // 4. Remove from model list
  // ---------------------------------------------------------------------
  m_WeatherRoutes.remove(owner);

  // ---------------------------------------------------------------------
  // 5. Destroy overlay + route
  //    Order matters: delete overlay first, then route.
  // ---------------------------------------------------------------------
  delete ov;
  owner->routemapoverlay = nullptr;
  delete owner;

  // ---------------------------------------------------------------------
  // 6. Clear any UI cursor highlight referencing this route
  // ---------------------------------------------------------------------
  m_positionOnRoute = nullptr;

  // ---------------------------------------------------------------------
  // 7. Refresh UI + persist
  //    Modern UI pipeline: UpdateStates() + SaveXML()
  // ---------------------------------------------------------------------
  UpdateStates();
  UpdateConfigurations();
  SaveXML(m_FileName.GetFullPath());


  // ---------------------------------------------------------------------
  // 8. Assert lifecycle invariants
  // ---------------------------------------------------------------------
  AssertThreadLifecycleInvariants();
}




/*********************************************************/
/*    13.Batch Routing    */
/*********************************************************/
// GenerateBatch
//   Generates multiple weather routing configurations
//   based on user-defined parameters in the ConfigurationBatchDialog.
// --------------------------------------------------------------
// MODERN
void WeatherRouting::GenerateBatch() {
  // 1. Collect overlays for all *selected* WeatherRoutes
  std::list<RouteMapOverlay*> routemapoverlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay)
      routemapoverlays.push_back(wr->routemapoverlay);
  }

  if (routemapoverlays.empty()) return;

  // 2. Prepare progress dialog and batch timing parameters
  wxProgressDialog* progressdialog = NULL;
  int count = routemapoverlays.size(), c = 0;
  int times = 0;

  wxTimeSpan StartSpan, StartSpacingSpan;
  double days, hours;

  ConfigurationBatchDialog& dlg = m_ConfigurationBatchDialog;
  dlg.m_tStartDays->GetValue().ToDouble(&days);
  StartSpan = wxTimeSpan::Days(days);

  dlg.m_tStartHours->GetValue().ToDouble(&hours);
  StartSpan += wxTimeSpan::Seconds(3600 * hours);

  dlg.m_tStartSpacingDays->GetValue().ToDouble(&days);
  StartSpacingSpan = wxTimeSpan::Days(days);

  dlg.m_tStartSpacingHours->GetValue().ToDouble(&hours);
  StartSpacingSpan += wxTimeSpan::Seconds(3600 * hours);

  if (!StartSpacingSpan.GetSeconds().ToLong()) {
    wxMessageDialog mdlg(this, _("Zero time span forbidden, aborting."),
                         _("Weather Routing"), wxOK | wxICON_ERROR);
    mdlg.ShowModal();
    return;
  }

  wxDateTime StartTime = wxDateTime::Now(), EndTime = StartTime + StartSpan;

  for (wxDateTime start = StartTime; start <= EndTime;
       start += StartSpacingSpan)
    times++;

  int sources = 0;
  for (auto it = dlg.sources.begin(); it != dlg.sources.end(); it++)
    for (auto it2 = (*it)->destinations.begin();
         it2 != (*it)->destinations.end(); it2++)
      sources++;

  count *= sources;
  count *= dlg.m_lBoats->GetCount();

  if (count > 10) {
    progressdialog = new wxProgressDialog(
        _("Batch configuration"), _("Weather Routing"), count, this,
        wxPD_CAN_ABORT | wxPD_ELAPSED_TIME | wxPD_REMAINING_TIME);
  }

  // 3. Main batch generation loop
  for (auto* ov : routemapoverlays) {
    RouteMapConfiguration configuration = ov->GetConfiguration();

    EndTime = configuration.StartTime + StartSpan;

    for (; configuration.StartTime <= EndTime;
         configuration.StartTime += StartSpacingSpan) {
      for (auto it = dlg.sources.begin(); it != dlg.sources.end(); it++) {
        configuration.Start = (*it)->Name;

        for (auto it2 = (*it)->destinations.begin();
             it2 != (*it)->destinations.end(); it2++) {
          configuration.End = (*it2)->Name;

          for (unsigned int boatindex = 0; boatindex < dlg.m_lBoats->GetCount();
               boatindex++) {
            configuration.boatFileName = dlg.m_lBoats->GetString(boatindex);

            for (int windstrength = dlg.m_sWindStrengthMin->GetValue();
                 windstrength <= dlg.m_sWindStrengthMax->GetValue();
                 windstrength += dlg.m_sWindStrengthStep->GetValue()) {
              configuration.WindStrength = windstrength / 100.0;

              AddConfiguration(configuration);

              WeatherRoute* newWR = m_WeatherRoutes.back();
              RouteMapOverlay* newOV = newWR->routemapoverlay;

              newOV->LoadBoat();
              configuration = newOV->GetConfiguration();

              if (progressdialog && !progressdialog->Update(c++)) goto abort;
            }
          }
        }
      }
    }
  }

abort:
  // 4. Cleanup: delete the overlays used for batch generation
  for (auto* ov : routemapoverlays) DeleteRouteMap(ov);

  // 5. Refresh UI and persist
  UpdateStates();
  UpdateDialogs();
  UpdateConfigurations();
  SaveXML(m_FileName.GetFullPath());

  delete progressdialog;
}



/*********************************************************/
/*    14.Export / Track / Route Saving    */
/*********************************************************/
// OnSaveAsTrack
//   Saves the selected RouteMapOverlay as a GPX track.
// OnSaveAllAsTracks
//    Saves all RouteMapOverlay objects as GPX tracks.
// OnSaveAsRoute
//   Saves the selected RouteMapOverlay as a GPX route.
// ShowRouteSaveOptionsDialog
//   Shows a dialog to get route save options from the user.
//   and returns the selected options.
// OnExportRouteAsGPX
//   Currently disabled. Placeholder for future functionality.
// SaveRouteOptions
//   Struct holding route save options.
// SaveAsTrack
//   Saves the given RouteMapOverlay as a GPX track.
//   Applies simplification if requested. Prompts for filename.
// SaveAsRoute
//   Saves the given RouteMapOverlay as a GPX route.
// SaveSimplifiedRouteAsGPX
//   Saves a simplified version of the given RouteMapOverlay
//   as a GPX route, applying the specified maximum time penalty.
//   Prompts for filename.

// MODERN
void WeatherRouting::OnSaveAsTrack(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  if (overlays.empty()) return;

  // ---------------------------------------------------------------------
  // 2. Save each selected overlay as a track
  // ---------------------------------------------------------------------
  for (auto* ov : overlays) {
    if (!ov) continue;

    SaveAsTrack(*ov);
  }
}


// MODERN
void WeatherRouting::OnSaveAllAsTracks(wxCommandEvent& event) {
  const int count = m_panel->m_lWeatherRoutes->GetItemCount();

  for (int i = 0; i < count; i++) {
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));

    if (!wr || !wr->routemapoverlay) continue;

    SaveAsTrack(*wr->routemapoverlay);
  }
}

// MODERN
void WeatherRouting::OnSaveAsRoute(wxCommandEvent& event) {
  // 1. Collect overlays for all *selected* WeatherRoutes
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  // 2. If nothing is selected, warn the user
  if (overlays.empty()) {
    wxMessageDialog mdlg(this, _("No weather route selected"),
                         _("Weather Routing"), wxOK | wxICON_WARNING);
    mdlg.ShowModal();
    return;
  }

  // 3. Saving logic continues below (your existing SaveAsRoute handler)
}

// MODERN   Disable stub handler for future route export functionality
void WeatherRouting::OnExportRouteAsGPX(wxCommandEvent & event) {
    wxMessageDialog mdlg(this, _("Export Route As GPX is currently disabled."),
                         _("Weather Routing"), wxOK | wxICON_INFORMATION);
    mdlg.ShowModal();
}

// MODERN
WeatherRouting::SaveRouteOptions
  WeatherRouting::ShowRouteSaveOptionsDialog() {
    SaveRouteOptions options;
    options.dialogAccepted = false;

    // Create a dialog with save options.
    wxDialog dlg(this, wxID_ANY, _("Save Route Options"), wxDefaultPosition,
                 wxDefaultSize);
    wxBoxSizer* mainSizer = new wxBoxSizer(wxVERTICAL);

    // Add simplify route option.
    wxCheckBox* cbSimplifyRoute =
        new wxCheckBox(&dlg, wxID_ANY, _("Simplify Route (experimental)"));
    cbSimplifyRoute->SetValue(true);
    mainSizer->Add(cbSimplifyRoute, 0, wxALL | wxEXPAND, 5);

    // Create a panel for simplification options that will be shown/hidden.
    wxPanel* simplifyPanel = new wxPanel(&dlg, wxID_ANY);
    wxBoxSizer* simplifyPanelSizer = new wxBoxSizer(wxVERTICAL);

    // Add time penalty control.
    wxStaticText* timePenaltyLabel =
        new wxStaticText(simplifyPanel, wxID_ANY, _("Maximum Time Loss (%)"));
    simplifyPanelSizer->Add(timePenaltyLabel, 0, wxALL | wxEXPAND, 5);

    // Create a horizontal sizer for the spinner and text display
    wxBoxSizer* penaltySizer = new wxBoxSizer(wxHORIZONTAL);

    // Add a spinner control for precise 0.1% increments
    wxSpinCtrlDouble* spinnerTimePenalty = new wxSpinCtrlDouble(
        simplifyPanel, wxID_ANY, wxEmptyString, wxDefaultPosition,
        wxDefaultSize, wxSP_ARROW_KEYS, 0.0, 20.0, 5.0, 0.1);
    spinnerTimePenalty->SetDigits(1);  // Show one decimal place

    penaltySizer->Add(spinnerTimePenalty, 1, wxALL | wxEXPAND, 5);

    // Add percentage text
    wxStaticText* percentLabel =
        new wxStaticText(simplifyPanel, wxID_ANY, _("%"));
    penaltySizer->Add(percentLabel, 0, wxALL | wxALIGN_CENTER_VERTICAL, 5);

    simplifyPanelSizer->Add(penaltySizer, 0, wxALL | wxEXPAND, 5);

    simplifyPanel->SetSizer(simplifyPanelSizer);
    mainSizer->Add(simplifyPanel, 0, wxALL | wxEXPAND, 5);

    wxStdDialogButtonSizer* buttonSizer = new wxStdDialogButtonSizer();
    buttonSizer->AddButton(new wxButton(&dlg, wxID_OK, _("Save")));
    buttonSizer->AddButton(new wxButton(&dlg, wxID_CANCEL));
    buttonSizer->Realize();

    mainSizer->Add(buttonSizer, 0, wxALL | wxEXPAND, 10);

    dlg.SetSizer(mainSizer);
    mainSizer->Fit(&dlg);
    dlg.Centre();

    // Setup checkbox event to show/hide simplification panel.
    cbSimplifyRoute->Bind(
        wxEVT_CHECKBOX, [simplifyPanel, &dlg, mainSizer](wxCommandEvent&) {
          simplifyPanel->Show(simplifyPanel->IsShown() ? false : true);
          mainSizer->Fit(&dlg);
        });

    if (dlg.ShowModal() == wxID_OK) {
      options.dialogAccepted = true;
      options.simplifyRoute = cbSimplifyRoute->GetValue();
      options.maxTimePenalty = spinnerTimePenalty->GetValue() / 100.0;
    }
    return options;
  }

// MODERN
  void WeatherRouting::SaveAsTrack(RouteMapOverlay & routemapoverlay) {
    std::list<PlotData> plotdata = routemapoverlay.GetPlotData(false);

    if (plotdata.empty()) {
      wxMessageDialog mdlg(this, _("Empty routing, nothing to save\n"),
                           _("Weather Routing"), wxOK | wxICON_WARNING);
      mdlg.ShowModal();
      return;
    }

    PlugIn_Track* newPath = new PlugIn_Track;
    wxDateTime display_time = routemapoverlay.StartTime();
    if (GetSettingsDialog().m_cbUseLocalTime->GetValue())
      display_time = display_time.FromUTC();

    newPath->m_NameString =
        _("Weather Route ") + " (" + display_time.Format("%x %H:%M") + ")";

    // XXX double check time is really end time, not start time off by one.
    RouteMapConfiguration c = routemapoverlay.GetConfiguration();
    newPath->m_StartString = c.Start;
    newPath->m_EndString = c.End;
    newPath->m_GUID = GetNewGUID();

    for (auto const& it : plotdata) {
      PlugIn_Waypoint* newPoint = new PlugIn_Waypoint(
          it.lat, heading_resolve(it.lon), "circle", _("Weather Route Point"));

      newPoint->m_CreateTime = it.time;
      newPath->pWaypointList->Append(newPoint);
    }

// last point, missing if config didn't succeed
    const Position* p = routemapoverlay.GetDestinationPosition();
    if (p) {
      PlugIn_Waypoint* newPoint =
          new PlugIn_Waypoint(p->lat, heading_resolve(p->lon), "circle",
                              _("Weather Route Destination"));
      newPoint->m_CreateTime = routemapoverlay.EndTime();
      newPath->pWaypointList->Append(newPoint);
    }

    AddPlugInTrack(newPath);
    // not done PlugIn_Track DTOR
    newPath->pWaypointList->DeleteContents(true);
    newPath->pWaypointList->Clear();

    delete newPath;

    GetParent()->Refresh();

    wxMessageDialog mdlg(
        this,
        _("Routing has been saved as a track in the 'Route and "
          "Mark' Manager\n"),
        _("Weather Routing"), wxOK);
    mdlg.ShowModal();
  }


// MODERN
  void WeatherRouting::SaveAsRoute(RouteMapOverlay & routemapoverlay) {
    std::list<PlotData> plotdata = routemapoverlay.GetPlotData(false);

    if (plotdata.empty()) {
      wxMessageDialog mdlg(this, _("Empty routing, nothing to save\n"),
                           _("Weather Routing"), wxOK | wxICON_WARNING);
      mdlg.ShowModal();
      return;
    }

    PlugIn_Route_Ex* newRoute = new PlugIn_Route_Ex();
    wxDateTime display_time = routemapoverlay.StartTime();
    if (GetSettingsDialog().m_cbUseLocalTime->GetValue())
      display_time = display_time.FromUTC();

    newRoute->m_NameString =
        _("Weather Route ") + " (" + display_time.Format("%x %H:%M") + ")";

    RouteMapConfiguration c = routemapoverlay.GetConfiguration();
    newRoute->m_StartString = c.Start;
    newRoute->m_EndString = c.End;
    newRoute->m_isVisible = true;
    newRoute->m_GUID = GetNewGUID();

    for (auto const& it : plotdata) {
      PlugIn_Waypoint_Ex* newPoint = new PlugIn_Waypoint_Ex(
          it.lat, heading_resolve(it.lon), "circle", _("Weather Route Point"));
      // newPoint->m_PlannedSpeed = it.sog;
      newPoint->m_CreateTime = it.time;
      newRoute->pWaypointList->Append(newPoint);
    }

// last point, missing if config didn't succeed
    const Position* p = routemapoverlay.GetDestinationPosition();
    if (p) {
      PlugIn_Waypoint_Ex* newPoint =
          new PlugIn_Waypoint_Ex(p->lat, heading_resolve(p->lon), "circle",
                                 _("Weather Route Destination"));
      newPoint->m_CreateTime = routemapoverlay.EndTime();
      newRoute->pWaypointList->Append(newPoint);
    }


    AddPlugInRouteEx(newRoute);
    // Clean up waypoint list (ownership transferred to OpenCPN)
    newRoute->pWaypointList->DeleteContents(true);
    newRoute->pWaypointList->Clear();

    delete newRoute;

    GetParent()->Refresh();

    wxMessageDialog mdlg(
        this,
        _("Routing has been saved as a route in the 'Route and "
          "Mark' Manager\n"),
        _("Weather Routing"), wxOK);
    mdlg.ShowModal();
  }



  // MODERN

//  void WeatherRouting::SaveSimplifiedRouteAsGPX(
//      const RouteMapOverlay& ov, const std::list<Position*>& simplifiedRoute,
//      const wxString& filename);



/*********************************************************/
/*    15. UI Update Pipeline (Unified, Deterministic   */
/*********************************************************/
/*
Update, RebuidList  Reset(overlay)- Key Roles
Reset(overlay)
    Clears the a RouteMapOverlay state
ResetSelected()
    Stops and clears only the selected RouteMapOverlay   objects, then
    updates their states in the UI.
ResetAll ()
    Stops and clears all RouteMapOverlay objects,
    then updates their states in the UI.
OnResetSelected()
    The event handler that calls ResetSelected().
OnSaveAsTrack()
    is the event handler that saves the selected routes as tracks.
ShowRouteSaveOptionsDialog()
   Shows a dialog to get route saving   options from the user.
OnSaveAsRoute()
   Event handler that saves the selected routes as routes. T
UI Related Functions:
   RefreshUI()
      refreshes the entire UI, including list controls and dialogs
   UpdateStates()
      walks all WeatherRoute objects, calls WeatherRoute::Update(stateonly=true),
      updates the list control row RebuidList()
      rebuilds the entire wxListCtrl that displays all routes.
      Heavier than UpdateStates()
   Rebuild
      also repopulates the whole table,refreshes the UI UpdateRouteMap(overlay)
      updates only the specified  RouteMapOverlay   */


//------------------------------------------
//   15.1 Core
//------------------------------------------

// UpdateCurrentConfigurations
  // Updates the current configurations in the UI.
  // Used in multiple places to refresh the list control and related dialogs
  // after changes.
  // MODERN

void WeatherRouting::UpdateCurrentConfigurations() {
    wxLogMessage("WeatherRouting::UpdateCurrentConfigurations()");

    if (m_shuttingDown) {
      wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
      return;
    }

    // Rebuild the WeatherRoutes list control
    if (m_panel && m_panel->m_lWeatherRoutes) {
      wxListCtrl* list = m_panel->m_lWeatherRoutes;
      list->DeleteAllItems();

      long index = 0;
      for (auto* wr : m_WeatherRoutes) {
        wxListItem item;
        item.SetId(index);
        item.SetData(reinterpret_cast<wxUIntPtr>(wr));
        list->InsertItem(item);
        UpdateItem(index, true);
        index++;
      }
    }

    // Modern UI update pipeline
    UpdateAllItems(true);
    UpdateDialogs();
    UpdateComputeState();

    if (GetParent()) GetParent()->Refresh();
  }

// MODERN
  void WeatherRouting::RefreshUI() {
    // 0. Sanity check: Ensure we have a panel and list control to refresh
    if (!m_panel || !m_panel->m_lWeatherRoutes) return;

    // 1. Refresh the entire routing table
    UpdateAllItems(true);

    // 2. Update all open dialogs (Statistics, Report, Plot)
    UpdateDialogs();

    // 3. Update compute-state UI
    UpdateComputeState();

    // 4. Refresh the main panel (list control + controls)
    m_panel->Refresh();

    // 5. Refresh the Routing Table panel (if present)
    if (m_RoutingTablePanel) {
      static_cast<RoutingTablePanel*>(m_RoutingTablePanel)->PopulateTable();
    }

    // 6. Trigger a parent window refresh
    if (GetParent()) GetParent()->Refresh();
  }



//------------------------------------------
//   15.2 Per?Route
//------------------------------------------

/* THE HEART OF THE WEATHER ROUTING ENGINE                         *
 * Promotes overelays from waiting to running, checks for completed threads *
 * Starts new worker threads as needed Monitors thread completion *
 * Requests Grib data as needed for running threads         *
 * Updates UI state as needed                         *
 * Refreshes  dialogs, route map dislay and statistics periodically      *
 * Detects when all routes are finished, stops the timer cleanly      *
 * Runs the scheduler, moves routes between lists, checks thread progress.
 * Keeps the UI updated as routes progress.
 * UI updates are deterministic and centralized here.
 * Everything else just marks overlays dirty and lets this
 * scheduler handle the rest.
 * Don't call UpdateRouteMap() directly, it's called from here as needed.
 * Keeps the UI in sync with the model.
 */ 

// UpdateRouteMap
//   Updates only the specified RouteMapOverlay in the wxListCtrl.
//   Called when a RouteMapOverlay changes state or completes computation.
//   Efficient targeted update to keep the UI in sync with the model.
//   Does not rebuild the entire list, only the affected row.
//   Used by the computation scheduler to refresh the UI as routes progress.
//   Searches for the WeatherRoute associated with the given RouteMapOverlay,
//   then calls UpdateItem() to refresh that row in the wxListCtrl.
//   If the RouteMapOverlay is not found, does nothing.
//   This function is more efficient than UpdateAllItems() when only one
//   route needs to be updated.
//   Note: This function assumes that each RouteMapOverlay is unique
//   and associated with only one WeatherRoute.
// 
// UpdateItem  See 9.WeatherRoute::Update(Model Update Logic
//   Updates a single row in the wxListCtrl based on the WeatherRoute data.
// UpdateAllItems

// UpdateSelectedItem
//   Updates only the selected rows in the wxListCtrl.
//------------------------------------------

// MODERN

void WeatherRouting::UpdateRouteMap(RouteMapOverlay* routemapoverlay) {
    if (!m_panel || !m_panel->m_lWeatherRoutes) return;

    wxListCtrl* lc = m_panel->m_lWeatherRoutes;

    for (int i = 0; i < lc->GetItemCount(); i++) {
      WeatherRoute* weatherroute =
          reinterpret_cast<WeatherRoute*>(wxUIntToPtr(lc->GetItemData(i)));

      if (weatherroute && weatherroute->routemapoverlay == routemapoverlay) {
        weatherroute->Update(this, false);  // modern call
        UpdateItem(i, false);               // fast UI refresh
        return;
      }
    }
  }




// MODERN
  void WeatherRouting::UpdateSelectedItems(bool changed) {
    if (!m_panel || !m_panel->m_lWeatherRoutes) return;

    wxListCtrl* lc = m_panel->m_lWeatherRoutes;

    long item = -1;

    // Iterate through all selected rows
    for (;;) {
      item = lc->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
      if (item == -1) break;

      // Update the selected row
      UpdateItem(item, changed);
    }
  }



//------------------------------------------
//   15.3 Column Helpers
//------------------------------------------
// SetColumn
//   Sets the text of a specific column in the wxListCtrl for a given row.
// ClearComputedColumns
//   Clears all computed columns for a given row in the wxListCtrl.
// UpdateStaticColumns
//   Updates the static columns (Boat, StartType, Start, End, Visible) for
//   a given row based on the WeatherRoute data.
// UpdateComputedColumns
//   Updates the computed columns (AvgSpeed, MaxSpeed, etc.) for a given row
//   based on the WeatherRoute data.
//------------------------------------------


void WeatherRouting::SetColumn(long index, int col, const wxString& value) {
  if (columns[col] >= 0)
    m_panel->m_lWeatherRoutes->SetItem(index, columns[col], value);
}

void WeatherRouting::ClearComputedColumns(long index) {
  SetColumn(index, STARTTIME, "");
  SetColumn(index, ENDTIME, "");
  SetColumn(index, TIME, "");
  SetColumn(index, DISTANCE, "");
  SetColumn(index, AVGSPEED, "");
  SetColumn(index, MAXSPEED, "");
  SetColumn(index, AVGSPEEDGROUND, "");
  SetColumn(index, MAXSPEEDGROUND, "");
  SetColumn(index, AVGWIND, "");
  SetColumn(index, MAXWIND, "");
  SetColumn(index, MAXWINDGUST, "");
  SetColumn(index, AVGCURRENT, "");
  SetColumn(index, MAXCURRENT, "");
  SetColumn(index, AVGSWELL, "");
  SetColumn(index, MAXSWELL, "");
  SetColumn(index, UPWINDPERCENTAGE, "");
  SetColumn(index, PORTSTARBOARD, "");
  SetColumn(index, TACKS, "");
  SetColumn(index, JIBES, "");
  SetColumn(index, SAILPLANCHANGES, "");
  SetColumn(index, COMFORT, "");
}


void WeatherRoute::ClearComputedFields() {
  // Currently nothing to clear in the slimmed-down model.
}


/*
void WeatherRoute::ClearComputedFields() {
  // These are all derived / computed presentation fields.
  Distance.clear();
  AvgSpeed.clear();
  MaxSpeed.clear();
  AvgSpeedGround.clear();
  MaxSpeedGround.clear();
  AvgWind.clear();
  MaxWind.clear();
  MaxWindGust.clear();
  AvgCurrent.clear();
  MaxCurrent.clear();
  AvgSwell.clear();
  MaxSwell.clear();
  UpwindPercentage.clear();
  PortStarboard.clear();
  Tacks.clear();
  Jibes.clear();
  SailPlanChanges.clear();
  Comfort.clear();
  Time.clear();
  EndTime.clear();
  State.clear();
  StateChanged = false;
}
*/

//------------------------------------------------------------------
// UpdateStaticColumns sets the non-computed columns based on the WeatherRoute
// data. These columns typically include information that doesn't change during
// computation, This includes the boat name, start type, start and end
// locations, and visibility. This function is called when a new route is added
// or when the static information of a route changes. It ensures that the UI
// reflects the current state of the WeatherRoute's static properties
//------------------------------------------------------------------


// MODERN
void WeatherRouting::UpdateStaticColumns(long index, WeatherRoute* wr) {
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* list = m_panel->m_lWeatherRoutes;

  // Visible icon
  if (columns[VISIBLE] >= 0) {
    list->SetItemImage(index, wr->routemapoverlay->m_bEndRouteVisible ? 0 : -1);
  }

  SetColumn(index, BOAT, wxFileName(wr->BoatFilename).GetName());
  SetColumn(index, STARTTYPE, wr->StartType);
  SetColumn(index, START, wr->Start);
  SetColumn(index, END, wr->End);
}


// MODERN

void WeatherRouting::UpdateComputedColumns(long index, WeatherRoute* wr) {
  SetColumn(index, AVGSPEED, wr->AvgSpeed);
  SetColumn(index, MAXSPEED, wr->MaxSpeed);
  SetColumn(index, AVGSPEEDGROUND, wr->AvgSpeedGround);
  SetColumn(index, MAXSPEEDGROUND, wr->MaxSpeedGround);
  SetColumn(index, AVGWIND, wr->AvgWind);
  SetColumn(index, MAXWIND, wr->MaxWind);
  SetColumn(index, MAXWINDGUST, wr->MaxWindGust);
  SetColumn(index, AVGCURRENT, wr->AvgCurrent);
  SetColumn(index, MAXCURRENT, wr->MaxCurrent);
  SetColumn(index, AVGSWELL, wr->AvgSwell);
  SetColumn(index, MAXSWELL, wr->MaxSwell);
  SetColumn(index, UPWINDPERCENTAGE, wr->UpwindPercentage);
  SetColumn(index, PORTSTARBOARD, wr->PortStarboard);
  SetColumn(index, TACKS, wr->Tacks);
  SetColumn(index, JIBES, wr->Jibes);
  SetColumn(index, SAILPLANCHANGES, wr->SailPlanChanges);
  SetColumn(index, COMFORT, wr->Comfort);
}



//------------------------------------------
//   16. Miscellaneous UI
//------------------------------------------
// Show
//   Shows or hides all plugin dialogs and menu items.
//   When hiding, saves the current visibility state of each dialog.
//   When showing, restores each dialog to its previous visibility state.
//   Also hides the routing table panel if it exists.
//   Returns the result of the base class Show() method.
// CopyDataFiles
//   Recursively copies data files from one directory to another.
//   Takes care to create destination directories as needed.
//   maintains the directory structure.
//   and logs each file copy operation.
// StopAllRoutes -deprecated-
//   Stops all active route computations.
//------------------------------------------

bool WeatherRouting::Show(bool show) {
  m_weather_routing_pi.ShowMenuItems(show);

if (show) {
    m_ConfigurationDialog.Show(m_bShowConfiguration);
    m_ConfigurationBatchDialog.Show(m_bShowConfigurationBatch);
    m_SettingsDialog.Show(m_bShowSettings);
    m_StatisticsDialog.Show(m_bShowStatistics);
    m_ReportDialog.Show(m_bShowReport);
    m_PlotDialog.Show(m_bShowPlot);
    m_FilterRoutesDialog.Show(m_bShowFilter);
    m_RoutePositionDialog.Show(m_bShowRoutePosition);
  } else {
    // Save + hide dialogs
    m_bShowConfiguration = m_ConfigurationDialog.IsShown();
    m_ConfigurationDialog.Hide();

    m_bShowConfigurationBatch = m_ConfigurationBatchDialog.IsShown();
    m_ConfigurationBatchDialog.Hide();

    m_bShowSettings = m_SettingsDialog.IsShown();
    m_SettingsDialog.Hide();

    m_bShowStatistics = m_StatisticsDialog.IsShown();
    m_StatisticsDialog.Hide();

    m_bShowReport = m_ReportDialog.IsShown();
    m_ReportDialog.Hide();

    m_bShowPlot = m_PlotDialog.IsShown();
    m_PlotDialog.Hide();

    m_bShowFilter = m_FilterRoutesDialog.IsShown();
    m_FilterRoutesDialog.Hide();

    m_bShowRoutePosition = m_RoutePositionDialog.IsShown();
    m_RoutePositionDialog.Hide();

    // Do NOT touch AUI panes here. // AUI owns visibility of the
    // RoutingTablePanel.
    // Hide routing table panel
  //  if (m_RoutingTablePanel) {
  //    wxAuiManager* mgr = ::GetFrameAuiManager();
  //    wxAuiPaneInfo& pane = mgr->GetPane(m_RoutingTablePanel);
  //    if (pane.IsOk() && pane.IsShown()) pane.Hide();
  //    mgr->Update();
  //  }

  }
  return WeatherRoutingBase::Show(show);
}



void WeatherRouting::CopyDataFiles(wxString from, wxString to) {
  if (from[from.Len() - 1] != '\\' && from[from.Len() - 1] != '/')
    from += wxFILE_SEP_PATH;
  if (to[to.Len() - 1] != '\\' && to[to.Len() - 1] != '/')
    to += wxFILE_SEP_PATH;

  if (!wxDirExists(to))
    wxFileName::Mkdir(to, wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL);

  wxDir dir(from);
  wxString next = wxEmptyString;
  bool b = dir.GetFirst(&next);
  while (b) {
    const wxString fileFrom = from + next;
    const wxString fileTo = to + next;
    if (wxDirExists(fileFrom))
      CopyDataFiles(fileFrom, fileTo);
    else {
      wxLogMessage("WeatherRouting copy file: " + fileFrom + " to " + fileTo);
      wxCopyFile(fileFrom, fileTo);
    }
    b = dir.GetNext(&next);
  }
}


/* ************************************************************************
 *   End of WeatherRouting.cpp
 * ***********************************************************************
 */
