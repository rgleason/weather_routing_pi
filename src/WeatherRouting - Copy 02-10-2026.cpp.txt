
/***************************************************************************
 *   Copyright (C) 2016 by Sean D'Epagnier                                 *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
 ***************************************************************************/


// Whenever positions  change  m_PositionPanel->PopulatePositions();
// Whenever routes change  m_RouteMapPanel->PopulateRoutes();


#include <wx/wx.h>
#include <wx/aui/aui.h>
#include <wx/imaglist.h>
#include <wx/progdlg.h>
#include <wx/dir.h>
#include <wx/log.h>
#include <wx/glcanvas.h>

#include <stdlib.h>
#include <math.h>
#include <cmath>
#include <time.h>
#include <algorithm>

#include "Utilities.h"
#include "Boat.h"
#include "BoatDialog.h"
#include "RouteMapOverlay.h"
#include "weather_routing_pi.h"
#include "WeatherRouting.h"
#include "RouteSimplifier.h"
#include "AboutDialog.h"
#include "icons.h"
#include "navobj_util.h"
#include "ocpn_plugin.h"
#include "Position.h"
#include "tinyxml.h"
#include "MemoryStatusDialog.h"

// Declare the custom event for route map updates
// This event is used by RouteMapOverlay threads to notify WeatherRouting of
// progress. it is a thread-safe event and can be sent from any thread. The
// event handler.  Globally defined event type that worker threads can post and
// the WeatherRouting can Recieve. It is in the heart of the thread to UI pipeline.
// Also the main thread event handler for this event is the main point
// where the UI gets updated based on background thread progress, so it is a
// critical part of the plugin's architecture.

wxDEFINE_EVENT(EVT_ROUTEMAP_UPDATE, wxThreadEvent);


// Column names
const wxString WeatherRouting::column_names[NUM_COLS] = {_("Visible"),
                                                         _("Boat"),
                                                         _("Start Type"),
                                                         _("Start"),
                                                         _("Start Time"),
                                                         _("End"),
                                                         _("End Time"),
                                                         _("Time"),
                                                         _("Distance"),
                                                         _("Avg Speed"),
                                                         _("Max Speed"),
                                                         _("Avg Speed Ground"),
                                                         _("Max Speed Ground"),
                                                         _("Avg Wind"),
                                                         _("Max Wind"),
                                                         _("Max Wind Gust"),
                                                         _("Avg Current"),
                                                         _("Max Current"),
                                                         _("Avg Swell"),
                                                         _("Max Swell"),
                                                         _("Upwind Percentage"),
                                                         _("Port Starboard"),
                                                         _("Tacks"),
                                                         _("Jibes"),
                                                         _("Sail Plan Changes"),
                                                         _("Comfort"),
                                                         _("State")};

/**
 * Used for NEflag argument to toSDMM_Plugin function from ocpn_plugin.h.
 * @todo Should probably be declared there instead, and probably be a boolean.
 */
enum NEflag {
  LAT = 1,
  LON = 2,
};

/**
 * Used for precision argument to toSDMM_Plugin function from ocpn_plugin.h.
 **/
enum Precision {
  LO = 0,
  HI = 1,
};

/* XPM */
static const char* eye[] = {"20 20 7 1",
                            ". c none",
                            "# c #000000",
                            "a c #333333",
                            "b c #666666",
                            "c c #999999",
                            "d c #cccccc",
                            "e c #ffffff",
                            "....................",
                            "....................",
                            "....................",
                            "....................",
                            ".......######.......",
                            ".....#aabccb#a#.....",
                            "....#deeeddeebcb#...",
                            "..#aeeeec##aceaec#..",
                            ".#bedaeee####dbcec#.",
                            "#aeedbdabc###bcceea#",
                            ".#bedad######abcec#.",
                            "..#be#d######dadb#..",
                            "...#abac####abba#...",
                            ".....##acbaca##.....",
                            ".......######.......",
                            "....................",
                            "....................",
                            "....................",
                            "....................",
                            "...................."};



WeatherRoute::WeatherRoute(WeatherRouting* parent)
    : m_parent(parent),
      routemapoverlay(new RouteMapOverlay(parent))
{
}


WeatherRoute::~WeatherRoute() { delete routemapoverlay; }

static int sortcol, sortorder = 1;
// sort callback. Sort by body.
#if wxCHECK_VERSION(2, 9, 0)
int wxCALLBACK SortWeatherRoutes(wxIntPtr item1, wxIntPtr item2, wxIntPtr list)
#else
int wxCALLBACK SortWeatherRoutes(long item1, long item2, long list)
#endif
{
  wxListCtrl* lc = (wxListCtrl*)list;

  wxListItem it1, it2;

  it1.SetId(lc->FindItem(-1, item1));
  it1.SetColumn(sortcol);

  it2.SetId(lc->FindItem(-1, item2));
  it2.SetColumn(sortcol);

  lc->GetItem(it1);
  lc->GetItem(it2);

  return sortorder * it1.GetText().Cmp(it2.GetText());
}


//==============================================================
// CONSTRUCTOR  weatherrouting
//==============================================================

WeatherRouting::WeatherRouting(wxWindow* parent, weather_routing_pi& plugin)
    : WeatherRoutingBase(parent),
      m_weather_routing_pi(plugin),
      m_ConfigurationDialog(*this),
      m_ConfigurationBatchDialog(this),
      m_CursorPositionDialog(this),
      m_RoutePositionDialog(this),
      m_BoatDialog(*this),
      m_SettingsDialog(this),
      m_StatisticsDialog(this),
      m_ReportDialog(*this),
      m_PlotDialog(*this),
      m_FilterRoutesDialog(this),
      m_RoutingTablePanel(nullptr),
      m_panel(NULL),
      m_bShowConfiguration(false), // ADD THIS
      m_bShowConfigurationBatch(false),
      m_bShowSettings(false),
      m_bShowStatistics(false),
      m_bShowReport(false),
      m_bShowPlot(false),
      m_bShowFilter(false),
      m_bShowRoutePosition(false)
{
  wxLogMessage("WR: ctor START");

  wxLogMessage("WR: before LoadConfigurationAndData");
  // Load configuration, settings, etc.
  LoadConfigurationAndData();
  wxLogMessage("WR: after LoadConfigurationAndData");

  // Create the overlay FIRST before calling InitializUI
  // since some UI elements depend on it(e.g.RoutePositionDialog)
  m_pRouteMapOverlay = new RouteMapOverlay(this);

  wxLogMessage("WR: before InitializeUI");
  // Build the UI
  InitializeUI();
  wxLogMessage("WR: after InitializeUI");

  wxLogMessage("WR: before BindEvents");
  // Bind events AFTER panels exist
  BindEvents();
  wxLogMessage("WR: after BindEvents");

  // Any remaining initialization
  m_tAutoSaveXML.SetOwner(this);
  wxLogMessage("WR: ctor END");
}


//==============================================================
// LOAD CONFIGURATION AND PLUGIN DATA AND USER SETTINGS
//==============================================================

void WeatherRouting::LoadConfigurationAndData() {
  wxFileConfig* pConf = GetOCPNConfigObject();
  pConf->SetPath("/PlugIns/WeatherRouting");

  // ---------------------------------------------------------
  // 1. Determine standard paths
  // ---------------------------------------------------------
  m_default_configuration_path =
      weather_routing_pi::StandardPath() + "WeatherRoutingConfiguration.xml";

  wxString packagedCfg = GetPluginDataDir("weather_routing_pi") +
                         "/data/WeatherRoutingConfiguration.xml";

  // ---------------------------------------------------------
  // 2. Ensure boats/ and polars/ directories exist
  // ---------------------------------------------------------
  wxString boatsdir = weather_routing_pi::StandardPath() + "/boats";
  wxString polarsdir = weather_routing_pi::StandardPath() + "/polars";

  bool forceCopyBoats = !wxFileName::DirExists(boatsdir);
  bool forceCopyPolars = !wxFileName::DirExists(polarsdir);

  wxFileName fn;
  fn.Mkdir(weather_routing_pi::StandardPath(), wxS_DIR_DEFAULT,
           wxPATH_MKDIR_FULL);
  fn.Mkdir(boatsdir, wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL);
  fn.Mkdir(polarsdir, wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL);

  // ---------------------------------------------------------
  // 3. Copy boats/polars if directories were missing
  // ---------------------------------------------------------
  if (forceCopyBoats)
    CopyDataFiles(GetPluginDataDir("weather_routing_pi") + "/data/boats",
                  boatsdir);

  if (forceCopyPolars)
    CopyDataFiles(GetPluginDataDir("weather_routing_pi") + "/data/polars",
                  polarsdir);

  // ---------------------------------------------------------
  // 4. Handle versioned data updates (boats, polars, examples)
  // ---------------------------------------------------------
  int confVersion;
  pConf->Read("ConfigVersion", &confVersion, 0);

#ifndef __OCPN__ANDROID__
  int currentVersion = PLUGIN_VERSION_MAJOR * 100 + PLUGIN_VERSION_MINOR;

  if (confVersion < currentVersion) {
    wxString title = _("New or updated data available");
    wxString message = _(
        "A new version of the Weather Route plugin has been installed.\n\n"
        "\"Import new boats and polars\" will overwrite the standard boats\n"
        "and polars with newer data. If you have modified this data and not\n"
        "changed the names, your modifications will be overwritten.\n\n"
        "\"Import example configurations\" will overwrite your route\n"
        "configurations with a sample set showing how WeatherRouting works.\n");

    wxString choices[2] = {_("Import new boats and polars"),
                           _("Import example configurations")};

    wxMultiChoiceDialog dlg(this, message, title, 2, choices);

    // First-time users: select both options by default
    if (confVersion == 0) {
      wxArrayInt sel;
      sel.Add(0);
      sel.Add(1);
      dlg.SetSelections(sel);
    }

    if (dlg.ShowModal() == wxID_OK) {
      wxArrayInt result = dlg.GetSelections();

      for (size_t i = 0; i < result.GetCount(); i++) {
        if (result[i] == 0) {
          CopyDataFiles(GetPluginDataDir("weather_routing_pi") + "/data/boats",
                        boatsdir);
          CopyDataFiles(GetPluginDataDir("weather_routing_pi") + "/data/polars",
                        polarsdir);
        } else if (result[i] == 1) {
          if (wxFileName::FileExists(packagedCfg))
            wxCopyFile(packagedCfg, m_default_configuration_path);
        }
      }

      // Path may change after modal dialog
      pConf->SetPath("/PlugIns/WeatherRouting");
      pConf->Write("ConfigVersion", currentVersion);
    }
  }
#endif

  // ---------------------------------------------------------
  // 5. Load plugin settings
  // ---------------------------------------------------------
  m_SettingsDialog.LoadSettings();

  // ---------------------------------------------------------
  // 6. Read UI flags
  // ---------------------------------------------------------
  pConf->SetPath("/PlugIns/WeatherRouting");
  pConf->Read("DisableColPane", &m_disable_colpane, false);

#ifdef __OCPN__ANDROID__
  m_disable_colpane = true;
#endif
}


//==============================================================
// Initialize the user interface
//==============================================================


/*
void WeatherRouting::InitializeUI() {
  wxLogMessage("WR: InitializeUI() starting");

  wxFileConfig* pConf = GetOCPNConfigObject();
  pConf->SetPath("/PlugIns/WeatherRouting");

  // ---------------------------------------------------------
  // Load the plugin icon for dialogs that need it
  // ---------------------------------------------------------
  wxIcon icon;
  icon.CopyFromBitmap(*_img_WeatherRouting);

  // ---------------------------------------------------------
  // MAIN LAYOUT: Horizontal split
  //
  //  LEFT  = configuration panel (collapsible or not)
  //  RIGHT = routing table panel
  //
  // This guarantees that both panels share the same parent (this),
  // which is required for wxSizer::SetContainingWindow to succeed.
  // ---------------------------------------------------------
  wxBoxSizer* mainSizer = new wxBoxSizer(wxHORIZONTAL);
  SetSizer(mainSizer);  // <-- This window ("this") owns mainSizer

  // ---------------------------------------------------------
  // LEFT SIDE: Configuration UI
  //
  // We build a vertical sizer that will contain either:
  //   - a collapsible pane containing WeatherRoutingPanel, OR
  //   - WeatherRoutingPanel directly (if collapsible pane disabled)
  //
  // All children created here MUST have parents consistent with
  // the window that ultimately receives this sizer.
  // ---------------------------------------------------------
  wxBoxSizer* leftSizer = new wxBoxSizer(wxVERTICAL);

  if (!m_disable_colpane) {
    // Create collapsible pane as a child of "this"
    m_colpane = new wxCollapsiblePane(this, wxID_ANY, _("Weather Routing"));
    leftSizer->Add(m_colpane, 1, wxEXPAND | wxALL, 5);

    // The collapsible pane contains its own internal window
    m_colpaneWindow = m_colpane->GetPane();

    // Sizer for the collapsible pane's internal window
    wxBoxSizer* paneSz = new wxBoxSizer(wxVERTICAL);
    m_colpaneWindow->SetSizer(paneSz);

    // Create the main configuration panel INSIDE the collapsible pane
    m_PositionsPanel = new WeatherRoutingPositionsPanel(this, *this);
    leftSizer->Add(m_PositionsPanel, 1, wxEXPAND | wxALL, 5);



    m_colpane->Expand();  // Start expanded by default
  } else {
    // No collapsible pane ? panel attaches directly to this window
    m_colpane = nullptr;
    m_colpaneWindow = this;

    m_panel = new WeatherRoutingPanel(m_colpaneWindow);
    leftSizer->Add(m_panel, 1, wxEXPAND | wxALL, 5);
  }

  leftSizer->SetSizeHints(this);

  // ---------------------------------------------------------
  // RIGHT SIDE: Routing Table Panel
  //
  // This panel MUST be a direct child of "this" because its sizer
  // will be attached to "this" through mainSizer.
  // ---------------------------------------------------------
  m_panel = new WeatherRoutingPanel(m_colpaneWindow);
  paneSz->Add(m_panel, 1, wxEXPAND, 0);
  paneSz->SetSizeHints(m_colpaneWindow);

 // m_RoutingTablePanel = new RoutingTablePanel(this, *this, nullptr);

  wxBoxSizer* rightSizer = new wxBoxSizer(wxVERTICAL);
  rightSizer->Add(m_RoutingTablePanel, 1, wxEXPAND | wxALL, 5);

  // ---------------------------------------------------------
  // Attach LEFT and RIGHT to the main horizontal sizer
  // ---------------------------------------------------------
  mainSizer->Add(leftSizer, 0, wxEXPAND);
  mainSizer->Add(rightSizer, 1, wxEXPAND);

  // ---------------------------------------------------------
  // Configure list columns and icons
  // ---------------------------------------------------------
  m_panel->m_lPositions->InsertColumn(POSITION_NAME, _("Name"));
  m_panel->m_lPositions->InsertColumn(POSITION_LAT, _("Lat"));
  m_panel->m_lPositions->InsertColumn(POSITION_LON, _("Lon"));

  wxImageList* imglist = new wxImageList(20, 20, true, 1);
  imglist->Add(wxBitmap(eye));
  m_panel->m_lWeatherRoutes->AssignImageList(imglist, wxIMAGE_LIST_SMALL);

  UpdateColumns();

  // ---------------------------------------------------------
  // Load XML configuration (routes, boats, settings)
  // ---------------------------------------------------------
  // May not be necessary to load XML before initializing the UI, but some
  // dialogs (e.g., RoutePositionDialog) depend on the overlay existing, and the
  // overlay to be initialized with the configuration. So we load XML first to
  // ensure the that the configuration is fully loaded before any UI elements
  // that depend on it are initialized. This also allows the UI to reflect the
  // loaded configuration immediately upon initialization.
  // However this is a bit of a chicken-and-egg problem because some dialogs
  // (e.g., RoutePositionDialog) are initialized in InitializeUI and depend on
  // the configuration being loaded,
  // This interupts the RouteMapPanel showing.
  // wxLogMessage("WR: Calling OpenXML()");
  // OpenXML(m_default_configuration_path, false);

  // ---------------------------------------------------------
  // Restore window geometry
  // ---------------------------------------------------------
  wxPoint pos = GetPosition();
  pConf->Read("DialogX", &pos.x, pos.x);
  pConf->Read("DialogY", &pos.y, pos.y);

  m_size = GetSize();
  pConf->Read("DialogWidth", &m_size.x, wxMax(m_size.x, 100));
  pConf->Read("DialogHeight", &m_size.y, wxMax(m_size.y, 100));

  SetSize(pos.x, pos.y, m_size.x, m_size.y);

  pConf->Read("DialogSplit", &sashpos, 0);

  // ---------------------------------------------------------
  // Initialize dialogs that require two-phase UI setup
  // ---------------------------------------------------------
  m_ConfigurationDialog.SetIcon(icon);
  m_ConfigurationDialog.InitUI();

  m_BoatDialog.SetIcon(icon);
  m_BoatDialog.InitUI();

  m_ReportDialog.SetIcon(icon);
  m_ReportDialog.InitUI();

  m_PlotDialog.SetIcon(icon);
  m_PlotDialog.InitUI();

  // Batch dialog depends on m_panel existing
  m_ConfigurationBatchDialog.Reset();

  SetEnableConfigurationMenu();

  wxLogMessage("WR: InitializeUI() completed");
}
*/

// -------------------------------------------------------------------------





void WeatherRouting::InitializeUI() {
  // ---------------------------------------------------------
  // MAIN FRAME SETUP
  // ---------------------------------------------------------
  wxBoxSizer* topSizer = new wxBoxSizer(wxVERTICAL);

  // ---------------------------------------------------------
  // MENU BAR
  // ---------------------------------------------------------
  wxMenuBar* menuBar = new wxMenuBar;

  // FILE MENU
  wxMenu* fileMenu = new wxMenu;
  fileMenu->Append(ID_FILE_OPEN, _("Open"));
  fileMenu->Append(ID_FILE_SAVE, _("Save"));
  fileMenu->Append(ID_FILE_SAVEAS, _("Save As"));
  fileMenu->AppendSeparator();
  fileMenu->Append(ID_FILE_CLOSE, _("Close"));
  menuBar->Append(fileMenu, _("File"));

  // POSITION MENU
  wxMenu* positionMenu = new wxMenu;
  positionMenu->Append(ID_POSITION_NEW, _("New Position"));
  positionMenu->Append(ID_POSITION_EDIT, _("Edit Position"));
  positionMenu->Append(ID_POSITION_UPDATE_BOAT, _("Update Boat Position"));
  positionMenu->Append(ID_POSITION_DELETE, _("Delete"));
  positionMenu->Append(ID_POSITION_DELETE_ALL, _("Delete All"));
  menuBar->Append(positionMenu, _("Position"));

  // ROUTINGS MENU
  wxMenu* routingMenu = new wxMenu;
  routingMenu->Append(ID_ROUTING_NEW, _("New"));
  routingMenu->Append(ID_ROUTING_BATCH, _("Batch"));
  routingMenu->Append(ID_ROUTING_EDIT, _("Edit"));
  routingMenu->Append(ID_ROUTING_GOTO, _("Goto"));
  routingMenu->Append(ID_ROUTING_DELETE, _("Delete"));
  routingMenu->Append(ID_ROUTING_DELETE_ALL, _("Delete All"));
  routingMenu->AppendSeparator();
  routingMenu->Append(ID_ROUTING_COMPUTE, _("Compute"));
  routingMenu->Append(ID_ROUTING_COMPUTE_ALL, _("Compute All"));
  routingMenu->Append(ID_ROUTING_STOP, _("Stop"));
  routingMenu->Append(ID_ROUTING_RESET_ALL, _("Reset All"));
  routingMenu->AppendSeparator();
  routingMenu->Append(ID_ROUTING_SAVE_TRACK, _("Save as Track"));
  routingMenu->Append(ID_ROUTING_SAVE_ALL_TRACKS, _("Save All as Tracks"));
  routingMenu->Append(ID_ROUTING_SAVE_ROUTE, _("Save as Route"));
  routingMenu->Append(ID_ROUTING_EXPORT_GPX, _("Export Routing as GPX"));
  routingMenu->Append(ID_ROUTING_FILTER, _("Filter"));
  menuBar->Append(routingMenu, _("Routings"));

  // VIEW MENU
  wxMenu* viewMenu = new wxMenu;
  viewMenu->Append(ID_VIEW_SETTINGS, _("Settings"));
  viewMenu->Append(ID_VIEW_STATISTICS, _("Statistics"));
  viewMenu->Append(ID_VIEW_REPORT, _("Report"));
  viewMenu->Append(ID_VIEW_PLOT, _("Plot"));
  viewMenu->Append(ID_VIEW_CURSOR_POSITION, _("Cursor Position"));
  viewMenu->Append(ID_VIEW_ROUTE_POSITION, _("Route Position"));
  viewMenu->Append(ID_VIEW_ROUTING_TABLE, _("Weather Routing Table"));
  menuBar->Append(viewMenu, _("View"));

  // HELP MENU
  wxMenu* helpMenu = new wxMenu;
  helpMenu->Append(ID_HELP_INFORMATION, _("Information"));
  helpMenu->Append(ID_HELP_MANUAL, _("Manual"));
  helpMenu->Append(ID_HELP_ABOUT, _("About"));
  menuBar->Append(helpMenu, _("Help"));

  SetMenuBar(menuBar);

  // ---------------------------------------------------------
  // MAIN CONTENT AREA (LEFT + RIGHT PANELS)
  // ---------------------------------------------------------
  wxBoxSizer* mainSizer = new wxBoxSizer(wxHORIZONTAL);

  // ---------------------------------------------------------
  // LEFT PANEL ? POSITIONS
  // ---------------------------------------------------------
  wxBoxSizer* leftSizer = new wxBoxSizer(wxVERTICAL);

  wxStaticText* posLabel = new wxStaticText(this, wxID_ANY, _("Positions"));
  posLabel->SetFont(posLabel->GetFont().Bold());
  leftSizer->Add(posLabel, 0, wxLEFT | wxTOP | wxBOTTOM, 5);

   // Create new left panel
  m_PositionPanel = new WeatherRoutingPositionPanel(this, *this);
  leftSizer->Add(m_PositionPanel, 1, wxEXPAND | wxALL, 5);

  // ---------------------------------------------------------
  // RIGHT PANEL ? ROUTINGS
  // ---------------------------------------------------------
  wxBoxSizer* rightSizer = new wxBoxSizer(wxVERTICAL);

  wxStaticText* routeLabel = new wxStaticText(this, wxID_ANY, _("Routings"));
  routeLabel->SetFont(routeLabel->GetFont().Bold());
  rightSizer->Add(routeLabel, 0, wxLEFT | wxTOP | wxBOTTOM, 5);

  // Create new right panel
  m_RouteMapPanel = new RouteMapPanel(this, *this);
  rightSizer->Add(m_RouteMapPanel, 1, wxEXPAND | wxALL, 5);

  // ---------------------------------------------------------
  // BUTTON ROW UNDER ROUTINGS PANEL
  // ---------------------------------------------------------
  wxBoxSizer* buttonRow = new wxBoxSizer(wxHORIZONTAL);

  m_btnCompute = new wxButton(this, ID_ROUTING_COMPUTE, _("Compute"));
  m_btnSaveTrack =
      new wxButton(this, ID_ROUTING_SAVE_TRACK, _("Save as Track"));
  m_btnSaveRoute =
      new wxButton(this, ID_ROUTING_SAVE_ROUTE, _("Save as Route"));
  m_btnExportGPX =
      new wxButton(this, ID_ROUTING_EXPORT_GPX, _("Export as GPX Route"));
  m_btnReset =
      new wxButton(this, ID_ROUTING_RESET, _("Reset"));  // Your addition
  m_btnGotoRouting =
      new wxButton(this, ID_GOTO_ROUTING, _("Goto Routing"));  //

  buttonRow->Add(m_btnCompute, 0, wxRIGHT, 5);
  buttonRow->Add(m_btnSaveTrack, 0, wxRIGHT, 5);
  buttonRow->Add(m_btnSaveRoute, 0, wxRIGHT, 5);
  buttonRow->Add(m_btnExportGPX, 0, wxRIGHT, 5);
  buttonRow->Add(m_btnReset, 0);

  rightSizer->Add(buttonRow, 0, wxALIGN_LEFT | wxALL, 5);

  // ---------------------------------------------------------
  // ADD LEFT + RIGHT PANELS TO MAIN SIZER
  // ---------------------------------------------------------
  mainSizer->Add(leftSizer, 0, wxEXPAND | wxALL, 5);
  mainSizer->Add(rightSizer, 1, wxEXPAND | wxALL, 5);

  topSizer->Add(mainSizer, 1, wxEXPAND);

  SetSizer(topSizer);
  Layout();


// ======================================================================
  // EVENT BINDINGS FOR NEW UI
  // ======================================================================

  // ---------------------------------------------------------
  // MENU BINDINGS
  // ---------------------------------------------------------

  // FILE
  Bind(wxEVT_MENU, &WeatherRouting::OnFileOpen, this, ID_FILE_OPEN);
  Bind(wxEVT_MENU, &WeatherRouting::OnFileSave, this, ID_FILE_SAVE);
  Bind(wxEVT_MENU, &WeatherRouting::OnFileSaveAs, this, ID_FILE_SAVEAS);
  Bind(wxEVT_MENU, &WeatherRouting::OnFileClose, this, ID_FILE_CLOSE);

  // POSITION
  Bind(wxEVT_MENU, &WeatherRouting::OnNewPosition, this, ID_POSITION_NEW);
  Bind(wxEVT_MENU, &WeatherRouting::OnEditPosition, this, ID_POSITION_EDIT);
  Bind(wxEVT_MENU, &WeatherRouting::OnUpdateBoatPosition, this,
       ID_POSITION_UPDATE_BOAT);
  Bind(wxEVT_MENU, &WeatherRouting::OnDeletePosition, this, ID_POSITION_DELETE);
  Bind(wxEVT_MENU, &WeatherRouting::OnDeleteAllPositions, this,
       ID_POSITION_DELETE_ALL);
  Bind(wxEVT_MENU, &WeatherRouting::OnGotoRouting, this, ID_GOTO_ROUTING);


  // ROUTINGS
  Bind(wxEVT_MENU, &WeatherRouting::OnNewRouting, this, ID_ROUTING_NEW);
  Bind(wxEVT_MENU, &WeatherRouting::OnBatchRouting, this, ID_ROUTING_BATCH);
  Bind(wxEVT_MENU, &WeatherRouting::OnEditRouting, this, ID_ROUTING_EDIT);
  Bind(wxEVT_MENU, &WeatherRouting::OnGotoRouting, this, ID_ROUTING_GOTO);
  Bind(wxEVT_MENU, &WeatherRouting::OnDeleteRouting, this, ID_ROUTING_DELETE);
  Bind(wxEVT_MENU, &WeatherRouting::OnDeleteAllRoutings, this,
       ID_ROUTING_DELETE_ALL);

  Bind(wxEVT_MENU, &WeatherRouting::OnCompute, this, ID_ROUTING_COMPUTE);
  Bind(wxEVT_MENU, &WeatherRouting::OnComputeAll, this, ID_ROUTING_COMPUTE_ALL);
  Bind(wxEVT_MENU, &WeatherRouting::OnStop, this, ID_ROUTING_STOP);
  Bind(wxEVT_MENU, &WeatherRouting::OnResetAll, this, ID_ROUTING_RESET_ALL);
  Bind(wxEVT_MENU, &WeatherRouting::OnToggleVisibility, this, ID_TOGGLE_VISIBILITY);


  Bind(wxEVT_MENU, &WeatherRouting::OnSaveAsTrack, this, ID_ROUTING_SAVE_TRACK);
  Bind(wxEVT_MENU, &WeatherRouting::OnSaveAllTracks, this,
       ID_ROUTING_SAVE_ALL_TRACKS);
  Bind(wxEVT_MENU, &WeatherRouting::OnSaveAsRoute, this, ID_ROUTING_SAVE_ROUTE);
  Bind(wxEVT_MENU, &WeatherRouting::OnExportGPX, this, ID_ROUTING_EXPORT_GPX);
  Bind(wxEVT_MENU, &WeatherRouting::OnFilter, this, ID_ROUTING_FILTER);

  // VIEW
  Bind(wxEVT_MENU, &WeatherRouting::OnSettings, this, ID_VIEW_SETTINGS);
  Bind(wxEVT_MENU, &WeatherRouting::OnStatistics, this, ID_VIEW_STATISTICS);
  Bind(wxEVT_MENU, &WeatherRouting::OnReport, this, ID_VIEW_REPORT);
  Bind(wxEVT_MENU, &WeatherRouting::OnPlot, this, ID_VIEW_PLOT);
  Bind(wxEVT_MENU, &WeatherRouting::OnCursorPosition, this,
       ID_VIEW_CURSOR_POSITION);
  Bind(wxEVT_MENU, &WeatherRouting::OnRoutePosition, this,
       ID_VIEW_ROUTE_POSITION);
  Bind(wxEVT_MENU, &WeatherRouting::OnRoutingTable, this,
       ID_VIEW_ROUTING_TABLE);

  // HELP
  Bind(wxEVT_MENU, &WeatherRouting::OnInformation, this, ID_HELP_INFORMATION);
  Bind(wxEVT_MENU, &WeatherRouting::OnManual, this, ID_HELP_MANUAL);
  Bind(wxEVT_MENU, &WeatherRouting::OnAbout, this, ID_HELP_ABOUT);

  // ======================================================================
  // BUTTON BINDINGS (new button row)
  // ======================================================================

  m_btnCompute->Bind(wxEVT_BUTTON, &WeatherRouting::OnCompute, this);
  m_btnSaveTrack->Bind(wxEVT_BUTTON, &WeatherRouting::OnSaveAsTrack, this);
  m_btnSaveRoute->Bind(wxEVT_BUTTON, &WeatherRouting::OnSaveAsRoute, this);
  m_btnExportGPX->Bind(wxEVT_BUTTON, &WeatherRouting::OnExportGPX, this);
  m_btnReset->Bind(wxEVT_BUTTON, &WeatherRouting::OnResetRouting, this);
  m_btnGotoRouting->Bind(wxEVT_BUTTON, &WeatherRouting::OnGotoRouting, this);

  // ======================================================================
  // LIST CONTROL BINDINGS
  // ======================================================================

  // POSITIONS LIST (left panel)
  m_PositionPanel->m_lPositions->Bind(
      wxEVT_LEFT_DCLICK, &WeatherRouting::OnEditPositionClick, this);

  m_PositionPanel->m_lPositions->Bind(
      wxEVT_LIST_ITEM_SELECTED, &WeatherRouting::OnPositionSelected, this);

  // ROUTINGS LIST (right panel)
  m_RouteMapPanel->m_lWeatherRoutes->Bind(
      wxEVT_LEFT_DCLICK, &WeatherRouting::OnEditConfigurationClick, this);

  m_RouteMapPanel->m_lWeatherRoutes->Bind(
      wxEVT_LIST_COL_CLICK, &WeatherRouting::OnWeatherRouteSort, this);

  m_RouteMapPanel->m_lWeatherRoutes->Bind(
      wxEVT_LIST_ITEM_SELECTED, &WeatherRouting::OnWeatherRouteSelected, this);

  m_RouteMapPanel->m_lWeatherRoutes->Bind(
      wxEVT_LIST_ITEM_DESELECTED, &WeatherRouting::OnWeatherRouteSelected,
      this);
}


/*
============================================================
// Bind all event handlers
//==============================================================

void WeatherRouting::BindEvents() {

  // ---------------------------------------------------------
  // System-Level Events
  // ---------------------------------------------------------
  // BIND OnRouteMapUpdate to EVT_ROUTEMAP_UPDATE
  //   // Route map update from RouteMapOverlay threads this is how
  // RouteMapOverlay notifies WeatherRouting of progress
  // It is a thread-safe event and can be sent from any thread
  // The event handler will be called in the main thread context, allowing safe
  // UI updates

  Bind(EVT_ROUTEMAP_UPDATE, &WeatherRouting::OnRouteMapUpdate, this);

#ifdef PLUGIN_USE_ASM
  Bind(EVT_MEMORY_ALERT_STOP, &WeatherRouting::OnMemoryAlertStop, this);
  Bind(EVT_MEMORY_AUTO_RESET, &WeatherRouting::OnMemoryAutoReset, this);
#endif

  // ---------------------------------------------------------
  // Timers
  // ---------------------------------------------------------
  m_tCompute.Connect(wxEVT_TIMER,
                     wxTimerEventHandler(WeatherRouting::OnComputationTimer),
                     nullptr, this);

  m_tHideConfiguration.Connect(
      wxEVT_TIMER,
      wxTimerEventHandler(WeatherRouting::OnHideConfigurationTimer), nullptr,
      this);

  m_tAutoSaveXML.Connect(
      wxEVT_TIMER, wxTimerEventHandler(WeatherRouting::OnAutoSaveXMLTimer),
      nullptr, this);

  Connect(wxEVT_IDLE, wxTimerEventHandler(WeatherRouting::OnRenderedTimer),
          nullptr, this);

  // ---------------------------------------------------------
  // UI Events
  // ---------------------------------------------------------
  if (m_colpane) {
    m_colpane->Connect(
        wxEVT_COLLAPSIBLEPANE_CHANGED,
        wxCollapsiblePaneEventHandler(WeatherRouting::OnCollPaneChanged),
        nullptr, this);
  }

  // Positions list
  m_panel->m_lPositions->Connect(
      wxEVT_LEFT_DCLICK,
      wxMouseEventHandler(WeatherRouting::OnEditPositionClick), nullptr, this);

  // WeatherRoutes list
  m_panel->m_lWeatherRoutes->Connect(
      wxEVT_LEFT_DCLICK,
      wxMouseEventHandler(WeatherRouting::OnEditConfigurationClick), nullptr,
      this);

  m_panel->m_lWeatherRoutes->Connect(
      wxEVT_COMMAND_LIST_COL_CLICK,
      wxListEventHandler(WeatherRouting::OnWeatherRouteSort), nullptr, this);

  m_panel->m_lWeatherRoutes->Connect(
      wxEVT_COMMAND_LIST_ITEM_SELECTED,
      wxListEventHandler(WeatherRouting::OnWeatherRouteSelected), nullptr,
      this);

  m_panel->m_lWeatherRoutes->Connect(
      wxEVT_COMMAND_LIST_ITEM_DESELECTED,
      wxListEventHandler(WeatherRouting::OnWeatherRouteSelected), nullptr,
      this);

  // Buttons
  m_panel->m_bCompute->Connect(wxEVT_COMMAND_BUTTON_CLICKED,
                               wxCommandEventHandler(WeatherRouting::OnCompute),
                               nullptr, this);

  m_panel->m_bSaveAsTrack->Connect(
      wxEVT_COMMAND_BUTTON_CLICKED,
      wxCommandEventHandler(WeatherRouting::OnSaveAsTrack), nullptr, this);

  m_panel->m_bSaveAsRoute->Connect(
      wxEVT_COMMAND_BUTTON_CLICKED,
      wxCommandEventHandler(WeatherRouting::OnSaveAsRoute), nullptr, this);

  m_panel->m_bExportRoute->Connect(
      wxEVT_COMMAND_BUTTON_CLICKED,
      wxCommandEventHandler(WeatherRouting::OnExportRouteAsGPX), nullptr, this);
}
*/



//==============================================================
// DESTRUCTOR  weatherrouting
//==============================================================

WeatherRouting::~WeatherRouting() {

  m_shuttingDown = true;  // <-- ADD THIS

  // Stop internal timers
  if (m_tAutoSaveXML.IsRunning())
      m_tAutoSaveXML.Stop();

  // Quiesce RoutingTablePanel early to prevent late callbacks
  if (m_RoutingTablePanel) {
    m_RoutingTablePanel->Freeze();
    m_RoutingTablePanel->Disconnect();
  }
  wxLogMessage(
      "WeatherRouting::~WeatherRouting - shutdown flag set, timers stopped, "
      "panel disconnected");
  wxLogMessage("~WeatherRouting() - BEGIN");

  // ---------------------------------------------------------
  // 1. Save settings and dialog geometry
  // ---------------------------------------------------------
  m_SettingsDialog.SaveSettings();

  wxFileConfig* pConf = GetOCPNConfigObject();
  pConf->SetPath("/PlugIns/WeatherRouting");

  wxPoint pos = GetPosition();
  pConf->Write("DialogX", pos.x);
  pConf->Write("DialogY", pos.y);
  pConf->Write("DialogWidth", m_size.x);
  pConf->Write("DialogHeight", m_size.y);

  if (m_panel && m_panel->m_splitter1)
    pConf->Write("DialogSplit", m_panel->m_splitter1->GetSashPosition());

  // Save XML project file
  SaveXML(m_FileName.GetFullPath());

  // ---------------------------------------------------------
  // 2. Stop all overlays using the NEW thread lifecycle
  // ---------------------------------------------------------
  {
    wxMutexLocker lock(m_OverlayListMutex);

    for (auto* ov : m_RouteMapOverlays) {
      if (!ov) continue;

      ov->SetFinished(true);
      ov->m_Stopped = true;
    }
  }

// Wait for all threads to exit cleanly
  std::list<RouteMapOverlay*> overlays(m_RouteMapOverlays.begin(),
                                       m_RouteMapOverlays.end());

  WaitForRoutesToStop(overlays);

  // ---------------------------------------------------------
  // 3. Remove overlays from scheduler lists and delete threads
  // ---------------------------------------------------------
  for (auto* ov : m_RouteMapOverlays) {
    if (!ov) continue;

    m_WaitingRouteMaps.remove(ov);
    m_RunningRouteMaps.remove(ov);

    if (ov->HasThread()) ov->Stop();

    ov->DeleteThread();
  }

  // ---------------------------------------------------------
  // 4. Delete WeatherRoute objects (after overlays are safe)
  // ---------------------------------------------------------
  for (auto* wr : m_WeatherRoutes) delete wr;

  m_WeatherRoutes.clear();
  m_RouteMapOverlays.clear();

  // ---------------------------------------------------------
  // 5. Destroy RoutingTablePanel if it exists
  // ---------------------------------------------------------
  if (m_RoutingTablePanel) {
    wxAuiManager* mgr = ::GetFrameAuiManager();
    mgr->DetachPane(m_RoutingTablePanel);
    m_RoutingTablePanel->Destroy();
    m_RoutingTablePanel = nullptr;
  }

  // ---------------------------------------------------------
  // 6. Let wxWidgets destroy child windows naturally
  // ---------------------------------------------------------
  // m_panel and m_colpane are children of this window.
  // wxWidgets will destroy them automatically.

  wxLogMessage("~WeatherRouting() - END");
}

//==============================================================
// DESTRUCTOR  ENDING  weatherrouting
//==============================================================


//==============================================================
// RENDER   OPENCPN Render overlay drawing function
//==============================================================

void WeatherRouting::Render(piDC& dc, PlugIn_ViewPort& vp) {
  // ---------------------------------------------------------------------
  // 1. Validate viewport and detect SDMM format changes
  // ---------------------------------------------------------------------
  static int prevLocationFormat = -1;
  int currentLocationFormat = GetLatLonFormat();
  bool locationFormatChanged = false;

  if (!vp.bValid) return;

  if (currentLocationFormat != prevLocationFormat) {
    prevLocationFormat = currentLocationFormat;
    locationFormatChanged = true;
  }

  // ---------------------------------------------------------------------
  // 2. Update waypoint positions in the Positions list control
  //    This is legacy behavior: the plugin polls RouteMap::Positions
  //    and updates the UI if any waypoint has moved or been renamed.
  // ---------------------------------------------------------------------
  bool work = false;

  for (auto& it : RouteMap::Positions) {
    PlugIn_Waypoint waypoint;
    bool gotWaypoint = false;

    wxString name = it.Name;
    double lat = it.lat;
    double lon = it.lon;

    // If the waypoint has a GUID, fetch its current state from OpenCPN
    if (!it.GUID.IsEmpty()) {
      gotWaypoint = GetSingleWaypoint(it.GUID, &waypoint);

      if (gotWaypoint) {
        if (lat != waypoint.m_lat || lon != waypoint.m_lon ||
            !waypoint.m_MarkName.IsSameAs(it.Name)) {
          work = true;
        }
      }
    }

    long index = m_panel->m_lPositions->FindItem(0, it.ID);
    if (index < 0) continue;  // corrupted or missing row

    // Update cached values if waypoint changed
    if (gotWaypoint && work) {
      name = waypoint.m_MarkName;
      lat = waypoint.m_lat;
      lon = waypoint.m_lon;

      it.Name = name;
      it.lat = lat;
      it.lon = lon;
    }

    // Update UI if waypoint changed or SDMM format changed
    if (work || locationFormatChanged) {
      m_panel->m_lPositions->SetItem(index, POSITION_NAME, name);
      m_panel->m_lPositions->SetColumnWidth(POSITION_NAME, wxLIST_AUTOSIZE);

      m_panel->m_lPositions->SetItem(
          index, POSITION_LAT, toSDMM_PlugIn(NEflag::LAT, lat, Precision::HI));
      m_panel->m_lPositions->SetColumnWidth(POSITION_LAT, wxLIST_AUTOSIZE);

      m_panel->m_lPositions->SetItem(
          index, POSITION_LON, toSDMM_PlugIn(NEflag::LON, lon, Precision::HI));
      m_panel->m_lPositions->SetColumnWidth(POSITION_LON, wxLIST_AUTOSIZE);
    }
  }

  // If anything changed, refresh the parent window
  if (work || locationFormatChanged) GetParent()->Refresh();

  // ---------------------------------------------------------------------
  // 3. Prepare OpenGL state (if using GL instead of wxDC)
  // ---------------------------------------------------------------------
  if (!dc.GetDC()) {
#ifndef __OCPN__ANDROID__
    glPushAttrib(GL_LINE_BIT | GL_ENABLE_BIT | GL_HINT_BIT);
    glEnable(GL_LINE_SMOOTH);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
#endif
    glEnable(GL_BLEND);
  }

  // ---------------------------------------------------------------------
  // 4. Determine GRIB timeline time for rendering
  // ---------------------------------------------------------------------
  wxDateTime time = m_ConfigurationDialog.m_GribTimelineTime;
  if (!time.IsValid()) time = wxDateTime::UNow();

  // ---------------------------------------------------------------------
  // 5. Update routing table highlight (UI only)
  // ---------------------------------------------------------------------
  if (m_RoutingTablePanel) m_RoutingTablePanel->UpdateTimeHighlight(time);

  // ---------------------------------------------------------------------
  // 6. Render all route overlays in the list control
  // ---------------------------------------------------------------------
  for (int i = 0; i < m_panel->m_lWeatherRoutes->GetItemCount(); i++) {
    WeatherRoute* weatherroute = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));

    if (weatherroute && weatherroute->routemapoverlay &&
        weatherroute->routemapoverlay->m_bEndRouteVisible) {
      weatherroute->routemapoverlay->Render(time, m_SettingsDialog, dc, vp,
                                            true);
    }
  }

  // ---------------------------------------------------------------------
  // 7. Render batch configuration overlay (if active)
  // ---------------------------------------------------------------------
  m_ConfigurationBatchDialog.Render(dc, vp);

  // ---------------------------------------------------------------------
  // 8. Restore OpenGL state
  // ---------------------------------------------------------------------
#ifndef __OCPN__ANDROID__
  if (!dc.GetDC()) glPopAttrib();
#endif
}

//==============================================================
// ANDROID GESTURE EVENT HANDLER
//==============================================================


#ifdef __OCPN__ANDROID__
void WeatherRouting::OnEvtPanGesture(wxQT_PanGestureEvent& event) {
  switch (event.GetState()) {
    case GestureStarted:
      m_startPos = GetPosition();
      m_startMouse = event.GetCursorPos();  // g_mouse_pos_screen;
      break;
    default: {
      wxPoint pos = event.GetCursorPos();
      int x = wxMax(0, pos.x + m_startPos.x - m_startMouse.x);
      int y = wxMax(0, pos.y + m_startPos.y - m_startMouse.y);
      int xmax = ::wxGetDisplaySize().x - GetSize().x;
      x = wxMin(x, xmax);
      int ymax =
          ::wxGetDisplaySize().y - GetSize().y;  // Some fluff at the bottom
      y = wxMin(y, ymax);

      Move(x, y);
      m_tDownTimer.Stop();
    } break;
  }
}
#endif


//==============================================================
// NEW  STUFF
//=============================================================


void WeatherRouting::ComputeSelectedRoute() {
  // ---------------------------------------------------------
  // 1. Get selected overlays (your modern helper)
  // ---------------------------------------------------------
  std::vector<RouteMapOverlay*> overlays = GetSelectedOverlays();

  if (overlays.empty()) {
    wxMessageBox(_("No routes selected."), _("Weather Routing"),
                 wxOK | wxICON_INFORMATION, this);
    return;
  }

#ifdef __WXMSW__
  if (AreNewComputationsDisabled()) {
    wxMessageBox(_("New computations are temporarily disabled."),
                 _("Weather Routing"), wxOK | wxICON_WARNING, this);
    return;
  }
#endif

  // ---------------------------------------------------------
  // 2. For each selected route, start computation
  // ---------------------------------------------------------
  for (RouteMapOverlay* rmo : overlays) {
    if (!rmo) continue;

    WeatherRoute* wr = rmo->m_weatherRoute;
    if (!wr) continue;

    // Skip if already running
    if (rmo->Running()) {
      wxLogMessage("WR: ComputeSelectedRoute ? route already running");
      continue;
    }

    // Skip if waiting
    if (IsWaiting(rmo)) {
      wxLogMessage("WR: ComputeSelectedRoute ? route already queued");
      continue;
    }

    // ---------------------------------------------------------
    // 3. Reset route state before computing
    // ---------------------------------------------------------
    wr->ResetComputedFields();
    rmo->Reset();

    // ---------------------------------------------------------
    // 4. Queue for computation
    // ---------------------------------------------------------
    m_WaitingRouteMaps.push_back(rmo);

    wxLogMessage("WR: ComputeSelectedRoute ? queued route for computation");
  }

  // ---------------------------------------------------------
  // 5. Trigger the computation timer
  //    (this launches threads when slots are available)
  // ---------------------------------------------------------
  m_tCompute.Start(50, true);

  // ---------------------------------------------------------
  // 6. Update UI
  // ---------------------------------------------------------
  UpdateDialogs();
  UpdateStates();
  m_RouteMapPanel->PopulateRoutes();
}




void WeatherRouting::ResetSelectedRoute() {
  // ---------------------------------------------------------
  // 1. Get selected overlays
  // ---------------------------------------------------------
  std::vector<RouteMapOverlay*> overlays = GetSelectedOverlays();
  if (overlays.empty()) {
    wxLogMessage("WR: ResetSelectedRoute ? no routes selected");
    return;
  }

  wxLogMessage("WR: ResetSelectedRoute ? BEGIN");

  // ---------------------------------------------------------
  // 2. Stop running routes
  // ---------------------------------------------------------
  for (auto* rmo : overlays) {
    if (!rmo) continue;

    // Stop thread safely
    rmo->Stop();

    // Ensure thread is gone
    rmo->DeleteThread();
  }

  // ---------------------------------------------------------
  // 3. Reset compute engine + model fields
  // ---------------------------------------------------------
  for (auto* rmo : overlays) {
    if (!rmo) continue;

    WeatherRoute* wr = rmo->m_weatherRoute;
    if (!wr) continue;

    // Reset overlay state
    rmo->Reset();

    // Reset model-side computed fields
    wr->ResetComputedFields();
  }

  // ---------------------------------------------------------
  // 4. Clear UI cursor highlight
  // ---------------------------------------------------------
  m_positionOnRoute = nullptr;

  // ---------------------------------------------------------
  // 5. Update UI for selected routes only
  // ---------------------------------------------------------
  for (auto* rmo : overlays) {
    WeatherRoute* wr = rmo->m_weatherRoute;
    if (!wr) continue;

    long row = GetRouteRow(wr);
    if (row >= 0) UpdateItem(row, true);  // your modern row refresh
  }

  // ---------------------------------------------------------
  // 6. Refresh dialogs + states
  // ---------------------------------------------------------
  UpdateDialogs();
  UpdateStates();
  m_RouteMapPanel->PopulateRoutes();
  GetParent()->Refresh();

  wxLogMessage("WR: ResetSelectedRoute ? END");
}


void WeatherRouting::OnEditConfigurationClick(wxMouseEvent& event) {
  long sel = m_RouteMapPanel->m_lWeatherRoutes->GetNextItem(
      -1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);

  if (sel < 0) return;

  WeatherRoute* route = reinterpret_cast<WeatherRoute*>(
      m_RouteMapPanel->m_lWeatherRoutes->GetItemData(sel));

  if (!route) return;

  // Open the route configuration dialog
  WeatherRoutingPanel dlg(this, route);
  if (dlg.ShowModal() == wxID_OK) {
    // User changed configuration ? refresh UI
    PopulateRoutes();
    Refresh();
  }
}


std::vector<RouteMapOverlay*> WeatherRouting::GetSelectedOverlays() const {
  std::vector<RouteMapOverlay*> result;

  // No panel? No list? No selection? Return empty.
  if (!m_RouteMapPanel || !m_RouteMapPanel->m_lWeatherRoutes) return result;

  wxListCtrl* list = m_RouteMapPanel->m_lWeatherRoutes;

  long item = -1;
  for (;;) {
    // Find next selected row
    item = list->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);

    if (item < 0) break;

    // Retrieve the WeatherRoute* stored in row data
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(list->GetItemData(item));

    if (!wr) continue;

    // Retrieve the overlay
    RouteMapOverlay* rmo = wr->routemapoverlay;
    if (!rmo) continue;

    result.push_back(rmo);
  }

  return result;
}

void WeatherRouting::UpdateItem(long row, bool refreshState) {
  if (!m_RouteMapPanel || !m_RouteMapPanel->m_lWeatherRoutes) return;

  wxListCtrl* list = m_RouteMapPanel->m_lWeatherRoutes;

  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(list->GetItemData(row));
  if (!wr) return;

  // Column 0: Visibility
  list->SetItem(row, 0, wr->visible ? _("X") : _(""));

  // Column 1: Boat
  list->SetItem(row, 1, wr->BoatName);

  // Column 2: Start Type
  list->SetItem(row, 2, wr->StartTypeString());

  // Column 3: Start
  list->SetItem(row, 3, wr->StartString());

  // Column 4: Start Time
  list->SetItem(row, 4, wr->StartTimeString());

  // Column 5: End
  list->SetItem(row, 5, wr->EndString());

  // Column 6: End Time
  list->SetItem(row, 6, wr->EndTimeString());

  // Column 7: Duration
  list->SetItem(row, 7, wr->DurationString());

  // Column 8: Distance
  list->SetItem(row, 8, wr->DistanceString());

  // Column 9: State
  if (refreshState) list->SetItem(row, 9, wr->StateString());
}


void WeatherRouting::OnWeatherRouteSelected(wxListEvent& event) {
  long row = event.GetIndex();
  if (row < 0) return;

  wxListCtrl* list = m_RouteMapPanel->m_lWeatherRoutes;

  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(list->GetItemData(row));
  if (!wr) return;

  // Update internal pointer for dialogs, cursor tracking, etc.
  m_positionOnRoute = wr;

  // Update dependent dialogs
  UpdateDialogs();
}


void WeatherRouting::OnResetRouting(wxCommandEvent& event) {
  ResetSelectedRoute();
}

void WeatherRouting::OnCompute(wxCommandEvent& event) {
  ComputeSelectedRoute();
}


void WeatherRouting::DeleteSelectedRoute() {
  // ---------------------------------------------------------
  // 1. Get selected overlays
  // ---------------------------------------------------------
  std::vector<RouteMapOverlay*> overlays = GetSelectedOverlays();
  if (overlays.empty()) {
    wxLogMessage("WR: DeleteSelectedRoute ? no routes selected");
    return;
  }

  wxLogMessage("WR: DeleteSelectedRoute ? BEGIN");

  // ---------------------------------------------------------
  // 2. Stop running computations
  // ---------------------------------------------------------
  for (auto* rmo : overlays) {
    if (!rmo) continue;

    rmo->Stop();
    rmo->DeleteThread();
  }

  // ---------------------------------------------------------
  // 3. Delete overlays + WeatherRoute objects
  // ---------------------------------------------------------
  for (auto* rmo : overlays) {
    if (!rmo) continue;

    WeatherRoute* wr = rmo->m_weatherRoute;
    if (!wr) continue;

    // Remove from master list
    auto it = std::find(m_WeatherRoutes.begin(), m_WeatherRoutes.end(), wr);
    if (it != m_WeatherRoutes.end()) m_WeatherRoutes.erase(it);

    // Delete overlay
    DeleteRouteMap(rmo);

    // Delete WeatherRoute object
    delete wr;
  }

  // ---------------------------------------------------------
  // 4. Clear stale UI state
  // ---------------------------------------------------------
  m_positionOnRoute = nullptr;

  // ---------------------------------------------------------
  // 5. Refresh UI
  // ---------------------------------------------------------
  m_RouteMapPanel->PopulateRoutes();
  UpdateDialogs();
  UpdateStates();
  GetParent()->Refresh();

  // ---------------------------------------------------------
  // 6. Schedule autosave
  // ---------------------------------------------------------
  m_tAutoSaveXML.Start(5000, true);

  wxLogMessage("WR: DeleteSelectedRoute ? END");
}


void WeatherRouting::OnDeleteRouting(wxCommandEvent& event) {
  DeleteSelectedRoute();
}


void WeatherRouting::OnDeleteAllRoutings(wxCommandEvent& event) {
  // Stop all computations first
  StopAll();

  // Delete all overlays + WeatherRoute objects
  for (auto* wr : m_WeatherRoutes) {
    if (!wr) continue;

    if (wr->routemapoverlay) DeleteRouteMap(wr->routemapoverlay);

    delete wr;
  }

  m_WeatherRoutes.clear();

  // Clear UI state
  m_positionOnRoute = nullptr;

  // Refresh UI
  m_RouteMapPanel->PopulateRoutes();
  UpdateDialogs();
  UpdateStates();
  GetParent()->Refresh();

  // Autosave
  m_tAutoSaveXML.Start(5000, true);

  wxLogMessage("WR: OnDeleteAllRoutings ? all routes deleted");
}


long WeatherRouting::GetRouteRow(WeatherRoute* wr) const {
  if (!wr || !m_RouteMapPanel || !m_RouteMapPanel->m_lWeatherRoutes) return -1;

  wxListCtrl* list = m_RouteMapPanel->m_lWeatherRoutes;

  long count = list->GetItemCount();
  for (long row = 0; row < count; row++) {
    WeatherRoute* rowWR =
        reinterpret_cast<WeatherRoute*>(list->GetItemData(row));

    if (rowWR == wr) return row;
  }

  return -1;
}


void WeatherRouting::OnEditConfigurationClick(wxCommandEvent& event) {
  // Get selected overlays (modern multi-select)
  auto overlays = GetSelectedOverlays();
  if (overlays.empty()) return;

  // For now, edit the first selected route
  RouteMapOverlay* rmo = overlays.front();
  WeatherRoute* wr = rmo->m_weatherRoute;
  if (!wr) return;

  // Open the configuration dialog
  WeatherRoutingConfigurationDialog dlg(this, wr);
  if (dlg.ShowModal() == wxID_OK) {
    // User changed configuration ? update UI
    UpdateDialogs();
    UpdateStates();
    m_RouteMapPanel->PopulateRoutes();
  }
}


void WeatherRouting::ResetAllRoutes() {
  wxLogMessage("WR: ResetAllRoutes ? BEGIN");

  // Stop all running computations
  StopAll();

  // Reset every route + overlay
  for (auto* wr : m_WeatherRoutes) {
    if (!wr) continue;

    RouteMapOverlay* rmo = wr->routemapoverlay;
    if (!rmo) continue;

    rmo->Reset();
    wr->ResetComputedFields();
  }

  // Clear cursor highlight
  m_positionOnRoute = nullptr;

  // Refresh UI
  m_RouteMapPanel->PopulateRoutes();
  UpdateDialogs();
  UpdateStates();
  GetParent()->Refresh();

  wxLogMessage("WR: ResetAllRoutes ? END");
}

void WeatherRouting::StopSelected() {
  auto overlays = GetSelectedOverlays();
  if (overlays.empty()) return;

  wxLogMessage("WR: StopSelected ? BEGIN");

  for (auto* rmo : overlays) {
    if (!rmo) continue;

    // Phase 1: signal stop
    rmo->Stop();

    // Phase 2: wait for thread to exit
    rmo->DeleteThread();

    // Phase 3: mark overlay as stopped
    rmo->m_Stopped = true;
  }

  // Update UI
  UpdateDialogs();
  UpdateStates();
  m_RouteMapPanel->PopulateRoutes();
  GetParent()->Refresh();

  wxLogMessage("WR: StopSelected ? END");
}


void WeatherRouting::StopAll() {
  wxLogMessage("WR: StopAll ? BEGIN");

  for (auto* wr : m_WeatherRoutes) {
    if (!wr) continue;

    RouteMapOverlay* rmo = wr->routemapoverlay;
    if (!rmo) continue;

    // Phase 1: signal stop
    rmo->Stop();

    // Phase 2: wait for thread to exit
    rmo->DeleteThread();

    // Phase 3: mark overlay as stopped
    rmo->m_Stopped = true;
  }

  UpdateDialogs();
  UpdateStates();
  m_RouteMapPanel->PopulateRoutes();
  GetParent()->Refresh();

  wxLogMessage("WR: StopAll ? END");
}

void WeatherRouting::OnStopRouting(wxCommandEvent& event) { StopSelected(); }

void WeatherRouting::OnStopAllRoutings(wxCommandEvent& event) { StopAll(); }

void WeatherRouting::OnEditConfigurationClick(wxCommandEvent& event) {
  auto overlays = GetSelectedOverlays();
  if (overlays.empty()) return;

  RouteMapOverlay* rmo = overlays.front();
  WeatherRoute* wr = rmo->m_weatherRoute;
  if (!wr) return;

  WeatherRoutingConfigurationDialog dlg(this, wr);

  if (dlg.ShowModal() == wxID_OK) {
    UpdateDialogs();
    UpdateStates();
    m_RouteMapPanel->PopulateRoutes();
  }
}

void WeatherRouting::OnSaveAsTrack(wxCommandEvent& event) {
  auto overlays = GetSelectedOverlays();
  if (overlays.empty()) return;

  for (auto* rmo : overlays) {
    WeatherRoute* wr = rmo->m_weatherRoute;
    if (!wr) continue;

    OnSaveAsTrack(wr);  // your existing backend function
  }
}

void WeatherRouting::OnSaveAsRoute(wxCommandEvent& event) {
  auto overlays = GetSelectedOverlays();
  if (overlays.empty()) return;

  for (auto* rmo : overlays) {
    WeatherRoute* wr = rmo->m_weatherRoute;
    if (!wr) continue;

    OnSaveAsRoute(wr);  // your existing backend function
  }
}

void WeatherRouting::OnGotoRouting(wxCommandEvent& event) {
  auto overlays = GetSelectedOverlays();
  if (overlays.empty()) return;

  RouteMapOverlay* rmo = overlays.front();
  WeatherRoute* wr = rmo->m_weatherRoute;
  if (!wr) return;

  if (wr->routepoints.empty()) return;

  const auto& p = wr->routepoints.front();

  JumpToPosition(p.lat, p.lon);  // OpenCPN API call
}

void WeatherRouting::SaveColumnWidth(int col, int width) {
  m_ColumnWidths[col] = width;
  m_tAutoSaveXML.Start(5000, true);
}

int WeatherRouting::LoadColumnWidth(int col) const {
  auto it = m_ColumnWidths.find(col);
  return (it != m_ColumnWidths.end()) ? it->second : -1;
}




//==============================================================
// END OF NEW  STUFF
//=============================================================



//============================================================
//  SYSTEM LEVEL EVENT HANDLERS (RouteMapUpdate, Memory Alerts)
//============================================================
// OnPostionKeyDown:
//     Handle key events for positions list
//     Currently only handles Delete key to delete position
//     Other keys are passed to default handler
// OnLeftDown
//    On left mouse button down event handler for both weather routing lists
// OnLeftUp
//     On left mouse button up event handler for both weather routing lists
// OnDownTimer
//    Timer event handler for "press and hold" context menu popup
// OnMemoryAlertStop
//   Handler for memory alert stop event from ASM
// OnMemoryAutoReset
//  Handler for memory auto reset event from ASM
// OnLeftDClick
//    On left double click event handler for positions list
// OnRightUp
//   On right mouse button up event handler for both weather routing lists
//-------------------------------------------------------------

void WeatherRouting::OnPositionKeyDown(wxListEvent& event) {
  switch (event.GetKeyCode()) {
    case WXK_DELETE: {
      wxCommandEvent event;
      OnDeletePosition(event);
    } break;
    default:
      event.Skip();
  }
}

// Shared mouse event handler for both weather routing lists (positions and
// routes) Handles "press and hold" timer for context menu popup
// Allow default selection behavior
void WeatherRouting::OnLeftDown(wxMouseEvent& event) {
  m_tDownTimer.Start(1200, true);
  m_downPos = event.GetPosition();
  event.Skip(); 
}

// Shared mouse event handler for both weather routing lists
// Stops the "press and hold" timer for context menu

void WeatherRouting::OnLeftUp(wxMouseEvent& event) { m_tDownTimer.Stop(); }

void WeatherRouting::OnDownTimer(wxTimerEvent&) {
  int flags = wxLIST_HITTEST_NOWHERE | wxLIST_HITTEST_ONITEM;
  if (m_panel->m_lWeatherRoutes->HitTest(m_downPos, flags) != wxNOT_FOUND)
    m_panel->m_lWeatherRoutes->PopupMenu(m_mContextMenu, m_downPos);
  else
    m_panel->m_lPositions->PopupMenu(m_mContextMenuPositions, m_downPos);
}

void WeatherRouting::OnRightUp(wxMouseEvent& event) {
  if (event.GetEventObject() == m_panel->m_lWeatherRoutes)
    m_panel->m_lWeatherRoutes->PopupMenu(m_mContextMenu, event.GetPosition());
  else
    m_panel->m_lPositions->PopupMenu(m_mContextMenuPositions,
                                     event.GetPosition());
}

void WeatherRouting::OnMemoryAlertStop(wxCommandEvent& event) {
  wxLogMessage("WeatherRouting::OnMemoryAlertStop - BEGIN");

  // Phase 1: signal all workers to stop
  StopAll();

  // Phase 2: wait for all threads to exit
  WaitForAllRoutesToStop();

  // Phase 3: update UI to reflect stopped state
  RefreshUI();

  // Show the AlertStop dialog
  MemoryStatusDialog dlg(this, MemoryDialogMode::AlertStop);
  int r = dlg.ShowModal();

  // If user pressed Reset, perform a full reset
  if (r == wxID_RESET) {
    ResetAll();  // <-- correct call
  }

  wxLogMessage("WeatherRouting::OnMemoryAlertStop - END");
}


void WeatherRouting::OnMemoryAutoReset(wxCommandEvent& event) {
  wxLogMessage("WeatherRouting::OnMemoryAutoReset - BEGIN");

  // Phase 1: signal all workers to stop
  StopAll();

  // Phase 2: wait for all threads to exit
  WaitForAllRoutesToStop();

  // Phase 3: full reset of all overlays
  ResetAll();

  // Show informational dialog
  MemoryStatusDialog dlg(this, MemoryDialogMode::AutoReset);
  dlg.ShowModal();

  wxLogMessage("WeatherRouting::OnMemoryAutoReset - END");
}



/* ============================================================
   UTILITY FUNCTIONS
   ============================================================
   Stateless helpers used by routing and UI layers.
   These do not depend on WeatherRoute instance state.
   ============================================================ */
// Cursor position dialog message
//    Quick helper to set message in cursor position dialog
// Route position dialog message
//    Quick helper to set message in route position dialog
// CursorPRouteChanged
//    Callback when cursor route changes to update plot dialog
// UpdateRoutePositionDialog
//    Update route position dialog based on cursor position
// UpdateCursorPositionDialog



static void CursorPositionDialogMessage(CursorPositionDialog& dlg,
                                        wxString msg) {
  dlg.m_stPosition->SetLabel(msg);
  dlg.m_stPosition->Fit();
  dlg.m_stTime->SetLabel("");
  dlg.m_stPolar->SetLabel("");
  dlg.m_stSailChanges->SetLabel("");
  dlg.m_stTacks->SetLabel("");
  dlg.m_stJibes->SetLabel("");
  dlg.m_stSailPlanChanges->SetLabel("");
  dlg.m_stWeatherData->SetLabel("");
  dlg.Fit();
}

static void RoutePositionDialogMessage(RoutePositionDialog& dlg, wxString msg) {
  dlg.m_stPosition->SetLabel(msg);
  dlg.m_stPosition->Fit();
  dlg.m_stTime->SetLabel("");
  dlg.m_stPolar->SetLabel("");
  dlg.m_stSailChanges->SetLabel("");
  dlg.m_stTacks->SetLabel("");
  dlg.m_stJibes->SetLabel("");
  dlg.m_stSailPlanChanges->SetLabel("");
  dlg.m_stWeatherData->SetLabel("");
  dlg.Fit();
}


// -----------------------------------------------------------------------------
// GetAllOverlays()
// -----------------------------------------------------------------------------
// Returns a vector containing *every* RouteMapOverlay currently managed by the
// WeatherRouting plugin.
//
// ARCHITECTURAL ROLE
// -------------------
// This method provides a unified, authoritative way to enumerate all overlays
// regardless of selection state. It complements GetSelectedOverlays() and
// supports operations that must consider the entire overlay set:
//
//   ? Global reset / StopAll()
//   ? Batch configuration and batch compute
//   ? Diagnostics, logging, and memory monitoring
//   ? Rendering passes that need to inspect overlay state
//   ? Future multi-route editing workflows
//
// SOURCE OF TRUTH
// ---------------
// Overlays are stored in m_RouteMapOverlays, a vector owned by WeatherRouting.
// Access to this container is protected by m_OverlayListMutex to ensure
// thread-safe iteration, since overlays may be created, destroyed, or modified
// by worker threads.
//
// RETURN TYPE
// -----------
// A std::vector<RouteMapOverlay*> is returned because:
//   ? It preserves stable iteration order
//   ? It is easy to pass to algorithms and range-based loops
//   ? It avoids exposing internal container types
//
// SAFETY NOTES
// ------------
//  ? The mutex is locked only long enough to copy pointers out of the master
//    list, minimizing contention with worker threads.
//  ? Null pointers are not expected but are ignored defensively.
// -----------------------------------------------------------------------------

std::vector<RouteMapOverlay*> WeatherRouting::GetAllOverlays() {
  if (m_shuttingDown)
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
      return {};

  std::vector<RouteMapOverlay*> result;

  // Lock the master overlay list for safe iteration
  wxMutexLocker lock(m_OverlayListMutex);

  // Copy all overlay pointers into the result vector
  for (RouteMapOverlay* rmo : m_RouteMapOverlays) {
    if (rmo) result.push_back(rmo);
  }

  return result;
}


// -----------------------------------------------------------------------------
// GetSelectedOverlays()
// -----------------------------------------------------------------------------
// Returns a vector of all RouteMapOverlay objects currently selected in the
// Weather Routing list control.
//
// ARCHITECTURAL ROLE
// -------------------
// This method is the modern replacement for the old CurrentRouteMaps() API.
// The list control (m_lWeatherRoutes) is now the *authoritative source* of
// route selection state. All multi-route operations?cursor updates, batch
// configuration, multi-reset, and future multi-route editing?should use this
// method.
//
// WHY A VECTOR?
// -------------
//  ? Stable iteration order (matches UI order)
//  ? Easy to pass to algorithms and range-based loops
//  ? Avoids the overhead and ambiguity of std::list
//
// SELECTION MODEL
// ---------------
// The list control supports multi-selection. Each selected row stores a
// RouteMapOverlay* in its item data. This method extracts those pointers and
// returns them as a clean, ready-to-use container.
//
// FUTURE EXTENSIONS
// -----------------
//  ? Multi-route editing in ConfigurationDialog
//  ? Multi-route batch generation
//  ? Multi-route Reset() and Compute()
//  ? Selection-based rendering optimizations
//
// SAFETY NOTES
// ------------
//  ? If the panel or list control is missing (e.g., during early construction
//    or teardown), the method returns an empty vector.
//  ? Null item-data pointers are ignored defensively.
// -----------------------------------------------------------------------------

  std::vector<RouteMapOverlay*> WeatherRouting::GetSelectedOverlays() const {
  std::vector<RouteMapOverlay*> result;

  // Defensive: ensure UI components exist
  if (!m_panel || !m_panel->m_lWeatherRoutes) return result;

  long item = -1;

  // Iterate through all selected rows in the list control
  for (;;) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item == -1) break;  // no more selected items

    // Retrieve the overlay pointer stored in the row's item data
    RouteMapOverlay* rmo = reinterpret_cast<RouteMapOverlay*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (rmo) result.push_back(rmo);
  }

  return result;
}



void WeatherRouting::CursorRouteChanged() {
  if (m_PlotDialog.IsShown() && m_PlotDialog.m_rbCursorRoute->GetValue())
    m_PlotDialog.SetRouteMapOverlay(FirstCurrentRouteMap());
}


void WeatherRouting::UpdateCursorPositionDialog() {
  CursorPositionDialog& dlg = m_CursorPositionDialog;

  // Dialog not yet visible ? nothing to do
  if (!dlg.IsShown()) return;

  // Panel or list control not ready yet
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  // No routes yet
  if (m_RouteMapOverlays.empty()) return;

  // Determine which WeatherRoute is selected
  long item = m_panel->m_lWeatherRoutes->GetNextItem(-1, wxLIST_NEXT_ALL,
                                                     wxLIST_STATE_SELECTED);
  if (item < 0) return;

  if (!dlg.IsShown()) return;

  if (item < 0) {
    CursorPositionDialogMessage(dlg, _("Select exactly 1 configuration"));
    return;
  }

  // Retrieve the WeatherRoute and its overlay
  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
      wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

  RouteMapOverlay* rmo = wr ? wr->routemapoverlay : nullptr;

  if (!rmo) {
    CursorPositionDialogMessage(dlg, _("No route map overlay available"));
    return;
  }

  const Position* p = rmo->GetLastCursorPosition();
  if (!p) {
    CursorPositionDialogMessage(dlg, _("Cursor outside computed route map"));
    return;
  }
  wxDateTime display_time = rmo->GetLastCursorTime();

  if (m_SettingsDialog.m_cbUseLocalTime->GetValue())
    display_time = display_time.FromUTC();

  dlg.m_stTime->SetLabel(display_time.Format("%x %H:%M"));

  RouteMapConfiguration configuration = rmo->GetConfiguration();
  auto latStr = toSDMM_PlugIn(NEflag::LAT, p->lat, Precision::HI);
  auto lonStr = toSDMM_PlugIn(NEflag::LON, p->lon, Precision::HI);
  dlg.m_stPosition->SetLabel(latStr + " " + lonStr);

  if (p->polar == -1)
    dlg.m_stPolar->SetLabel(wxEmptyString);
  else {
    wxFileName fn = configuration.boat.Polars[p->polar].FileName;
    dlg.m_stPolar->SetLabel(fn.GetFullName());
  }

  dlg.m_stSailChanges->SetLabel(wxString::Format("%d", p->SailChanges()));

  dlg.m_stTacks->SetLabel(wxString::Format("%d", p->tacks));
  dlg.m_stJibes->SetLabel(wxString::Format("%d", p->jibes));
  dlg.m_stSailPlanChanges->SetLabel(
      wxString::Format("%d", p->sail_plan_changes));

  wxString weatherdata;
  wxString grib = _("Grib") + " ";
  wxString climatology = _("Climatology") + " ";
  wxString data_deficient = _("Data Deficient") + " ";
  wxString wind = _("Wind") + " ";
  wxString current = _("Current") + " ";

  if (p->data_mask & DataMask::GRIB_WIND) weatherdata += grib + wind;
  if (p->data_mask & DataMask::CLIMATOLOGY_WIND)
    weatherdata += climatology + wind;
  if (p->data_mask & DataMask::DATA_DEFICIENT_WIND)
    weatherdata += data_deficient + wind;
  if (p->data_mask & DataMask::GRIB_CURRENT) weatherdata += grib + current;
  if (p->data_mask & DataMask::CLIMATOLOGY_CURRENT)
    weatherdata += climatology + current;
  if (p->data_mask & DataMask::DATA_DEFICIENT_CURRENT)
    weatherdata += data_deficient + current;

  dlg.m_stWeatherData->SetLabel(weatherdata);
  dlg.Fit();
}



  /* New method to display information on the weather route
   * (like starttime, finishtime, time, position, wind, speed, etc.)
   * based on cursor position of the user.
   * This is complementary with the plot chart.
   */

void WeatherRouting::UpdateRoutePositionDialog(RoutePositionDialog & dlg) {
    // ---------------------------------------------------------------------
    // 1. Determine the first selected route map overlay
    //    The list control is the authoritative source of selection.
    // ---------------------------------------------------------------------
    RouteMapOverlay* rmo = FirstCurrentRouteMap();
    if (!rmo) {
      RoutePositionDialogMessage(dlg, _("No route selected"));
      return;
    }
    RouteMapConfiguration configuration = rmo->GetConfiguration();

    // ---------------------------------------------------------------------
    // 2. Determine the closest computed route point to the cursor
    //    getClosestRoutePositionFromCursor() fills PlotData with the
    //    interpolated or exact point along the route.
    // ---------------------------------------------------------------------
    PlotData data;
    Position* closestPosition = rmo->getClosestRoutePositionFromCursor(
        m_weather_routing_pi.m_cursor_lat, m_weather_routing_pi.m_cursor_lon,
        data);

    // Store the position for display in the dialog
    m_positionOnRoute = closestPosition;

    // If no discrete Position* exists but PlotData is valid,
    // fall back to a synthetic saved position
    if (!closestPosition && data.time.IsValid()) {
      m_positionOnRoute = &m_savedPosition;
      m_savedPosition = data;
    }

    // If still nothing, the cursor is outside the computed route map
    if (!m_positionOnRoute) {
      RoutePositionDialogMessage(dlg, _("Cursor outside computed route map"));
      return;
    }

    // ---------------------------------------------------------------------
    // 3. Trip time (start ? cursor)
    // ---------------------------------------------------------------------
    wxDateTime startTime = configuration.StartTime;
    wxDateTime cursorTime = data.time;

    // Convert to local time if requested
    if (m_SettingsDialog.m_cbUseLocalTime->GetValue()) {
      startTime = startTime.FromUTC();
      cursorTime = data.time.FromUTC();
    }

    // Display elapsed time
    wxString time = calculateTimeDelta(startTime, cursorTime);
    dlg.m_stTime->SetLabel(time);

    // ---------------------------------------------------------------------
    // 4. Position (lat/lon)
    // ---------------------------------------------------------------------
    auto latStr = toSDMM_PlugIn(NEflag::LAT, data.lat, Precision::HI);
    auto lonStr = toSDMM_PlugIn(NEflag::LON, data.lon, Precision::HI);
    dlg.m_stPosition->SetLabel(latStr + " " + lonStr);

    // ---------------------------------------------------------------------
    // 5. Polar file used at this point
    // ---------------------------------------------------------------------
    if (data.polar == -1) {
      dlg.m_stPolar->SetLabel(wxEmptyString);
    } else {
      wxFileName fn = configuration.boat.Polars[data.polar].FileName;
      dlg.m_stPolar->SetLabel(fn.GetFullName());
    }

    // ---------------------------------------------------------------------
    // 6. Maneuvers: tacks & jibes
    // ---------------------------------------------------------------------
    dlg.m_stTacks->SetLabel(wxString::Format("%d", data.tacks));
    dlg.m_stJibes->SetLabel(wxString::Format("%d", data.jibes));

    // ---------------------------------------------------------------------
    // 7. Boat speed (SOW/SOG)
    // ---------------------------------------------------------------------
    if (std::abs(data.stw - data.sog) > 0.1) {
      dlg.m_stBoatSpeed->SetLabel(wxString::Format(
          "%.1f knts (SOW), %.1f knts (SOG)", data.stw, data.sog));
    } else {
      dlg.m_stBoatSpeed->SetLabel(wxString::Format("%.1f knts", data.stw));
    }

    // ---------------------------------------------------------------------
    // 8. Boat course (COW/COG)
    // ---------------------------------------------------------------------
    if (std::abs(data.ctw - data.cog) >= 5) {
      dlg.m_stBoatCourse->SetLabel(wxString::Format(
          "%.0f T (COW), %.0f T (COG)", positive_degrees(data.ctw),
          positive_degrees(data.cog)));
    } else {
      dlg.m_stBoatCourse->SetLabel(
          wxString::Format("%.0f T", positive_degrees(data.ctw)));
    }

    // ---------------------------------------------------------------------
    // 9. True wind speed
    // ---------------------------------------------------------------------
    dlg.m_stTWS->SetLabel(wxString::Format("%.0f knts", data.twsOverWater));

    // ---------------------------------------------------------------------
    // 10. True wind angle (port/starboard)
    // ---------------------------------------------------------------------
    double windDirection = heading_resolve(data.ctw - data.twdOverWater);
    wxString windDirectionLabel =
        windDirection <= 0
            ? wxString::Format("%.0f starboard", fabs(windDirection))
            : wxString::Format("%.0f port", fabs(windDirection));
    dlg.m_stTWA->SetLabel(windDirectionLabel);

    // ---------------------------------------------------------------------
    // 11. Apparent wind speed
    // ---------------------------------------------------------------------
    float apparentWindSpeed =
        Polar::VelocityApparentWind(data.stw, windDirection, data.twsOverWater);
    dlg.m_stAWS->SetLabel(wxString::Format("%.0f knts", apparentWindSpeed));

    // ---------------------------------------------------------------------
    // 12. Apparent wind angle (port/starboard)
    // ---------------------------------------------------------------------
    float apparentWindDirection = Polar::DirectionApparentWind(
        apparentWindSpeed, data.stw, windDirection, data.twsOverWater);

    wxString apparentWindDirectionLabel =
        apparentWindDirection <= 0
            ? wxString::Format("%.0f starboard", fabs(apparentWindDirection))
            : wxString::Format("%.0f port", fabs(apparentWindDirection));
    dlg.m_stAWA->SetLabel(apparentWindDirectionLabel);

    // ---------------------------------------------------------------------
    // 13. Waves & wind gusts
    // ---------------------------------------------------------------------
    dlg.m_stWaves->SetLabel(wxString::Format("%.0f m", data.WVHT));
    dlg.m_stWindGust->SetLabel(wxString::Format("%.0f knts", data.VW_GUST));

    // ---------------------------------------------------------------------
    // 14. Climatology / GRIB data mask summary
    // ---------------------------------------------------------------------
    wxString weatherdata;
    wxString grib = _("Grib") + " ";
    wxString climatology = _("Climatology") + " ";
    wxString data_deficient = _("Data Deficient") + " ";
    wxString wind = _("Wind") + " ";
    wxString current = _("Current") + " ";

    if (closestPosition) {
      dlg.m_stSailChanges->SetLabel(
          wxString::Format("%d", closestPosition->SailChanges()));

      if (closestPosition->data_mask & DataMask::GRIB_WIND)
        weatherdata += grib + wind;
      if (closestPosition->data_mask & DataMask::CLIMATOLOGY_WIND)
        weatherdata += climatology + wind;
      if (closestPosition->data_mask & DataMask::DATA_DEFICIENT_WIND)
        weatherdata += data_deficient + wind;

      if (closestPosition->data_mask & DataMask::GRIB_CURRENT)
        weatherdata += grib + current;
      if (closestPosition->data_mask & DataMask::CLIMATOLOGY_CURRENT)
        weatherdata += climatology + current;
      if (closestPosition->data_mask & DataMask::DATA_DEFICIENT_CURRENT)
        weatherdata += data_deficient + current;

      dlg.m_stWeatherData->SetLabel(weatherdata);
    }

    // ---------------------------------------------------------------------
    // 15. Fit dialog to updated content
    // ---------------------------------------------------------------------
    dlg.Fit();
  }




      // This is the parameterless version that uses the member dialog instance
  // It can be called from anywhere in the code without needing to pass the
  // dialog reference
  void WeatherRouting::UpdateRoutePositionDialog() {
    // Dialog not yet visible ? nothing to do
    if (!m_RoutePositionDialog.IsShown()) return;

    // Panel or list control not ready yet ? bail out
    if (!m_panel || !m_panel->m_lWeatherRoutes) return;

    // No overlays yet ? nothing meaningful to show
    if (m_RouteMapOverlays.empty()) return;

    UpdateRoutePositionDialog(m_RoutePositionDialog);
  }



// clean, compact way to bail out of a function when something fail
// Store the error code.Jump to a cleanup label at the bottom of the function.
// This makes the macro behave like a single statement, so you can safely write:
// if(!OpenXML()) FAIL(1);     without breaking the if block.
// plugin has several functions that:open files, parse XML,
// allocate objects, need cleanup on failure

#define FAIL(X)  \
  do {           \
    error = X;   \
    goto failed; \
  } while (0)


// OLD CODE NO LONGER USED
// Starts the scheduler timer.  OLDER
/* ^void WeatherRouting::UpdateComputeState() {
  m_panel->m_gProgress->SetRange(m_RoutesToRun);
  m_panel->m_gProgress->SetValue(0);
  m_mCompute->Enable();
  m_panel->m_bCompute->Enable();
  m_StartTime = wxDateTime::Now();
  m_tCompute.Start(1, true);
}
*/


/*********************************************************/
/*   3. Invariants Violation  Guardrails                 */
/*********************************************************/

void WeatherRouting::AssertAllInvariants() {
  AssertSchedulerInvariants();
  AssertThreadLifecycleInvariants();
}

void WeatherRouting::AssertSchedulerInvariants() {
  // No overlay appears in both lists
  for (auto* ov : m_WaitingRouteMaps) {
    wxASSERT_MSG(std::find(m_RunningRouteMaps.begin(), m_RunningRouteMaps.end(),
                           ov) == m_RunningRouteMaps.end(),
                 "Overlay appears in both waiting and running lists");
  }

  // Running overlays must have threads
  for (auto* ov : m_RunningRouteMaps) {
    wxASSERT_MSG(ov->HasThread(), "Running overlay has no thread");
  }

  // Waiting overlays must NOT have threads
  for (auto* ov : m_WaitingRouteMaps) {
    wxASSERT_MSG(!ov->HasThread(), "Waiting overlay incorrectly has a thread");
  }
}


void WeatherRouting::AssertThreadLifecycleInvariants() {
  for (auto* ov : m_RouteMapOverlays) {
    if (!ov) continue;

    // If overlay says it has a thread, pointer must be valid
    if (ov->HasThread()) {
      wxASSERT_MSG(ov->m_Thread != nullptr,
                   "Overlay reports HasThread() but m_Thread is null");
    }

    // If overlay is running, thread must be alive
    if (ov->Running()) {
      wxASSERT_MSG(ov->HasThread(),
                   "Overlay reports Running() but HasThread() is false");
    }

    // If overlay is finished, thread must be gone
    if (ov->Finished()) {
      wxASSERT_MSG(!ov->HasThread(),
                   "Overlay reports Finished() but thread still exists");
    }

    // If overlay is stopped, thread must be gone
    if (ov->m_Stopped) {
      wxASSERT_MSG(!ov->HasThread(),
                   "Overlay reports m_Stopped but thread still exists");
    }
  }
}


/*********************************************************/
/*   3. Initialization Helper                              */
/*********************************************************/
//StartCompute
//   Column initialization, Timer setup, Dialog creation
//   Event bindings
//  NOTE: Heavy lifting initialization is in Initialize()
//   to keep constructor clean
//  This method is called by Initialize() after
//    the plugin environment is fully ready for use.
//  This funcion starts the compute timer if there is work to do.
//   Alternatively, StartCompute() can be called
//  from other places when new work is added.
//*********************************************************/

/* Kick start the scheduler and computing*/
void WeatherRouting::StartCompute() {
  // Only start the scheduler timer if:
  // 1. We actually have work to do (m_bRunning == true)
  // 2. The timer is not already running
  if (m_bRunning && !m_tCompute.IsRunning()) {
    wxLogMessage("StartCompute(): Starting scheduler timer (25ms one-shot)");
    m_tCompute.Start(25, true);
  }
  AssertThreadLifecycleInvariants();
}


bool WeatherRouting::IsWaiting(const RouteMapOverlay* rmo) const {
  for (auto* w : m_WaitingRouteMaps)
    if (w == rmo) return true;
  return false;
}


/******************************************************************/
/*  4. Top?Level Thread and UI Syncrhonization and Event Handlers */
/******************************************************************/

//-----------------------------------------------------------------
//   4.1 EVT_ROUTEMAP_UPDATE Handler(UI Choke Point)
//-----------------------------------------------------------------
// This is the single choke point for all UI updates.
// All worker-thread completions funnel through this event.
// Ensures UpdateStates(), UpdateDialogs(), and UpdateComputeState()
// run on the main thread in a race-free, deterministic order.
// NOTE: This event is posted by worker threads when they complete
// their computations. All UI updates MUST occur here!!!
//-----------------------------------------------------------------

    void WeatherRouting::OnRouteMapUpdate(wxThreadEvent& event) {
      wxLogMessage("WeatherRouting::OnRouteMapUpdate - BEGIN");

      UpdateDialogs();
      UpdateComputeState();

      wxLogMessage("WeatherRouting::OnRouteMapUpdate - END");
    }




//----------------------------------
//   4.1 File / Session
//----------------------------------
// OnOpen
//    Opens an existing weather routing configuration XML file.
// OnSave
//    Saves the current configuration to the existing XML file.
// OnSaveAs
//    Saves the current configuration to a new XML file.
//----------------------------------


void WeatherRouting::OnOpen(wxCommandEvent& event) {
  wxString error;
  wxFileDialog openDialog(
      this, _("Select Configuration"), m_FileName.GetPath(),
      m_FileName.GetName(),
      wxT("XML files (*.xml)|*.XML;*.xml|All files (*.*)|*.*"), wxFD_OPEN);

  if (openDialog.ShowModal() == wxID_OK) {
    wxCommandEvent event;
    OnDeleteAllPositions(event);
    OnDeleteAll(event);
    OpenXML(openDialog.GetPath());
  }
}

void WeatherRouting::OnSave(wxCommandEvent& event) {
  if (m_FileName.GetFullPath().IsEmpty()) {
    // No file path set yet, behave like Save As
    OnSaveAs(event);
    return;
  }

  SaveXML(m_FileName.GetFullPath());
  m_tAutoSaveXML
      .Stop();  // Stop any pending auto-save since we just manually saved
}

void WeatherRouting::OnSaveAs(wxCommandEvent& event) {
  wxString error;
  wxFileDialog saveDialog(
      this, _("Select Configuration"), m_FileName.GetPath(),
      m_FileName.GetName(),
      wxT("XML files (*.xml)|*.XML;*.xml|All files (*.*)|*.*"),
      wxFD_SAVE | wxFD_OVERWRITE_PROMPT);

  if (saveDialog.ShowModal() == wxID_OK) {
    // Use wxFileDialog::AppendExtension to ensure the file has the .xml
    // extension
    wxString filename =
        wxFileDialog::AppendExtension(saveDialog.GetPath(), "*.xml");

    SaveXML(filename);
    m_tAutoSaveXML
        .Stop();  // Stop any pending auto-save since we just manually saved
  }
}


/***********************************************************************
 * WeatherRouting Close Handlers
 *
 * WeatherRouting implements two different OnClose() handlers:
 *
 *   1. void OnClose(wxCloseEvent& event)
 *   2. void OnClose(wxCommandEvent& event)
 *
 * These two handlers serve different purposes and MUST NOT call each
 * other recursively. Their responsibilities are intentionally distinct:
 *
 * --------------------------------------------------------------------
 * 1. OnClose(wxCloseEvent&)
 * --------------------------------------------------------------------
 * Triggered when the user clicks the window managers X button or
 * when wxWidgets attempts to close the panel programmatically.
 *
 * OpenCPN plugins must NEVER allow their main panel to be destroyed
 * by a wxCloseEvent. The panel is owned by OpenCPN, not the plugin.
 *
 * Therefore:
 *   - We VETO the close request to prevent destruction.
 *   - We forward the intent to the command-version handler so the
 *     plugin can hide itself cleanly.
 *
 * This keeps the plugin alive and prevents crashes or dangling pointers.
 *
 * --------------------------------------------------------------------
 * 2. OnClose(wxCommandEvent&)
 * --------------------------------------------------------------------
 * Triggered when the plugin itself decides to close/hide the panel
 * (toolbar button, menu item, or forwarded from the wxCloseEvent
 * handler above).
 *
 * This handler performs the *actual* close behavior:
 *   - Hide the panel (never destroy it)
 *   - Stop computations safely
 *   - Persist visibility state
 *   - Update menus and refresh UI
 *
 * This is the correct OpenCPN plugin pattern: hide, don?t destroy.
 *
 * --------------------------------------------------------------------
 * Summary
 * --------------------------------------------------------------------
 * wxCloseEvent  -  Veto + forward to command handler
 * wxCommandEvent -  Perform safe hide + state updates
 *
 * This separation ensures:
 *   - No recursion
 *   - No accidental destruction
 *   - Clean shutdown of computations
 *   - Correct persistence of UI state
 *   - Full compatibility with OpenCPN?s plugin lifecycle
 ***********************************************************************/


void WeatherRouting::OnClose(wxCommandEvent& event) {
  // handler for your plugin?s own ?Close/Hide? command.
  // Hide the panel instead of destroying it.
  // This is the standard OpenCPN plugin pattern.
  Hide();

  // Persist window state (size, position, visibility)
  wxFileConfig* pConf = GetOCPNConfigObject();
  if (pConf) {
    pConf->SetPath("/Plugins/WeatherRouting");
    pConf->Write("Visible", false);
  }

  // Stop any running computations safely
  StopAll();

  // Update menus and toolbar buttons
  SetEnableConfigurationMenu();

  // Ensure UI refreshes cleanly
  GetParent()->Refresh();
}

void WeatherRouting::OnClose(wxCloseEvent& event) {
  // Window Manager close or plugin hide command received.
  // Prevent wxWidgets from destroying the panel.
  // OpenCPN owns this window; plugins must never allow destruction here.
  event.Veto();

  // Convert the window-manager close (clicking ?X?) into the same behavior
  // as pressing the plugin?s own ?close/hide? command.
  wxCommandEvent cevent;
  OnClose(cevent);  // Call the command-version safely

  // No event.Skip() here ? we?ve handled the close fully.
}

void WeatherRouting::OnAutoSaveXMLTimer(wxTimerEvent&) {
    AutoSaveXML();
}

void WeatherRouting::AutoSaveXML() {
    SaveXML(m_FileName.GetFullPath());
}



//----------------------------------
//   4.2 Route Creation / Deletion
//----------------------------------
// OnNew
//    Creates a new routing configuration.
// OnRenderedTimer
//    Sets initial sash position after rendering starts.
// OnSize
//    Handles resizing of the main panel.
// OnCollPaneChanged
//    Handles changes to the collapsible pane state.
// OnDelete
//    Deletes selected routing configurations.
// OnDeleteAll
//    Deletes all routing configurations
// OnEditPosition - Seen in Position Management section
//    Edits the selected position. See 6. Position Management section. 
//----------------------------------


void WeatherRouting::OnNew(wxCommandEvent& event) {
  // Create an empty configuration object
  RouteMapConfiguration configuration;

  // Pass the configuration into the dialog
  m_ConfigurationDialog.SetConfiguration(configuration);

  // Show the dialog (no arguments allowed)
  if (m_ConfigurationDialog.ShowModal() != wxID_OK) {
    // User cancelled
    return;
  }

  // Retrieve the updated configuration from the dialog
  configuration = m_ConfigurationDialog.GetConfiguration();

  // Add the new configuration to the model + UI
  if (!AddConfiguration(configuration)) {
    wxMessageDialog mdlg(this, _("Failed to create new routing configuration."),
                         _("Weather Routing"), wxOK | wxICON_ERROR);
    mdlg.ShowModal();
    return;
  }

  // Update menus and UI state
  SetEnableConfigurationMenu();
}

void WeatherRouting::OnRenderedTimer(wxTimerEvent&) {
  // don't do it until the window system is up and running
  if (GetClientSize().GetWidth() > 20) {
    if (!sashpos) sashpos = GetClientSize().GetWidth() / 5;
    m_panel->m_splitter1->SetSashPosition(sashpos, true);
    Disconnect(wxEVT_IDLE, wxTimerEventHandler(WeatherRouting::OnRenderedTimer),
               NULL, this);
  }
}

void WeatherRouting::OnSize(wxSizeEvent& event) {
  if (m_colpane && m_colpane->IsExpanded()) {
    Update();
    Layout();
    m_size = GetSize();
  } else {
    if (m_colpane) Fit();
  }
  event.Skip();
}

//-
void WeatherRouting::OnCollPaneChanged(wxCollapsiblePaneEvent& event) {
  if (m_colpane && m_colpane->IsExpanded())
    SetSize(m_size);
  else if (m_colpane)
    Fit();
  Update();
  Layout();
}



// OLD CODE NO LONGER USED
/*
void WeatherRouting::OnDelete(wxCommandEvent& event) {
  // Stop all computations to avoid thread corruption.
  StopAll();
  // Determine which WeatherRoute is selected
  long index = m_panel->m_lWeatherRoutes->GetNextItem(-1, wxLIST_NEXT_ALL,
                                                      wxLIST_STATE_SELECTED);
  if (index < 0) return;
  // Retrieve the WeatherRoute
  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
      wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(index)));
  if (!wr || !wr->routemapoverlay) return;
  // Delete only the selected route map overlay
  std::list<RouteMapOverlay*> toDelete;
  toDelete.push_back(wr->routemapoverlay);
  DeleteRouteMaps(toDelete);
  // Select the next logical row
  int cnt = m_panel->m_lWeatherRoutes->GetItemCount();
  m_panel->m_lWeatherRoutes->SetItemState(index == cnt ? index - 1 : index,
                                          wxLIST_STATE_SELECTED,
                                          wxLIST_STATE_SELECTED);
  GetParent()->Refresh();
  // Schedule auto-save in 5 seconds
  m_tAutoSaveXML.Start(5000, true);
}

void WeatherRouting::OnDeleteAll(wxCommandEvent& event) {
  std::list<RouteMapOverlay*> allroutemapoverlays;
  for (int i = 0; i < m_panel->m_lWeatherRoutes->GetItemCount(); i++) {
    WeatherRoute* weatherroute = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));
    allroutemapoverlays.push_back(weatherroute->routemapoverlay);
  }
  DeleteRouteMaps(allroutemapoverlays);
  GetParent()->Refresh();
  m_tAutoSaveXML.Start(5000, true);  // Schedule auto-save in 5 seconds
}
*/

//----------------------------------
//   4.3 Reset
//----------------------------------
// OnReset  
// .. Resets a route
// OnResetSelected
//    Resets selected routes.
// OnResetAll
//    Resets all routes.
//----------------------------------

//void WeatherRouting::OnReset(wxCommandEvent& event)
//  { ResetAll();
//}

void WeatherRouting::OnResetSelected(wxCommandEvent& event) {
  ResetSelected();
}

void WeatherRouting::OnResetAll(wxCommandEvent& event) {
   m_StatisticsDialog.SetRunTime(m_RunTime = wxTimeSpan(0));
   ResetAll();
}


//----------------------------------
//   4.4 Compute / Stop
//----------------------------------
// OnCompute
//   build waiting list from selected routes
// OnComputeAll
//   build waiting list from all routes
// OnComputationTimer
//   the actual routing engine
// OnComputeAll
//    Starts route computation for all routes.
// OnStop
//    Stops route computation for selected routes.
// RouteMapOverlay
//  each overlay has its own thread and state machine
// Start
//   create worker threads
// StartAll
//   create worker threads for all routes
// Stop
//   signal worker threads to stop, but do not wait for them here. The threads
// StartCompute
//  Keep small prevents subtle bugs and makes the scheduler predictable.

//----------------------------------

void WeatherRouting::OnCompute(wxCommandEvent& event) {
#ifdef PLUGIN_USE_ASM
  // If the address space monitor is active and memory is critically low,
  // route computation is disabled to prevent instability.
  if (m_addressSpaceMonitor && m_addressSpaceMonitor->IsComputationDisabled()) {
    wxMessageBox(
        _("Route computation is currently disabled due to high memory usage.\n"
          "Use Reset All or wait until memory is available."),
        _("Weather Routing - Memory Alert"), wxOK | wxICON_WARNING);
    return;
  }
#endif

  wxLogMessage("OnCompute(): Preparing selected routes for computation.");

  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  //    The list control is the authoritative source of selection.
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> selectedOverlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    // Retrieve the WeatherRoute associated with this row
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    // Only enqueue overlays that actually exist
    if (wr && wr->routemapoverlay)
      selectedOverlays.push_back(wr->routemapoverlay);
  }

  // If nothing is selected, there is nothing to compute
  if (selectedOverlays.empty()) return;

  // ---------------------------------------------------------------------
  // 2. Reset scheduler lists
  //    These lists drive the asynchronous computation scheduler.
  // ---------------------------------------------------------------------
  m_WaitingRouteMaps.clear();
  m_RunningRouteMaps.clear();

  // ---------------------------------------------------------------------
  // 3. Populate the waiting list with selected overlays
  // ---------------------------------------------------------------------
  for (auto* ov : selectedOverlays) m_WaitingRouteMaps.push_back(ov);

  // ---------------------------------------------------------------------
  // 4. Initialize scheduler counters and state
  // ---------------------------------------------------------------------
  m_RoutesToRun = m_WaitingRouteMaps.size();
  m_bRunning = (m_RoutesToRun > 0);

  // ---------------------------------------------------------------------
  // 5. If there is work to do, update UI and start the scheduler
  // ---------------------------------------------------------------------
  if (m_bRunning) {
    UpdateComputeState();  // Update buttons, progress bar, status text
    StartCompute();        // Begin timed scheduling of route computations
  }
}


void WeatherRouting::OnComputeAll(wxCommandEvent& event) {
#ifdef PLUGIN_USE_ASM
  if (m_addressSpaceMonitor && m_addressSpaceMonitor->IsComputationDisabled()) {
    wxMessageBox(
        _("Route computation is currently disabled due to high memory usage.\n"
          "Use Reset All or wait until memory is available."),
        _("Weather Routing - Memory Alert"), wxOK | wxICON_WARNING);
    return;
  }
#endif

  wxLogMessage(
      "OnComputeAll(): For all Routes, Prep to compute, Create Overlay wait "
      "list, Clear running list, Call StartCompute.");

  // Build waiting list from ALL route overlays
  StartAll();  // fills m_WaitingRouteMaps, sets m_bRunning, m_RoutesToRun

  if (!m_bRunning) return;  // nothing to compute

  // Initialize progress bar if present
  if (m_panel && m_panel->m_gProgress) {
    m_panel->m_gProgress->SetRange(m_RoutesToRun);
    m_panel->m_gProgress->SetValue(0);
  }

  UpdateComputeState();  // update UI (buttons, labels, etc.)
  StartCompute();        // ignite the scheduler timer
}

void WeatherRouting::OnStop(wxCommandEvent& event) {
  wxLogMessage("OnStop(): stopping selected routes");

  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  //    The list control is the authoritative source of selection.
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> selectedOverlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    // Retrieve the WeatherRoute associated with this row
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay)
      selectedOverlays.push_back(wr->routemapoverlay);
  }

  // If nothing is selected, nothing to stop
  if (selectedOverlays.empty()) return;

  // ---------------------------------------------------------------------
  // 2. Signal each selected overlay to stop
  //    Stop(ov) sets the overlay's stop flag; the scheduler timer
  //    will handle cleanup and thread shutdown.
  // ---------------------------------------------------------------------
  for (auto* ov : selectedOverlays) {
    if (!ov) continue;
    Stop(ov);
  }

  // ---------------------------------------------------------------------
  // 3. Update UI state (buttons, labels, progress bar, etc.)
  // ---------------------------------------------------------------------
  UpdateComputeState();

  // Optional: debug-only invariant check could go here
}




//------------------------------------------
//   4.5 Selection / Sorting / Interaction
//------------------------------------------- List Includes Control Event Handlers --
// 
// OnWeatherRouteSelected
//    Updates the configuration dialog when the user selects a route.
// OnWeatherPositionSelected
//    Updates the position dialog when the user selects a position.
// OnWeatherRouteSort
//    Sorts the weather routes list when the user clicks a column header.
// OnWeatherRoutesListLeftDown
//    Handles clicks on the visibility column to toggle route visibility.
// OnWeatherRouteKeyDown
//    Handles delete key to remove selected routes.
// OnListLabelEdit
//   Handles in-place editing of route names and positions.(NOT USED)
//
//
// -----------------------------------------
// OnPositionKeyDown
// OnRouteSelected
// OnCursorRouteChanged if event driven
//------------------------------------------

void WeatherRouting::OnWeatherRouteSelected() {
  // Refresh parent window to update map highlights, etc.
  GetParent()->Refresh();

  // ---------------------------------------------------------------------
  // 1. Collect selected WeatherRoutes from the list control
  //    The list control is the authoritative source of selection.
  // ---------------------------------------------------------------------
  std::list<WeatherRoute*> selectedRoutes;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr) selectedRoutes.push_back(wr);
  }

  // ---------------------------------------------------------------------
  // 2. Build configuration list and update cursor position for each route
  // ---------------------------------------------------------------------
  std::list<RouteMapConfiguration> currentConfigurations;

  for (auto* wr : selectedRoutes) {
    RouteMapOverlay* ov = wr->routemapoverlay;
    if (!ov) continue;

    // Update cursor position for this overlay
    ov->SetCursorLatLon(m_weather_routing_pi.m_cursor_lat,
                        m_weather_routing_pi.m_cursor_lon);

    // Collect its configuration for the Configuration dialog
    currentConfigurations.push_back(ov->GetConfiguration());
  }

  // ---------------------------------------------------------------------
  // 3. Update the Configuration dialog visibility and content
  // ---------------------------------------------------------------------
  if (selectedRoutes.empty()) {
    // No selection ? hide configuration dialog after a short delay
    m_tHideConfiguration.Start(25, true);
  } else {
    m_tHideConfiguration.Stop();
    m_bSkipUpdateCurrentItems = true;
    m_ConfigurationDialog.SetConfigurations(currentConfigurations);
    m_bSkipUpdateCurrentItems = false;
  }

  // ---------------------------------------------------------------------
  // 4. Update all other dialogs (statistics, report, plot, etc.)
  // ---------------------------------------------------------------------
  UpdateDialogs();

  // ---------------------------------------------------------------------
  // 5. Update the Routing Table panel if it exists and is visible
  // ---------------------------------------------------------------------
  if (m_RoutingTablePanel) {
    wxAuiManager* pauimgr = ::GetFrameAuiManager();
    wxAuiPaneInfo& pane = pauimgr->GetPane(m_RoutingTablePanel);

    if (pane.IsOk() && pane.IsShown() && !selectedRoutes.empty()) {
      // Use the first selected route for the routing table
      WeatherRoute* wr = selectedRoutes.front();
      RouteMapOverlay* ov = wr->routemapoverlay;

      ((RoutingTablePanel*)m_RoutingTablePanel)->m_RouteMap = ov;
      ((RoutingTablePanel*)m_RoutingTablePanel)->PopulateTable();
    }
  }

  // ---------------------------------------------------------------------
  // 6. Enable/disable menu items based on selection state
  // ---------------------------------------------------------------------
  SetEnableConfigurationMenu();
}

void WeatherRouting::OnWeatherPositionSelected() {
  // For now, just refresh the parent to update the display
  // This can be extended in the future to handle position-specific logic
  GetParent()->Refresh();
}

void WeatherRouting::OnWeatherRouteSort(wxListEvent& event) {
  sortcol = event.GetColumn();
  sortorder = -sortorder;

  if (sortcol == 0) {
    for (int index = 0; index < m_panel->m_lWeatherRoutes->GetItemCount();
         index++) {
      WeatherRoute* weatherroute = reinterpret_cast<WeatherRoute*>(
          wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(index)));
      weatherroute->routemapoverlay->m_bEndRouteVisible = sortorder == 1;
      UpdateItem(index, false);
    }
    RequestRefresh(GetParent());
  } else {
#if wxCHECK_VERSION(2, 9, 0)
    m_panel->m_lWeatherRoutes->SortItems(SortWeatherRoutes,
                                         (wxIntPtr)m_panel->m_lWeatherRoutes);
#else
    m_panel->m_lWeatherRoutes->SortItems(SortWeatherRoutes,
                                         (long)m_panel->m_lWeatherRoutes);
#endif
  }
}

void WeatherRouting::OnWeatherRoutesListLeftDown(wxMouseEvent& event) {
  OnLeftDown(event);
  wxPoint pos = event.GetPosition();
  int flags = 0;
  long index = m_panel->m_lWeatherRoutes->HitTest(pos, flags);

  // Do we have the Visibility column?
  if (columns[VISIBLE] >= 0) {
    int minx = 0,
        maxx = m_panel->m_lWeatherRoutes->GetColumnWidth(columns[VISIBLE]);

    //    Clicking Visibility column?
    if (index >= 0 && event.GetX() >= minx && event.GetX() < maxx) {
      // Process the clicked item
      WeatherRoute* weatherroute = reinterpret_cast<WeatherRoute*>(
          wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(index)));
      weatherroute->routemapoverlay->m_bEndRouteVisible =
          !weatherroute->routemapoverlay->m_bEndRouteVisible;
      UpdateItem(index, false);
      RequestRefresh(GetParent());
    }
  }

  // Allow wx to process...
  event.Skip();
}

void WeatherRouting::OnWeatherRouteKeyDown(wxListEvent& event) {
  switch (event.GetKeyCode()) {
    case WXK_DELETE: {
      wxCommandEvent event;
      OnDelete(event);
    } break;
    default:
      event.Skip();
  }
}



#if 0 /* wx widgets is shit, can only allow users \
         to edit the first column, so this doesn't work */
void WeatherRouting::OnListLabelEdit( wxListEvent& event )
{
    long index = event.GetIndex();
    int col = event.GetColumn();

    long i = 0;
    for(std::list<RouteMapPosition>::iterator it = RouteMap::Positions.begin();
        it != RouteMap::Positions.end(); it++, i++)
        if(i == index) {
            if(col == POSITION_NAME) {
                (*it).Name = event.GetText();
            } else {
                double value;
                event.GetText().ToDouble(&value);
                if(col == POSITION_LAT)
                    (*it).lat = value;
                else if(col == POSITION_LON)
                    (*it).lon = value;

                m_lPositions->SetItem(index, col, wxString::Format("%.5f", value));
                UpdateConfigurations();
            }
        }
}
#endif


//------------------------------------------
//   4.6 Navigation
//------------------------------------------
// OnGoTo
//    Jumps the chart to show all selected routes.

void WeatherRouting::OnGoTo(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // 1. Collect all valid RouteMapOverlays from m_WeatherRoutes
  //    This replaces the old CurrentRouteMaps(true) call.
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  for (auto* wr : m_WeatherRoutes) {
    if (!wr || !wr->routemapoverlay) continue;

    RouteMapConfiguration cfg = wr->routemapoverlay->GetConfiguration();
    if (std::isnan(cfg.StartLat)) continue;  // skip invalid routes

    overlays.push_back(wr->routemapoverlay);
  }

  if (overlays.empty()) return;

  // ---------------------------------------------------------------------
  // 2. Compute centroid of all selected route start/end points
  // ---------------------------------------------------------------------
  double avg_lat = 0, avg_lonx = 0, avg_lony = 0, total = 0;

  for (auto* ov : overlays) {
    RouteMapConfiguration cfg = ov->GetConfiguration();
    if (std::isnan(cfg.StartLat)) continue;

    avg_lat += cfg.StartLat + cfg.EndLat;
    avg_lonx += cos(deg2rad(cfg.StartLon)) + cos(deg2rad(cfg.EndLon));
    avg_lony += sin(deg2rad(cfg.StartLon)) + sin(deg2rad(cfg.EndLon));

    total += 2;
  }

  avg_lat /= total;
  avg_lonx /= total;
  avg_lony /= total;

  double avg_lon = rad2deg(atan2(avg_lony, avg_lonx));

  // ---------------------------------------------------------------------
  // 3. Compute maximum distance from centroid to determine zoom level
  // ---------------------------------------------------------------------
  double max_distance = 0;

  for (auto* ov : overlays) {
    RouteMapConfiguration cfg = ov->GetConfiguration();
    if (std::isnan(cfg.StartLat)) continue;

    double distance;

    DistanceBearingMercator_Plugin(avg_lat, avg_lon, cfg.StartLat, cfg.StartLon,
                                   NULL, &distance);
    max_distance = wxMax(max_distance, distance);

    DistanceBearingMercator_Plugin(avg_lat, avg_lon, cfg.EndLat, cfg.EndLon,
                                   NULL, &distance);
    max_distance = wxMax(max_distance, distance);
  }

  // ---------------------------------------------------------------------
  // 4. Jump to the computed centroid with appropriate zoom
  // ---------------------------------------------------------------------
  if (max_distance > 1e-4) {
    JumpToPosition(avg_lat, avg_lon, .125 / max_distance);
  } else {
    wxMessageDialog mdlg(this, _("Cannot goto invalid route(s)."),
                         _("Weather Routing"), wxOK | wxICON_ERROR);
    mdlg.ShowModal();
  }
}

/* ============================================================
   UI UPDATE & DISPLAY SYNCHRONIZATION
   ------------------------------------------------------------
   Functions that refresh dialog state, map overlays, and
   presentation logic. These do not compute routing results.
   They only reflect current state into the UI.
   ============================================================ */
// UpdateDisplaySettings
//    Updates the display settings of all route map overlays
//    to reflect changes in global display options.
//    Called when global display settings change.
//    Marks all overlays for update and requests a refresh.
//------------------------------------------------------------


void WeatherRouting::UpdateDisplaySettings() {
  for (int i = 0; i < m_panel->m_lWeatherRoutes->GetItemCount(); i++) {
    WeatherRoute* weatherroute = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));
    weatherroute->routemapoverlay->m_UpdateOverlay = true;
  }

  GetParent()->Refresh();
}


/* ============================================================
   UI REACTION HANDLERS
   ------------------------------------------------------------
   Functions that respond to UI state changes (dialogs, radio
   buttons, selections) and update overlays or dialogs.
   These do not compute routing or modify configuration.
   ============================================================ */


static double ComputeRouteDistance(const Position* dest) {
  double total = 0.0;

  const Position* p = dest;
  while (p && p->parent) {
    const Position* q = static_cast<const Position*>(p->parent);
    total += p->Distance(q);
    p = q;
  }

  return total;
}



//------------------------------------------
//   4.7 Dialogs EVENT HANDLERS ? Configuration / Settings Dialogs
//------------------------------------------
//
// --- Button Command Event Handlers ---
//
// OnEditConfiguration
//    Opens the Configuration dialog for the selected route(s)
//    This is the main edit function for configurations.
// OnUpdateBoat
//    Updates the "Boat" position to the current boat location
//    This is called when the user requests to update the boat position
// OnDelete          See 6 Route Creation / Deletion
// OnDeletePosition  See 6 Position Management


void WeatherRouting::OnEditConfiguration() {
  // ---------------------------------------------------------------------
  // 1. Determine which WeatherRoutes are selected
  //    The list control is the authoritative source of selection.
  // ---------------------------------------------------------------------
  std::list<RouteMapConfiguration> selectedConfigs;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (!wr || !wr->routemapoverlay) continue;

    // Collect the configuration for the dialog
    selectedConfigs.push_back(wr->routemapoverlay->GetConfiguration());
  }

  // If nothing is selected, nothing to edit
  if (selectedConfigs.empty()) return;

  // ---------------------------------------------------------------------
  // 2. Show the configuration dialog populated with selected configurations
  // ---------------------------------------------------------------------
  m_bSkipUpdateCurrentItems = true;
  m_ConfigurationDialog.SetConfigurations(selectedConfigs);
  m_bSkipUpdateCurrentItems = false;

 m_ConfigurationDialog.Show();
}


void WeatherRouting::OnUpdateBoat(wxCommandEvent& event) {
  double lat = m_weather_routing_pi.m_boat_lat;
  double lon = m_weather_routing_pi.m_boat_lon;

  long index = 0;
  for (std::list<RouteMapPosition>::iterator it = RouteMap::Positions.begin();
       it != RouteMap::Positions.end(); it++, index++)
    if ((*it).Name == _("Boat")) {
      m_panel->m_lPositions->SetItem(
          index, POSITION_LAT, toSDMM_PlugIn(NEflag::LAT, lat, Precision::HI));
      m_panel->m_lPositions->SetItem(
          index, POSITION_LON, toSDMM_PlugIn(NEflag::LON, lon, Precision::HI));

      (*it).lat = lat, (*it).lon = lon;
      UpdateConfigurations();
      return;
    }

  AddPosition(lat, lon, _("Boat"), false);
}


//------------------------------------------
// -- Dialog Interaction Handlers --
//
// OnSettings
//    Opens the Settings dialog on request from the menu.
// OnFilter 
//    Opens the Filter Routes dialog on request from the menu.
// OnStatistics
//    Opens the Statistics dialog on request from the menu.
// OnReport
//    Opens the Report dialog on request from the menu.
// OnCursorPosition
//    Toggles the Cursor Position dialog on request from the menu.
// OnRoutePosition
//    Toggles the Route Position dialog on request from the menu.
// OnBatch
//    Opens the Batch Configuration dialog on request from the menu.
//  OnUpdateBoat
//    Updates the "Boat" position to the current boat location

//------------------------------------------


void WeatherRouting::OnSettings(wxCommandEvent& event) {
  m_SettingsDialog.Show();
}

void WeatherRouting::OnFilter(wxCommandEvent& event) {
  m_FilterRoutesDialog.Show();
}

void WeatherRouting::OnStatistics(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // Collect overlays for all selected WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  if (overlays.empty()) return;

  m_StatisticsDialog.SetRouteMapOverlays(overlays);
  m_StatisticsDialog.Show();
}

void WeatherRouting::OnReport(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // Collect overlays for all selected WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  if (overlays.empty()) return;

  m_ReportDialog.SetRouteMapOverlays(overlays);
  m_ReportDialog.Show();
}

void WeatherRouting::OnCursorPosition(wxCommandEvent& event) {
  m_CursorPositionDialog.Show(!m_CursorPositionDialog.IsShown());
  UpdateCursorPositionDialog();
}

void WeatherRouting::OnRoutePosition(wxCommandEvent& event) {
  m_RoutePositionDialog.Show(!m_RoutePositionDialog.IsShown());
  UpdateRoutePositionDialog();
}

void WeatherRouting::OnBatch(wxCommandEvent& event) {
  if (m_ConfigurationBatchDialog.IsShown()) return;

  // Reset the batch UI dialog (UI only, not engine state)
  m_ConfigurationBatchDialog.Reset();
  m_ConfigurationBatchDialog.Show();
}

void WeatherRouting::OnPlot(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // Use the *first selected* WeatherRoute for plotting
  // ---------------------------------------------------------------------
  long item = m_panel->m_lWeatherRoutes->GetNextItem(-1, wxLIST_NEXT_ALL,
                                                     wxLIST_STATE_SELECTED);

  if (item < 0) return;

  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
      wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

  if (!wr || !wr->routemapoverlay) return;

  m_PlotDialog.SetRouteMapOverlay(wr->routemapoverlay);
  m_PlotDialog.Show();
}


//-----------------------------------------------------------
//   4.8  UI Commands: Help / Information / Auxiliary Dialogs
//-----------------------------------------------------------
// OnWeatherTable
//    This function opens the Weather Routing Table panel.
//    and adds it to the AUI manager if not already present.
//    upon user request from the menu.
// OnManual
//    This function opens the Weather Routing User Manual
//    in the default web browser upon user request from the menu.
// OnInformation
//   This function opens the Weather Routing Information
//   HTML file in the default web browser upon user request from the menu.
// OnAbout
//   This function opens the About dialog upon user request from the menu.
//-----------------------------------------------------------

void WeatherRouting::OnWeatherTable(wxCommandEvent& event) {
  AddRoutingPanel();
}

void WeatherRouting::OnManual(wxCommandEvent& event) {
  wxLaunchDefaultBrowser(
      "https://opencpn.org/wiki/dokuwiki/"
      "doku.php?id=opencpn:opencpn_user_manual:plugins:weather:weather_"
      "routing");
}

void WeatherRouting::OnInformation(wxCommandEvent& event) {
  wxString infolocation = GetPluginDataDir("weather_routing_pi") + "/data/" +
                          _("WeatherRoutingInformation.html");
  wxLaunchDefaultBrowser("file://" + infolocation);
}

void WeatherRouting::OnAbout(wxCommandEvent& event) {
  AboutDialog dlg(GetParent());
  dlg.ShowModal();
}



/*********************************************************/
/*   5. XML Load / Save                              */
/*********************************************************/

bool WeatherRouting::OpenXML(wxString filename, bool reportfailure) {
  wxLogMessage("WR: OpenXML() entered");

  TiXmlDocument doc;
  wxString error;


//wxWindow* p = GetParent();
//  if (p && p->IsTopLevel()) {
//    p->SetTitle(_("Weather Routing"));
//  }

//  m_FileName = fn;

  wxProgressDialog* progressdialog = NULL;
  wxDateTime start = wxDateTime::UNow();

  wxString lastboatFileName;
  Boat lastboat;

  if (!doc.LoadFile(filename.mb_str()))
    FAIL(_("Failed to load file."));
  else {
    TiXmlHandle root(doc.RootElement());

    // Log root element name wxString rootName =
    wxString rootName = wxString::FromUTF8(root.Element()->Value());
    wxLogMessage("ROOT ELEMENT = %s", rootName.mb_str());

    // Be tolerant of historical root names
    if (rootName != "OpenCPNWeatherRoutingConfiguration" &&
        rootName != "WeatherRoutingConfiguration" &&
        rootName != "OpenCPNWeatherRouting") {
      FAIL(_("Invalid xml file"));
    }

    RouteMap::Positions.clear();

    int count = 0;
    for (TiXmlElement* e = root.FirstChild().Element(); e;
         e = e->NextSiblingElement())
      count++;

    int i = 0;
    for (TiXmlElement* e = root.FirstChild().Element(); e;
         e = e->NextSiblingElement(), i++) {
      if (progressdialog) {
        if (!progressdialog->Update(i)) {
          delete progressdialog;
          return true;
        }
      } else {
        wxDateTime now = wxDateTime::UNow();
        /* if it's going to take more than a half second, show a progress dialog
         */
        if ((now - start).GetMilliseconds() > 250 && i < count / 2) {
          progressdialog = new wxProgressDialog(
              _("Load"), _("Weather Routing"), count, this,
              wxPD_CAN_ABORT | wxPD_ELAPSED_TIME | wxPD_REMAINING_TIME);
        }
      }

      if (!strcmp(e->Value(), "Position")) {
        wxString name = wxString::FromUTF8(e->Attribute("Name"));
        wxString GUID = wxString::FromUTF8(e->Attribute("GUID"));
        double lat = AttributeDouble(e, "Latitude", NAN);        double lon = AttributeDouble(e, "Longitude", NAN);

        if (GUID.IsEmpty())
          for (auto it : RouteMap::Positions) {
            if (it.Name == name) {
              static bool warnonce = true;
              if (warnonce) {
                warnonce = false;
                wxMessageDialog mdlg(
                    this,
                    _("File contains duplicate position name, discaring\n"),
                    _("Weather Routing"), wxOK | wxICON_WARNING);
                mdlg.ShowModal();
              }

              goto skipadd;
            }
          }
        AddPosition(lat, lon, name, GUID);

      skipadd:;
      } else if (!strcmp(e->Value(), "Configuration")) {
        // Ideally the name of the XML element should be "Routings" but it is
        // kept as "Configuration" for backward compatibility.
        RouteMapConfiguration configuration;
        configuration.RouteGUID = wxString::FromUTF8(e->Attribute("GUID"));
        configuration.StartType =
            (RouteMapConfiguration::StartDataType)AttributeInt(
                e, "StartType", RouteMapConfiguration::START_FROM_POSITION);
        configuration.Start = wxString::FromUTF8(e->Attribute("Start"));
        configuration.UseCurrentTime =
            AttributeBool(e, "UseCurrentTime", false);
        if (configuration.UseCurrentTime) {
          // The current time will be overridden when the route is computed.
          configuration.StartTime = wxDateTime::Now().ToUTC();
        } else {
          wxDateTime date;
          date.ParseISODate(wxString::FromUTF8(e->Attribute("StartDate")));
          wxDateTime time;
          time.ParseISOTime(wxString::FromUTF8(e->Attribute("StartTime")));
          if (date.IsValid()) {
            if (time.IsValid()) {
              date.SetHour(time.GetHour());
              date.SetMinute(time.GetMinute());
              date.SetSecond(time.GetSecond());
            }
            configuration.StartTime = date;
          } else {
            configuration.StartTime = wxDateTime::Now();
          }
        }

        configuration.End = wxString::FromUTF8(e->Attribute("End"));
        configuration.DeltaTime = AttributeDouble(e, "dt", 0);

        configuration.boatFileName = wxString::FromUTF8(e->Attribute("Boat"));
        if (!wxFileName::FileExists(configuration.boatFileName)) {
          configuration.boatFileName =
              weather_routing_pi::StandardPath() + "boats" +
              wxFileName::GetPathSeparator() + configuration.boatFileName;
          if (!wxFileName::FileExists(configuration.boatFileName)) {
            configuration.boatFileName = wxEmptyString;
          }
        }

        configuration.Integrator =
            (RouteMapConfiguration::IntegratorType)AttributeInt(e, "Integrator",
                                                                0);

        configuration.MaxDivertedCourse =
            AttributeDouble(e, "MaxDivertedCourse", 90);
        configuration.MaxCourseAngle =
            AttributeDouble(e, "MaxCourseAngle", 180);
        configuration.MaxSearchAngle =
            AttributeDouble(e, "MaxSearchAngle", 120);
        configuration.MaxTrueWindKnots =
            AttributeDouble(e, "MaxTrueWindKnots", 50);
        configuration.MaxApparentWindKnots =
            AttributeDouble(e, "MaxApparentWindKnots", 50);

        configuration.MaxSwellMeters =
            AttributeDouble(e, "MaxSwellMeters", 20.);
        configuration.MaxLatitude = AttributeDouble(e, "MaxLatitude", 90);
        configuration.TackingTime = AttributeDouble(e, "TackingTime", 0);
        configuration.JibingTime = AttributeDouble(e, "JibingTime", 0);
        configuration.SailPlanChangeTime =
            AttributeDouble(e, "SailPlanChangeTime", 0);
        configuration.WindVSCurrent = AttributeDouble(e, "WindVSCurrent", 0);

        configuration.AvoidCycloneTracks =
            AttributeBool(e, "AvoidCycloneTracks", false);
        configuration.CycloneMonths = AttributeInt(e, "CycloneMonths", 2);
        configuration.CycloneDays = AttributeInt(e, "CycloneDays", 0);

        configuration.UseGrib = AttributeBool(e, "UseGrib", true);
        configuration.ClimatologyType =
            (RouteMapConfiguration::ClimatologyDataType)AttributeInt(
                e, "ClimatologyType", RouteMapConfiguration::CUMULATIVE_MAP);
        configuration.AllowDataDeficient =
            AttributeBool(e, "AllowDataDeficient", false);
        configuration.WindStrength = AttributeDouble(e, "WindStrength", 1);

        configuration.UpwindEfficiency =
            AttributeDouble(e, "UpwindEfficiency", 1.);
        configuration.DownwindEfficiency =
            AttributeDouble(e, "DownwindEfficiency", 1.);
        configuration.NightCumulativeEfficiency =
            AttributeDouble(e, "NightCumulativeEfficiency", 1.);

        configuration.DetectLand = AttributeBool(e, "DetectLand", true);
        configuration.SafetyMarginLand =
            AttributeDouble(e, "SafetyMarginLand", 0.);
        configuration.DetectBoundary =
            AttributeBool(e, "DetectBoundary", false);
        configuration.Currents = AttributeBool(e, "Currents", true);
        configuration.OptimizeTacking =
            AttributeBool(e, "OptimizeTacking", false);

        configuration.InvertedRegions =
            AttributeBool(e, "InvertedRegions", false);
        configuration.Anchoring = AttributeBool(e, "Anchoring", false);

        configuration.FromDegree = AttributeDouble(e, "FromDegree", 0);
        configuration.ToDegree = AttributeDouble(e, "ToDegree", 180);
        configuration.ByDegrees = AttributeDouble(e, "ByDegrees", 5.);

        // Motor configuration loading
        configuration.UseMotor = AttributeBool(e, "UseMotor", false);
        configuration.MotorSpeedThreshold =
            AttributeDouble(e, "MotorSpeedThreshold", 2.0);
        configuration.MotorSpeed = AttributeDouble(e, "MotorSpeed", 5.0);

        if (configuration.boatFileName == lastboatFileName)
          configuration.boat = lastboat;

        AddConfiguration(configuration);

        lastboatFileName = configuration.boatFileName;
        m_WeatherRoutes.back()->routemapoverlay->LoadBoat();
        lastboat =
            m_WeatherRoutes.back()->routemapoverlay->GetConfiguration().boat;
      } else {
        // Don?t abort on unknown nodes; just log and continue
        wxLogMessage("Skipping unknown XML node: %s", e->Value());
        continue;
        //        FAIL(_("Unrecognized xml node"));
      }
    }
  }
  delete progressdialog;
  return true;

failed:
  delete progressdialog;
  if (reportfailure) {
    wxMessageDialog mdlg(this, error, _("Weather Routing"),
                         wxOK | wxICON_ERROR);
    mdlg.ShowModal();
  }
  return false;
}

void WeatherRouting::SaveXML(wxString filename) {
  wxFileName fn(filename);

//  wxWindow* p = GetParent();
//  if (p && p->IsTopLevel()) {
//    p->SetTitle(_("Weather Routing") + " - " + fn.GetFullName());
//  }

  m_FileName = fn;


  TiXmlDocument doc;
  TiXmlDeclaration* decl = new TiXmlDeclaration("1.0", "utf-8", "");
  doc.LinkEndChild(decl);

  TiXmlElement* root = new TiXmlElement("OpenCPNWeatherRoutingConfiguration");
  doc.LinkEndChild(root);

  char version[24];
  sprintf(version, "%d.%d", PLUGIN_VERSION_MAJOR, PLUGIN_VERSION_MINOR);
  root->SetAttribute("version", version);
  root->SetAttribute("creator", "Opencpn Weather Routing plugin");

  for (std::list<RouteMapPosition>::iterator it = RouteMap::Positions.begin();
       it != RouteMap::Positions.end(); it++) {
    TiXmlElement* c = new TiXmlElement("Position");

    c->SetAttribute("Name", (*it).Name.mb_str());
    c->SetAttribute("Latitude", wxString::Format("%.6f", (*it).lat).mb_str());
    c->SetAttribute("Longitude", wxString::Format("%.6f", (*it).lon).mb_str());
    if (!(*it).GUID.IsEmpty()) c->SetAttribute("GUID", (*it).GUID.mb_str());

    root->LinkEndChild(c);
  }

  for (auto it = m_WeatherRoutes.begin(); it != m_WeatherRoutes.end(); it++) {
    // Ideally the name of the XML element should be "Routings" but it is kept
    // as "Configuration" for backward compatibility.
    TiXmlElement* c = new TiXmlElement("Configuration");

    RouteMapConfiguration configuration =
        (*it)->routemapoverlay->GetConfiguration();

    if (!configuration.RouteGUID.IsEmpty())
      c->SetAttribute("GUID", configuration.RouteGUID.mb_str());

    c->SetAttribute("StartType", configuration.StartType);
    c->SetAttribute("Start", configuration.Start.mb_str());
    c->SetAttribute("UseCurrentTime", configuration.UseCurrentTime);
    if (!configuration.UseCurrentTime) {
      c->SetAttribute("StartDate",
                      configuration.StartTime.FormatISODate().mb_str());
      c->SetAttribute("StartTime",
                      configuration.StartTime.FormatISOTime().mb_str());
    }
    c->SetAttribute("End", configuration.End.mb_str());
    c->SetAttribute("dt", configuration.DeltaTime);

    c->SetAttribute("Boat", configuration.boatFileName.ToUTF8());

    c->SetAttribute("Integrator", configuration.Integrator);

    c->SetAttribute("MaxDivertedCourse", configuration.MaxDivertedCourse);
    c->SetAttribute("MaxCourseAngle", configuration.MaxCourseAngle);
    c->SetAttribute("MaxSearchAngle", configuration.MaxSearchAngle);
    c->SetAttribute("MaxTrueWindKnots", configuration.MaxTrueWindKnots);
    c->SetAttribute("MaxApparentWindKnots", configuration.MaxApparentWindKnots);

    c->SetDoubleAttribute("MaxSwellMeters", configuration.MaxSwellMeters);
    c->SetAttribute("MaxLatitude", configuration.MaxLatitude);
    c->SetAttribute("TackingTime", configuration.TackingTime);
    c->SetAttribute("JibingTime", configuration.JibingTime);
    c->SetAttribute("SailPlanChangeTime", configuration.SailPlanChangeTime);
    c->SetAttribute("WindVSCurrent", configuration.WindVSCurrent);

    c->SetAttribute("AvoidCycloneTracks", configuration.AvoidCycloneTracks);
    c->SetAttribute("CycloneMonths", configuration.CycloneMonths);
    c->SetAttribute("CycloneDays", configuration.CycloneDays);

    c->SetAttribute("UseGrib", configuration.UseGrib);
    c->SetAttribute("ClimatologyType", configuration.ClimatologyType);
    c->SetAttribute("AllowDataDeficient", configuration.AllowDataDeficient);
    c->SetDoubleAttribute("WindStrength", configuration.WindStrength);

    c->SetDoubleAttribute("UpwindEfficiency", configuration.UpwindEfficiency);
    c->SetDoubleAttribute("DownwindEfficiency",
                          configuration.DownwindEfficiency);
    c->SetDoubleAttribute("NightCumulativeEfficiency",
                          configuration.NightCumulativeEfficiency);

    c->SetAttribute("DetectLand", configuration.DetectLand);
    c->SetDoubleAttribute("SafetyMarginLand", configuration.SafetyMarginLand);
    c->SetAttribute("DetectBoundary", configuration.DetectBoundary);
    c->SetAttribute("Currents", configuration.Currents);
    c->SetAttribute("OptimizeTacking", configuration.OptimizeTacking);

    c->SetAttribute("InvertedRegions", configuration.InvertedRegions);
    c->SetAttribute("Anchoring", configuration.Anchoring);

    c->SetDoubleAttribute("FromDegree", configuration.FromDegree);
    c->SetDoubleAttribute("ToDegree", configuration.ToDegree);
    c->SetDoubleAttribute("ByDegrees", configuration.ByDegrees);

    // Motor configuration saving
    c->SetAttribute("UseMotor", configuration.UseMotor);
    c->SetDoubleAttribute("MotorSpeedThreshold",
                          configuration.MotorSpeedThreshold);
    c->SetDoubleAttribute("MotorSpeed", configuration.MotorSpeed);

    root->LinkEndChild(c);
  }

  if (!doc.SaveFile(filename.mb_str())) {
    wxMessageDialog mdlg(this, _("Failed to save xml file: ") + filename,
                         _("Weather Routing"), wxOK | wxICON_ERROR);
    mdlg.ShowModal();
  }
}

/* ****************************************************************
 * Shows a dialog to get route saving options from the user.
 * @return SaveRouteOptions structure with user's selections
 * ***************************************************************
 */

/*
void WeatherRouting::OnSaveAsRoute(wxCommandEvent& event) {
 std::list<RouteMapOverlay*> routemapoverlays = CurrentRouteMaps(true);
 if (routemapoverlays.empty()) {
   wxMessageDialog mdlg(this, _("No weather route selected"),
                        _("Weather Routing"), wxOK | wxICON_WARNING);
   mdlg.ShowModal();
   return;
 }

 // Get route saving options from user
 // Get route saving options from user
 SaveRouteOptions options = ShowRouteSaveOptionsDialog();
 if (!options.dialogAccepted) {
   return;  // User canceled
 }

 // Process each selected route
 for (auto it = routemapoverlays.begin(); it != routemapoverlays.end(); it++) {
   RouteMapOverlay* routemap = *it;

   if (options.simplifyRoute) {
     RouteSimplifier simplifier(routemap);

     // Configure simplification parameters (new API)
     SimplificationParams params;
     double routeHours = routemap->GetConfiguration().RouteTime;
     params.maxTimeHours = routeHours * options.maxTimePenalty;

     SimplificationResult result = simplifier.Simplify(params);

     if (!result.success) {
       wxMessageDialog errorDlg(
           this, _("Failed to simplify route: ") + result.message,
           _("Weather Routing"), wxOK | wxICON_ERROR);
       errorDlg.ShowModal();

       // Inform user to save manually
       wxMessageDialog infoDlg(this,
                               _("Route was not saved automatically.\nUse "
                                 "'Save As Route' from the menu to save it."),
                               _("Weather Routing"),
                               wxOK | wxICON_INFORMATION);
       infoDlg.ShowModal();
     } else {
       // Save simplified route internally (no file dialog)
       SaveSimplifiedRoute(*routemap, result.simplifiedRoute);

       wxMessageDialog resultDlg(this, result.message,
                                 _("Route Simplification"),
                                 wxOK | wxICON_INFORMATION);
       resultDlg.ShowModal();
     }
   } else {
     // Inform user to save manually
     wxMessageDialog infoDlg(this,
                             _("Route was not saved automatically.\nUse 'Save "
                               "As Route' from the menu to save it."),
                             _("Weather Routing"), wxOK | wxICON_INFORMATION);
     infoDlg.ShowModal();
   }
 }

 //===============================

void WeatherRouting::OnSaveAsTrack(wxCommandEvent& event) {
  // Get selected overlays
  std::list<RouteMapOverlay*> overlays = CurrentRouteMaps(true);
  if (overlays.empty()) {
    wxMessageDialog mdlg(this, _("No weather route selected"),
                         _("Weather Routing"), wxOK | wxICON_WARNING);
    mdlg.ShowModal();
    return;
  }

  // Only one track can be saved at a time
  RouteMapOverlay* routemap = overlays.front();

  // Ask user for save options (simplify or not)
  SaveRouteOptions options = ShowRouteSaveOptionsDialog();
  if (!options.dialogAccepted) return;

  // Build the <trk> element
  TiXmlElement* trk = nullptr;

  if (options.simplifyRoute) {
    // Run simplifier
    RouteSimplifier simplifier(routemap);

    SimplificationParams params;
    params.maxTimeLossPercent = options.maxTimePenalty;

    SimplificationResult result = simplifier.Simplify(params);

    if (!result.success) {
      wxMessageDialog mdlg(this,
                           _("Failed to simplify track: ") + result.message,
                           _("Weather Routing"), wxOK | wxICON_ERROR);
      mdlg.ShowModal();
      return;
    }

   trk = SaveSimplifiedRouteAsGPX(*routemap, result.simplifiedRoute);
  } else {
    // Save original track
    trk = SaveSimplifiedRoute(*routemap, routemap->GetRoute());
  }

  if (!trk) {
    wxMessageDialog mdlg(this,
                         _("Unable to generate GPX track for this route."),
                         _("Weather Routing"), wxOK | wxICON_ERROR);
    mdlg.ShowModal();
    return;
  }

  // Ask user where to save the GPX file
  wxFileDialog saveDialog(this, _("Save Track As GPX"), wxEmptyString,
                          wxEmptyString, _("GPX files (*.gpx)|*.gpx"),
                          wxFD_SAVE | wxFD_OVERWRITE_PROMPT);

  if (saveDialog.ShowModal() != wxID_OK) return;

  wxString path = saveDialog.GetPath();

  // Build GPX document
  TiXmlDocument doc;
  doc.LinkEndChild(new TiXmlDeclaration("1.0", "UTF-8", ""));

  TiXmlElement* gpx = new TiXmlElement("gpx");
  gpx->SetAttribute("version", "1.1");
  gpx->SetAttribute("creator", "WeatherRouting Plugin");
  gpx->SetAttribute("xmlns", "http://www.topografix.com/GPX/1/1");
  gpx->SetAttribute("xmlns:opencpn", "http://www.opencpn.org");

  doc.LinkEndChild(gpx);
  gpx->LinkEndChild(trk);

  // Save to disk
  if (!doc.SaveFile(path.ToUTF8())) {
    wxMessageDialog mdlg(this, _("Failed to save GPX file."),
                         _("Weather Routing"), wxOK | wxICON_ERROR);
    mdlg.ShowModal();
    return;
  }

  wxMessageDialog mdlg(this, _("Track saved successfully."),
                       _("Weather Routing"), wxOK | wxICON_INFORMATION);
  mdlg.ShowModal();
}
*/

TiXmlElement* WeatherRouting::SaveSimplifiedRouteAsGPX(
    const RouteMapOverlay& routemapoverlay,
    const std::list<Position*>& simplifiedRoute) {
  if (simplifiedRoute.empty()) return nullptr;

  // Create <trk>
  TiXmlElement* trk = new TiXmlElement("trk");

  // Track name
  const RouteMapConfiguration& config = routemapoverlay.GetConfiguration();
  wxString trackName =
      wxString::Format("Simplified %s to %s", config.Start, config.End);

  TiXmlElement* name = new TiXmlElement("name");
  name->LinkEndChild(new TiXmlText(trackName.ToUTF8()));
  trk->LinkEndChild(name);

  // Create <trkseg>
  TiXmlElement* trkseg = new TiXmlElement("trkseg");
  trk->LinkEndChild(trkseg);

  // Write each simplified point
  for (Position* pos : simplifiedRoute) {
    TiXmlElement* trkpt = new TiXmlElement("trkpt");

    trkpt->SetDoubleAttribute("lat", pos->lat);
    trkpt->SetDoubleAttribute("lon", pos->lon);

    // Time (ISO8601)
    if (pos->time.IsValid()) {
      TiXmlElement* time = new TiXmlElement("time");
      time->LinkEndChild(
          new TiXmlText(pos->time.FormatISOCombined('T').ToUTF8()));
      trkpt->LinkEndChild(time);
    }

    // Extensions block for extra data
    TiXmlElement* ext = nullptr;

    auto addExtension = [&](const char* tag, double value) {
      if (std::isnan(value)) return;
      if (!ext) {
        ext = new TiXmlElement("extensions");
        trkpt->LinkEndChild(ext);
      }
      TiXmlElement* e = new TiXmlElement(tag);
      e->LinkEndChild(new TiXmlText(wxString::Format("%.3f", value).ToUTF8()));
      ext->LinkEndChild(e);
    };

    // Boat speed (SOG)
    addExtension("opencpn:sog", pos->speed);

    // Wind
    addExtension("opencpn:wind_speed", pos->wind_speed);
    addExtension("opencpn:wind_dir", pos->wind_direction);

    // Current
    addExtension("opencpn:current_speed", pos->current_speed);
    addExtension("opencpn:current_dir", pos->current_direction);

    // Swell
    addExtension("opencpn:swell_height", pos->swell_height);

    trkseg->LinkEndChild(trkpt);
  }

  return trk;
}


/*********************************************************/
/*   6. Position Management                              */
/*********************************************************/
// NOTE Why 3 AddPosition overloads 
//    UI update code is similar in all three.but the semantics are different
//    three different workflows, not duplicates.
//--------------------------------
// Other position management functions are in RouteMap.cpp
//--------------------------------
// OnEditPosition
//   User selects a position in the list and clicks Edit
//   Prompts for new name, Checks for name collisions
//   Updates the list control, Updates configuration dialogs
// OnDeletePosition
//   User selects a position in the list and clicks Delete
//   Prompts for confirmation, Removes from the list control
//   Updates configuration dialogs, Removes from RouteMap::Positions
// OnDeleteAllPositions
//   User clicks Delete All Positions
//   Prompts for confirmation, Clears the list control
//   Updates configuration dialogs, Clears RouteMap::Positions
//--------------------------------


// AddPosition 1 -The interactive UI entry point.
// Called when the user clicks Add Position in theU
// UI and only provides coordinates.

void WeatherRouting::AddPosition(double lat, double lon) {
  wxTextEntryDialog pd(this, _("Enter Name"), _("New Position"));
  if (pd.ShowModal() == wxID_OK) AddPosition(lat, lon, pd.GetValue(), false);
}


// AddPosition 2 - Handles user-created positions that have no GUID.
// Checks for name collisions
// Optionally prompts the user (?Replace existing??)
// Updates the list control   Updates configuration dialogs
// Schedules autosave,  the core logic for user-defined positions.

void WeatherRouting::AddPosition(double lat, double lon, wxString name,
                                 const bool suppress_prompt) {
  for (auto& it : RouteMap::Positions) {
    if (it.GUID.IsEmpty() && it.Name == name) {
      int replace = wxID_YES;
      if (!suppress_prompt) {
        wxMessageDialog mdlg(this, _("This name already exists, replace?\n"),
                             _("Weather Routing"),
                             wxYES | wxNO | wxICON_WARNING);
        replace = mdlg.ShowModal();
      }
      if (replace == wxID_YES) {
        long index = m_panel->m_lPositions->FindItem(0, it.ID);
        assert(index >= 0);

        it.lat = lat;
        it.lon = lon;
        m_panel->m_lPositions->SetItem(
            index, POSITION_LAT,
            toSDMM_PlugIn(NEflag::LAT, lat, Precision::HI));
        m_panel->m_lPositions->SetColumnWidth(POSITION_LAT, wxLIST_AUTOSIZE);
        m_panel->m_lPositions->SetItem(
            index, POSITION_LON,
            toSDMM_PlugIn(NEflag::LON, lon, Precision::HI));
        m_panel->m_lPositions->SetColumnWidth(POSITION_LON, wxLIST_AUTOSIZE);
        UpdateConfigurations();
      }
      return;
    }
  }

  RouteMapPosition p(name, lat, lon);
  RouteMap::Positions.push_back(p);
  UpdateConfigurations();

  wxListItem item;
  long index = m_panel->m_lPositions->InsertItem(
      m_panel->m_lPositions->GetItemCount(), item);

  m_panel->m_lPositions->SetItem(index, POSITION_NAME, name);
  m_panel->m_lPositions->SetColumnWidth(POSITION_NAME, wxLIST_AUTOSIZE);
  m_panel->m_lPositions->SetItem(
      index, POSITION_LAT, toSDMM_PlugIn(NEflag::LAT, lat, Precision::HI));
  m_panel->m_lPositions->SetColumnWidth(POSITION_LAT, wxLIST_AUTOSIZE);
  m_panel->m_lPositions->SetItem(
      index, POSITION_LON, toSDMM_PlugIn(NEflag::LON, lon, Precision::HI));
  m_panel->m_lPositions->SetColumnWidth(POSITION_LON, wxLIST_AUTOSIZE);

  m_panel->m_lPositions->SetItemData(index, p.ID);
  m_ConfigurationDialog.AddSource(name);
  m_ConfigurationBatchDialog.AddSource(name);
  m_tAutoSaveXML.Start(5000, true);  // Schedule auto-save in 5 seconds
}


// AddPosition 3 - Handles positions loaded from XML or generated by routing.
// If GUID is empty delegates to the user defined version
// If GUID exists ? updates or inserts a GUID?based position
// Does not prompt the user Does not treat name collisions the same way
// Updates the UI and configuration dialogs
// GUID?based positions are route-derived, not user-created. They behave differently :

void WeatherRouting::AddPosition(double lat, double lon, wxString name,
                                 wxString GUID) {
  if (GUID.IsEmpty()) return AddPosition(lat, lon, std::move(name), false);

  for (auto& it : RouteMap::Positions) {
    if (it.GUID.IsEmpty()) continue;

    if (it.GUID.IsSameAs(GUID)) {
      // wxMessageDialog mdlg(this, _("This name already exists,
      // replace?\n"),_("Weather Routing"), wxYES | wxNO | wxICON_WARNING);
      long index = m_panel->m_lPositions->FindItem(0, it.ID);
      assert(index >= 0);

      it.lat = lat;
      it.lon = lon;
      m_panel->m_lPositions->SetItem(index, POSITION_NAME, name);
      m_panel->m_lPositions->SetColumnWidth(POSITION_NAME, wxLIST_AUTOSIZE);
      m_panel->m_lPositions->SetItem(
          index, POSITION_LAT, toSDMM_PlugIn(NEflag::LAT, lat, Precision::HI));
      m_panel->m_lPositions->SetColumnWidth(POSITION_LAT, wxLIST_AUTOSIZE);
      m_panel->m_lPositions->SetItem(
          index, POSITION_LON, toSDMM_PlugIn(NEflag::LON, lon, Precision::HI));
      m_panel->m_lPositions->SetColumnWidth(POSITION_LON, wxLIST_AUTOSIZE);
      UpdateConfigurations();
      m_tAutoSaveXML.Start(5000, true);  // Schedule auto-save in 5 seconds
      return;
    }
  }

  RouteMapPosition p(name, lat, lon, GUID);
  RouteMap::Positions.push_back(p);
  UpdateConfigurations();

  wxListItem item;
  long index = m_panel->m_lPositions->InsertItem(
      m_panel->m_lPositions->GetItemCount(), item);
  m_panel->m_lPositions->SetItem(index, POSITION_NAME, name);
  m_panel->m_lPositions->SetColumnWidth(POSITION_NAME, wxLIST_AUTOSIZE);

  m_panel->m_lPositions->SetItem(
      index, POSITION_LAT, toSDMM_PlugIn(NEflag::LAT, lat, Precision::HI));
  m_panel->m_lPositions->SetColumnWidth(POSITION_LAT, wxLIST_AUTOSIZE);
  m_panel->m_lPositions->SetItem(
      index, POSITION_LON, toSDMM_PlugIn(NEflag::LON, lon, Precision::HI));
  m_panel->m_lPositions->SetColumnWidth(POSITION_LON, wxLIST_AUTOSIZE);
  m_panel->m_lPositions->SetItemData(index, p.ID);

  m_ConfigurationDialog.AddSource(name);
  m_ConfigurationBatchDialog.AddSource(name);
}

void WeatherRouting::AddRoute(wxString& GUID) {
  RouteMapConfiguration configuration;
  if (FirstCurrentRouteMap())
    configuration = FirstCurrentRouteMap()->GetConfiguration();
  else
    configuration = DefaultConfiguration();

  configuration.RouteGUID = GUID;
  configuration.StartTime = wxDateTime::Now();
  configuration.DeltaTime = 3600;

  if (!AddConfiguration(configuration)) return;
#if 0
    for(int i=0; i<m_panel->m_lWeatherRoutes->GetItemCount(); i++) {
        WeatherRoute *weatherroute =
            reinterpret_cast<WeatherRoute*>(wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));
        if(weatherroute->routemapoverlay->m_bEndRouteVisible)
            weatherroute->routemapoverlay->Render(time, m_SettingsDialog, dc, vp, true);
    }
#endif
  if (!IsShown()) Show(true);

  m_tAutoSaveXML.Start(5000, true);  // Schedule auto-save in 5 seconds
}


void WeatherRouting::OnNewPosition(wxCommandEvent& event) {
  NewPositionDialog dlg(this);
  if (dlg.ShowModal() == wxID_OK) {
    AddPosition(fromDMM_Plugin(dlg.m_tLatitude->GetValue()),
                fromDMM_Plugin(dlg.m_tLongitude->GetValue()),
                dlg.m_tName->GetValue(), false);
  }
}


void WeatherRouting::OnEditPosition() {
  if (RouteMap::Positions.empty()) return;
  if (m_panel->m_lPositions->GetSelectedItemCount() == 0) return;

  // Find selected item in GUI
  long item = m_panel->m_lPositions->GetNextItem(-1, wxLIST_NEXT_ALL,
                                                 wxLIST_STATE_SELECTED);
  wxString name = m_panel->m_lPositions->GetItemText(item, POSITION_NAME);

  // Fill dialog with position data
  NewPositionDialog dlg(this);
  for (const auto& p : RouteMap::Positions) {
    if (p.Name == name) {
      dlg.m_tName->SetValue(p.Name);
      dlg.m_tLatitude->SetValue(toSDMM_PlugIn(1, p.lat));
      dlg.m_tLongitude->SetValue(toSDMM_PlugIn(2, p.lon));
      break;
    }
  }

  // Show dialog and store result
  if (dlg.ShowModal() == wxID_OK) {
    AddPosition(fromDMM_Plugin(dlg.m_tLatitude->GetValue()),
                fromDMM_Plugin(dlg.m_tLongitude->GetValue()),
                dlg.m_tName->GetValue(), true);
  }
}


void WeatherRouting::OnDeletePosition(wxCommandEvent& event) {
  long index = m_panel->m_lPositions->GetNextItem(-1, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
  if (index < 0) return;

  wxListItem item;
  item.SetId(index);
  item.SetColumn(0);
  item.SetMask(
      wxLIST_MASK_TEXT);  // Note use of the mask, somehow it's required for
                          // this to work correctly on windows
  m_panel->m_lPositions->GetItem(item);

  long ID = m_panel->m_lPositions->GetItemData(index);
  assert(ID >= 0);

  for (std::list<RouteMapPosition>::iterator it = RouteMap::Positions.begin();
       it != RouteMap::Positions.end(); it++) {
    if ((*it).ID == ID) {
      wxString name = (*it).Name;
      m_ConfigurationDialog.RemoveSource(name);
      m_ConfigurationBatchDialog.RemoveSource(name);
      RouteMap::Positions.erase(it);
      break;
    }
  }
  m_panel->m_lPositions->DeleteItem(index);

  UpdateConfigurations();
  m_tAutoSaveXML.Start(5000, true);  // Schedule auto-save in 5 seconds
}

void WeatherRouting::OnDeleteAllPositions(wxCommandEvent& event) {
  RouteMap::Positions.clear();
  m_ConfigurationDialog.ClearSources();
  m_ConfigurationBatchDialog.ClearSources();
  m_panel->m_lPositions->DeleteAllItems();
  m_tAutoSaveXML.Start(5000, true);  // Schedule auto-save in 5 seconds
}


/*********************************************************/
/*   7. Configuration Management                          */
/*********************************************************/
// DefaultConfiguration
//   Creates a default configuration based on first two positions
//   and standard settings.
//   Used when creating a new route from scratch.
//   The default boat is Boat.xml from the standard boats directory.
//   If less than two positions exist, lat/lon are set to 0.
//   The start time is set to now, with a delta time of 1 hour.
//   Other settings are hard-coded defaults.
//   Returns the created RouteMapConfiguration object.
// AddConfiguration
//   Adds a new configuration to the list of weather routes.
//   If the configuration has a RouteGUID, it retrieves the route
//   and sets the start and end positions accordingly.
//   Creates a new WeatherRoute and RouteMapOverlay for the configuration.
//   Updates the UI list and enables relevant menu items.
//   Schedules an auto-save of the XML file.
//   Returns true if the configuration was added successfully.
// UpdateConfigurations
//   Updates all existing weather routes with their current configurations.
//   This is typically called after positions have been modified.
//   It retrieves the configuration from each RouteMapOverlay,
//   sets it back to update start/end positions, and then updates the route.
//   No return value.
// UpdateBoatFileName
//   Updates the boat file name for all existing weather routes.
//   This is called when the standard boats directory changes.
//   It sets the boat file name in each RouteMapOverlay's configuration
//   to the new standard path. No return value.
// SetEnableConfigurationMenu
//   Enables or disables the configuration menu items.
//  This is used to prevent user interaction during long operations.
//   It sets the enabled state of the configuration menu and batch menu.
//   No return value.
//----------------------------------------------------------



void WeatherRouting::OnDefaultConfiguration(wxCommandEvent& event) {
  // Empty handler is fine ? menu item reserved for future use
}


RouteMapConfiguration WeatherRouting::DefaultConfiguration() {
  RouteMapConfiguration configuration;

  if (RouteMap::Positions.size() >= 1) {
    RouteMapPosition& p = *RouteMap::Positions.begin();
    configuration.Start = p.Name;
    configuration.StartLat = p.lat, configuration.StartLon = p.lon;
  } else
    configuration.StartLat = 0, configuration.StartLon = 0;

  configuration.StartTime = wxDateTime::Now();
  configuration.DeltaTime = 3600;

  if (RouteMap::Positions.size() >= 2) {
    RouteMapPosition& p = *(++RouteMap::Positions.begin());
    configuration.End = p.Name;
    configuration.EndLat = p.lat, configuration.EndLon = p.lon;
  } else
    configuration.EndLat = 0, configuration.EndLon = 0;

  configuration.boatFileName = weather_routing_pi::StandardPath() + "boats" +
                               wxFileName::GetPathSeparator() + "Boat.xml";

  configuration.Integrator = RouteMapConfiguration::NEWTON;

  configuration.MaxDivertedCourse = 90;
  configuration.MaxCourseAngle = 180;
  configuration.MaxSearchAngle = 120;
  configuration.MaxTrueWindKnots = 50;      // Safety margin for wind speed
  configuration.MaxApparentWindKnots = 50;  // Safety margin for wind speed

  configuration.MaxSwellMeters = 20.;
  configuration.MaxLatitude = 90;
  configuration.TackingTime = 0;
  configuration.JibingTime = 0;
  configuration.SailPlanChangeTime = 0;
  configuration.WindVSCurrent = 0;

  configuration.AvoidCycloneTracks = false;
  configuration.CycloneMonths = 1;
  configuration.CycloneDays = 0;

  configuration.UseGrib = true;
  configuration.ClimatologyType = RouteMapConfiguration::MOST_LIKELY;
  configuration.AllowDataDeficient = false;
  configuration.WindStrength = 1;
  configuration.DetectLand = true;
  configuration.SafetyMarginLand = 0.;
  configuration.DetectBoundary = false;
  configuration.Currents = false;
  configuration.OptimizeTacking = false;
  configuration.InvertedRegions = false;
  configuration.Anchoring = false;

  configuration.FromDegree = 0;
  configuration.ToDegree = 180;
  configuration.ByDegrees = 5;

  return configuration;
}



bool WeatherRouting::AddConfiguration(RouteMapConfiguration& configuration) {
  wxLogMessage("WR: OpenXML() entered");

  // 1. Create WeatherRoute + overlay (ONE TIME)
  WeatherRoute* weatherroute = new WeatherRoute(this);

  // Defensive fallback (should never trigger now)
  if (!weatherroute->routemapoverlay)
    weatherroute->routemapoverlay = new RouteMapOverlay(this);

  RouteMapOverlay* routemapoverlay = weatherroute->routemapoverlay;

  // Apply configuration and reset overlay state
  routemapoverlay->SetConfiguration(configuration);
  routemapoverlay->Clear();

  // 2. If GUID exists, load start/end positions
  if (!configuration.RouteGUID.IsEmpty()) {
    std::unique_ptr<PlugIn_Route> rte =
        GetRoute_Plugin(configuration.RouteGUID);
    if (!rte) return false;

    PlugIn_Route* proute = rte.get();
    if (!proute) return false;

    wxPlugin_WaypointListNode* pwpnode = proute->pWaypointList->GetFirst();
    if (!pwpnode) return false;

    PlugIn_Waypoint* pwp = pwpnode->GetData();
    AddPosition(pwp->m_lat, pwp->m_lon, pwp->m_MarkName, pwp->m_GUID);
    configuration.Start = pwp->m_MarkName;
    configuration.StartGUID = pwp->m_GUID;
    configuration.StartLat = pwp->m_lat;
    configuration.StartLon = pwp->m_lon;

    while (pwpnode->GetNext()) pwpnode = pwpnode->GetNext();

    pwp = pwpnode->GetData();
    AddPosition(pwp->m_lat, pwp->m_lon, pwp->m_MarkName, pwp->m_GUID);
    configuration.End = pwp->m_MarkName;
    configuration.EndGUID = pwp->m_GUID;
    configuration.EndLat = pwp->m_lat;
    configuration.EndLon = pwp->m_lon;
  }

  // 3. Update route state
  weatherroute->Update(this, false);

  // 4. Insert into lists, update UI
  m_RouteMapOverlays.push_back(routemapoverlay);
  m_WeatherRoutes.push_back(weatherroute);

  wxListItem item;
  long index = m_panel->m_lWeatherRoutes->InsertItem(
      m_panel->m_lWeatherRoutes->GetItemCount(), item);

  m_panel->m_lWeatherRoutes->SetItemPtrData(index, (wxUIntPtr)weatherroute);
  UpdateItem(index, true);

  m_mDeleteAll->Enable();
  m_mComputeAll->Enable();
  m_mSaveAllAsTracks->Enable();
  m_tAutoSaveXML.Start(5000, true);

  return true;
}





void WeatherRouting::UpdateConfigurations() {
  for (int i = 0; i < m_panel->m_lWeatherRoutes->GetItemCount(); i++) {
    WeatherRoute* weatherroute = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));

    /* get and set configuration to update start/end positions */
    RouteMapConfiguration c = weatherroute->routemapoverlay->GetConfiguration();
    weatherroute->routemapoverlay->SetConfiguration(c);

    weatherroute->Update(this, true);
    UpdateItem(i, true);
  }
}


void WeatherRouting::UpdateBoatFilename(const wxString& boatFileName) {
  wxLogMessage("WeatherRouting::UpdateBoatFilename - BEGIN (%s)",
               boatFileName.mb_str());

  for (long index = 0; index < m_panel->m_lWeatherRoutes->GetItemCount();
       index++) {
    WeatherRoute* weatherroute = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(index)));

    if (!weatherroute || !weatherroute->routemapoverlay) continue;

    RouteMapOverlay* ov = weatherroute->routemapoverlay;
    RouteMapConfiguration c = ov->GetConfiguration();

    if (c.boatFileName == boatFileName) {
      wxLogMessage("UpdateBoatFilename: resetting route %ld (overlay=%p)",
                   index, ov);

      // 1. Update the boat file in the configuration
      c.boatFileName = boatFileName;
      ov->SetConfiguration(c);

      // 2. Fully reset the overlay using the new unified lifecycle
      Reset(ov);  // <-- your new 3?phase safe reset

      // 3. Update the UI row
      UpdateRouteMap(ov);
    }
  }

  // 4. Refresh global UI
  UpdateAllItems(true);
  UpdateDialogs();
  UpdateComputeState();
  GetParent()->Refresh();

  wxLogMessage("WeatherRouting::UpdateBoatFilename - END");
}

void WeatherRouting::SetEnableConfigurationMenu() {
  // Menus and panel controls may not exist yet during initialization
  if (!m_panel || !m_panel->m_lWeatherRoutes || !m_panel->m_bCompute ||
      !m_panel->m_bSaveAsTrack || !m_panel->m_bSaveAsRoute || !m_mBatch ||
      !m_mEdit || !m_mGoTo || !m_mDelete || !m_mCompute || !m_mSaveAsTrack ||
      !m_mSaveAsRoute || !m_mExportRouteAsGPX || !m_mDeleteAll ||
      !m_mComputeAll || !m_mSaveAllAsTracks) {
    return;
  }

  bool current = FirstCurrentRouteMap() != NULL;
  m_mBatch->Enable(current);
  m_mEdit->Enable(current);
  m_mGoTo->Enable(current);
  m_mDelete->Enable(current);
  m_mCompute->Enable(current);
  m_panel->m_bCompute->Enable(current);
  m_mSaveAsTrack->Enable(current);
  m_mSaveAsRoute->Enable(current);
  m_mExportRouteAsGPX->Enable(current);
  m_panel->m_bSaveAsTrack->Enable(current);
  m_panel->m_bSaveAsRoute->Enable(current);

  m_mStop->Enable(m_WaitingRouteMaps.size() + m_RunningRouteMaps.size() > 0);

  bool cnt = m_panel->m_lWeatherRoutes->GetItemCount() > 0;
  m_mDeleteAll->Enable(cnt);
  m_mComputeAll->Enable(cnt);
  m_mSaveAllAsTracks->Enable(cnt);
}



void WeatherRouting::AddRoutingPanel() {
  // ---------------------------------------------------------------------
  // 1. Determine the first selected WeatherRoute
  //    The list control is the authoritative source of selection.
  // ---------------------------------------------------------------------
  long item = m_panel->m_lWeatherRoutes->GetNextItem(-1, wxLIST_NEXT_ALL,
                                                     wxLIST_STATE_SELECTED);

  if (item < 0) return;  // No selection ? nothing to show

  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
      wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

  if (!wr || !wr->routemapoverlay) return;

  RouteMapOverlay* ov = wr->routemapoverlay;

  // ---------------------------------------------------------------------
  // 2. Create the RoutingTablePanel if it does not exist
  // ---------------------------------------------------------------------
  if (!m_RoutingTablePanel) {
    wxWindow* parent = m_weather_routing_pi.GetParentWindow();

    m_RoutingTablePanel = new RoutingTablePanel(parent, *this, ov);

    wxAuiManager* pauimgr = ::GetFrameAuiManager();
    wxAuiPaneInfo pane = wxAuiPaneInfo()
                             .Name("Weather Routing Table")
                             .Caption("Weather Routing Table")
                             .CaptionVisible(true)
                             .Float()
                             .FloatingPosition(100, 100)
                             .FloatingSize(700, 400)
                             .Dockable(true)
                             .Movable(true)
                             .CloseButton(true);

    pauimgr->AddPane(m_RoutingTablePanel, pane);

#if OCPN_API_VERSION_MAJOR > 1 || \
    (OCPN_API_VERSION_MAJOR == 1 && OCPN_API_VERSION_MINOR >= 20)
    // Apply OpenCPN color scheme
    PI_ColorScheme cs = GetAppColorScheme();
    ((RoutingTablePanel*)m_RoutingTablePanel)->SetColorScheme(cs);
#endif

    pauimgr->Update();
  }

  // ---------------------------------------------------------------------
  // 3. Update existing panel with the new selected route
  // ---------------------------------------------------------------------
  else {
    ((RoutingTablePanel*)m_RoutingTablePanel)->m_RouteMap = ov;
    ((RoutingTablePanel*)m_RoutingTablePanel)->PopulateTable();

    // Ensure the panel is visible
    wxAuiManager* pauimgr = ::GetFrameAuiManager();
    wxAuiPaneInfo& pane = pauimgr->GetPane(m_RoutingTablePanel);

    if (!pane.IsShown()) {
      pane.Show(true);
      pauimgr->Update();
    }
  }
}

/*********************************************************/
/*   8. Route List Management (Model + wxListCtrl ) */
/*********************************************************/
// AddRouteToList
//   Add a new WeatherRoute to the internal model and the wxListCtrl
//   then populate its row via UpdateItem()
// RemoveRouteFromList
//   Remove a WeatherRoute from the internal model and the wxListCtrl
//   using the unified Reset(overlay) lifecycle for safe teardown
//   then refresh remaining rows with UpdateItem()
//-----------------------------------------------------  
// RemoveSelectedRoutes
//   Remove all selected WeatherRoutes from the internal model and the
//   wxListCtrl then refresh remaining rows with UpdateItem()
// RemoveAllRoutes
//   Remove all WeatherRoutes from the internal model and the wxListCtrl
//   using the unified Reset(overlay) lifecycle for safe teardown
//   then refresh UI state with UpdateDialogs()
//-----------------------------------------------------
// SelectRouteInList
//   Select a WeatherRoute in the wxListCtrl given its pointer
//   clearing any previous selection
//   used after adding a new route to highlight it
//   or when the user requests selection via context menu
//   or when a route computation finishes
//   or when the user double-clicks a route to edit it
//   or when the user requests selection via external code
//  then refresh UI state with UpdateDialogs()

//------------------------------------------
//   8.1 Add / Remove
//------------------------------------------

void WeatherRouting::AddRouteToList(WeatherRoute* wr) {
  if (!wr) return;

  // Add to internal model
  m_WeatherRoutes.push_back(wr);

  // Determine the new row index
  long index = m_panel->m_lWeatherRoutes->GetItemCount();

  // Insert a new row with the route pointer as item data
  wxListItem item;
  item.SetId(index);
  item.SetData(reinterpret_cast<wxUIntPtr>(wr));
  item.SetText("");  // first column text (STATE will be filled by UpdateItem)
  m_panel->m_lWeatherRoutes->InsertItem(item);

  // Initialize all columns to empty strings
  for (int c = 0; c < NUM_COLS; c++) {
    if (columns[c] >= 0)
      m_panel->m_lWeatherRoutes->SetItem(index, columns[c], "");
  }

  // Now populate the row using the unified update pipeline
  UpdateItem(index, true);
}

void WeatherRouting::RemoveRouteFromList(long index) {
  if (index < 0 || index >= (long)m_WeatherRoutes.size()) return;

  // 1. Locate the WeatherRoute in the model
  auto it = m_WeatherRoutes.begin();
  std::advance(it, index);
  WeatherRoute* wr = *it;

  // 2. Reset the overlay using the canonical lifecycle
  if (wr && wr->routemapoverlay) {
    Reset(wr->routemapoverlay);
  }

  // 3. Delete the WeatherRoute object
  delete wr;
  m_WeatherRoutes.erase(it);

  // 4. Remove the row from the UI list control
  m_panel->m_lWeatherRoutes->DeleteItem(index);

  // 5. Reindex remaining rows
  long count = m_panel->m_lWeatherRoutes->GetItemCount();
  auto it2 = m_WeatherRoutes.begin();
  for (long i = 0; i < count; i++, ++it2) {
    m_panel->m_lWeatherRoutes->SetItemData(i,
                                           reinterpret_cast<wxUIntPtr>(*it2));
  }

  // 6. Refresh UI rows
  for (long i = 0; i < count; i++) UpdateItem(i, true);

  // 7. Global UI refresh pipeline
  UpdateDialogs();
  UpdateComputeState();
  if (GetParent()) GetParent()->Refresh();

  AssertSchedulerInvariants();
}



void WeatherRouting::RemoveSelectedRoutes() {
  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  if (!lc) return;

  // Collect selected indices (descending order avoids index shifting)
  std::vector<long> selected;
  long item = -1;

  for (;;) {
    item = lc->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item == -1) break;
    selected.push_back(item);
  }

  if (selected.empty()) return;

  std::sort(selected.begin(), selected.end(), std::greater<long>());

  // Remove each selected route using the unified lifecycle
  for (long idx : selected) RemoveRouteFromList(idx);

  // Refresh remaining rows
  long count = lc->GetItemCount();
  for (long i = 0; i < count; i++) UpdateItem(i, true);

  // Update dialogs and UI state
  UpdateDialogs();
  GetParent()->Refresh();
}

void WeatherRouting::RemoveAllRoutes() {
  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  if (!lc) return;

  if (m_WeatherRoutes.empty()) return;

  // Freeze UI to avoid flicker during mass deletion
  lc->Freeze();

  // 1. Reset each overlay using the canonical 3?phase lifecycle
  for (WeatherRoute* wr : m_WeatherRoutes) {
    if (wr && wr->routemapoverlay) {
      Reset(wr->routemapoverlay);  // <-- unified, safe teardown
    }
  }

  // 2. Delete all WeatherRoute objects
  for (WeatherRoute* wr : m_WeatherRoutes) {
    delete wr;
  }

  // 3. Clear the model
  m_WeatherRoutes.clear();

  // 4. Clear the UI list control
  lc->DeleteAllItems();

  // 5. Thaw UI
  lc->Thaw();

  // 6. Refresh dialogs and UI state
  UpdateDialogs();
  GetParent()->Refresh();
}


//------------------------------------------
//   8.2 Selection
//------------------------------------------

void
    WeatherRouting::SelectRouteInList(WeatherRoute* wr) {
  if (!wr) return;

  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  if (!lc) return;

  // Find the index of this WeatherRoute in the model
  long index = -1;

  long i = 0;
  for (auto it = m_WeatherRoutes.begin(); it != m_WeatherRoutes.end();
       ++it, ++i) {
    if (*it == wr) {
      index = i;
      break;
    }
  }

  if (index == -1) return;  // Not found

  // Clear any previous selection (wxListCtrl has no UnselectAll)
  long item = -1;
  while (true) {
    item = lc->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item == -1) break;
    lc->SetItemState(item, 0, wxLIST_STATE_SELECTED);
  }

  // Select the row
  lc->SetItemState(index, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);

  // Ensure it is visible
  lc->EnsureVisible(index);
}


//------------------------------------------
//   8.3 Column / WeatherRouting  Table Management
//------------------------------------------

void WeatherRouting::RebuildListControlColumns() {
  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  if (!lc) return;

  // Freeze UI to avoid flicker
  lc->Freeze();

  // 1. Remove all existing columns
  lc->DeleteAllColumns();

  // 2. Rebuild the columns[] mapping based on user settings
  int colIndex = 0;
  for (int i = 0; i < NUM_COLS; i++) {
    if (m_SettingsDialog.m_cblFields->IsChecked(i)) {
      columns[i] = colIndex;

      wxString name = column_names[i];

      // Add "(local)" or "(UTC)" to time columns
      if (i == STARTTIME || i == ENDTIME) {
        name += " (";
        if (m_SettingsDialog.m_cbUseLocalTime->GetValue())
          name += _("local");
        else
          name += _("UTC");
        name += ")";
      }

      lc->InsertColumn(colIndex, name);
      lc->SetColumnWidth(colIndex, wxLIST_AUTOSIZE);
      colIndex++;
    } else {
      columns[i] = -1;  // column hidden
    }
  }

  // 3. Rebuild all rows (item data + values)
  long count = lc->GetItemCount();
  lc->DeleteAllItems();

  long index = 0;
  for (auto wr : m_WeatherRoutes) {
    wxListItem item;
    item.SetId(index);
    item.SetData(reinterpret_cast<wxUIntPtr>(wr));
    item.SetText("");  // STATE column will be filled by UpdateItem
    lc->InsertItem(item);

    UpdateItem(index, true);
    index++;
  }

  // 4. Thaw UI
  lc->Thaw();
}


/*************************************************************************/
/*     9.WeatherRoute::Update(Model Update Logic)  full 1?30?2026 version */
/**************************************************************************/
// Update
//   Update the WeatherRoute fields from the RouteMapOverlay
//   Called when the RouteMapOverlay has new data
//   Typically after a computation step or completion
//   Update can be full or state only
//   If stateonly == true, only the State field is updated
//   Used when only the State may have changed (eg. Started, Stopped, Error
//   Finished, etc.)
//   If stateonly == false, all fields are updated
//   Used when the route has new data (eg. after a computation step or
//   completion)
// UpdateItem
//   Displays the WeatherRoute fields in the wxListCtrl
//   Called after WeatherRoute::Update to refresh the UI
// RebuildList
//   Rebuilds the wxListCtrl columns based on user settings
//   Called when user changes column visibility settings
// ------------------------------------------------------------

// THIS IS THE MODERNIZED, FULLY REFACTORED WeatherRoute::Update METHOD

void WeatherRoute::Update(WeatherRouting* wr, bool stateonly) {
  wxLogMessage("WR: WeatherRoute::Update() entered");

  // ------------------------------------------------------------
  //    1. Update all computer fields (unless stateonly == true)
  //  -----------------------------------------------------------
  if (!stateonly) {
    // Clear computed fields ONLY when overlay is dirty AND this is a full
    // update
    if (!stateonly && routemapoverlay->IsDirty()) {
      ClearComputedFields();
      routemapoverlay->ClearDirty();
    }

    RouteMapConfiguration configuration = routemapoverlay->GetConfiguration();

    BoatFilename = configuration.boatFileName;

    // Add handling for Start field based on StartType
    if (configuration.StartType == RouteMapConfiguration::START_FROM_BOAT) {
      Start = _("Boat");
    } else {
      Start = configuration.Start;
    }

    StartType =
        configuration.StartType == RouteMapConfiguration::START_FROM_POSITION
            ? _("From Position")
            : _("From Boat");

    UseCurrentTime = configuration.UseCurrentTime ? _("true") : _("false");

    wxDateTime starttime = configuration.StartTime;
    if (wr->GetSettingsDialog().m_cbUseLocalTime->GetValue())
      starttime = starttime.FromUTC();
    StartTime = starttime.Format("%x %H:%M");

    End = configuration.End;

    wxDateTime endtime = routemapoverlay->EndTime();
    if (endtime.IsValid()) {
      if (wr->GetSettingsDialog().m_cbUseLocalTime->GetValue())
        endtime = endtime.FromUTC();
      EndTime = endtime.Format("%x %H:%M");
    } else {
      EndTime = "N/A";
    }

    // REFACTORING
    // Dedicate a function to display the difference
    // between the two TimeDate. Useful in other parts of the code.
    Time = calculateTimeDelta(starttime, endtime);

    Distance = wxString::Format(
        "%.0f/%.0f", routemapoverlay->RouteInfo(RouteMapOverlay::DISTANCE),
        DistGreatCircle_Plugin(configuration.StartLat, configuration.StartLon,
                               configuration.EndLat, configuration.EndLon));

    AvgSpeed = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::AVGSPEED));

    MaxSpeed = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::MAXSPEED));

    AvgSpeedGround = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::AVGSPEEDGROUND));

    MaxSpeedGround = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::MAXSPEEDGROUND));

    AvgWind = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::AVGWIND));

    MaxWind = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::MAXWIND));

    MaxWindGust = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::MAXWINDGUST));

    AvgCurrent = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::AVGCURRENT));

    MaxCurrent = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::MAXCURRENT));

    AvgSwell = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::AVGSWELL));

    MaxSwell = wxString::Format(
        "%.1f", routemapoverlay->RouteInfo(RouteMapOverlay::MAXSWELL));

    UpwindPercentage = wxString::Format(
        "%.1f%%",
        routemapoverlay->RouteInfo(RouteMapOverlay::PERCENTAGE_UPWIND));

    double ps = routemapoverlay->RouteInfo(RouteMapOverlay::PORT_STARBOARD);
    PortStarboard = wxString::Format("%.0f/%.0f", ps, 100 - ps);

    Tacks = wxString::Format(
        "%.0f", routemapoverlay->RouteInfo(RouteMapOverlay::TACKS));
    Jibes = wxString::Format(
        "%.0f", routemapoverlay->RouteInfo(RouteMapOverlay::JIBES));
    SailPlanChanges = wxString::Format(
        "%.0f", routemapoverlay->RouteInfo(RouteMapOverlay::SAIL_PLAN_CHANGES));

    // CUSTOMIZATION  Display sailing comfort
    int comfort_level = routemapoverlay->RouteInfo(RouteMapOverlay::COMFORT);
    Comfort = RouteMapOverlay::sailingConditionText(comfort_level);
  }
  // -----------------------------------
  //  2. Compute and Update State field
  // -----------------------------------
  if (!routemapoverlay->Valid()) {
    State = _("Invalid Start/End");
    wxString error = routemapoverlay->GetError();
    wxString weatherError = routemapoverlay->GetWeatherForecastError();
    if (!error.IsEmpty())
      State += ": " + error;
    else if (!weatherError.IsEmpty())
      State += ": " + weatherError;
    return;
  }

  if (routemapoverlay->Running()) {
    State = _("Computing...");
    return;
  }

  if (routemapoverlay->m_Stopped) {
    State = _("Stopped");
    return;
  }
  // --------------------------------------------
  //  3. Finished Route
  // --------------------------------------------
  if (routemapoverlay->Finished()) {
    if (routemapoverlay->ReachedDestination()) {
      State = _("Complete");
    } else {
      // Partial / failed completion
      State = "";
      bool needsComma = false;

      wxString weatherStatus = routemapoverlay->GetWeatherForecastError();
      if (weatherStatus != wxEmptyString) {
        if (needsComma) State += ", ";
        State += _("Grib");
        State += ": ";
        State += weatherStatus;
        needsComma = true;
      }

      PolarSpeedStatus polarStatus = routemapoverlay->GetPolarStatus();
      if (polarStatus != POLAR_SPEED_SUCCESS) {
        if (needsComma) State += ", ";
        State += _("Polar");
        State += ": ";
        State += Polar::GetPolarStatusMessage(polarStatus);
        needsComma = true;
      }

      wxString gribError = routemapoverlay->GetGribError();
      if (gribError != wxEmptyString) {
        if (needsComma) State += ", ";
        State += gribError;
        needsComma = true;
      }

      if (routemapoverlay->LandCrossing()) {
        if (needsComma) State += ", ";
        State += _("Land");
        State += ": ";
        State += _("Failed");
        needsComma = true;
      }

      if (routemapoverlay->BoundaryCrossing()) {
        if (needsComma) State += ", ";
        State += _("Boundary");
        State += ": ";
        State += _("Failed");
      }
    }
    return;
  }
  // -----------------------------------------
  //  4. Waiting in queue state
  // -----------------------------------------
  if (wr->IsWaiting(routemapoverlay)) {
    State = _("Waiting...");
    return;
  }

  // -------------------------------------
  // 5. READY state (idle, not computed)
  // --------------------------------------
  State = _("Ready");
}


/*
void WeatherRouting::UpdateItem(int index, bool changed) {
  if (index < 0 || index >= (int)m_WeatherRoutes.size()) return;

  auto it = m_WeatherRoutes.begin();
  std::advance(it, index);
  WeatherRoute* wr = *it;

  RouteMapOverlay* ov = wr->routemapoverlay;

  // --- Column: State ---
  SetColumn(index, STATE, wr->State);

  // If overlay missing or not computed, clear everything
  if (!ov || !ov->Finished() || ov->GetIsoChronList().empty()) {
    wr->ClearComputedFields();    // model-side clear
    ClearComputedColumns(index);  // UI-side clear
    return;
  }

  const auto& origin = ov->GetIsoChronList();
  IsoChron* firstIso = origin.front();
  IsoChron* lastIso = origin.back();

  if (!firstIso || !lastIso) {
    wr->ClearComputedFields();
    ClearComputedColumns(index);
    return;
  }

  // --- Start Time ---
  wxString startStr = firstIso->time.FormatISOCombined(' ');
  SetColumn(index, STARTTIME, startStr);

  // --- End Time ---
  wxString endStr = lastIso->time.FormatISOCombined(' ');
  SetColumn(index, ENDTIME, endStr);

  // --- Time ---
  wxTimeSpan span = lastIso->time - firstIso->time;
  wxString timeStr = span.Format("%H:%M");
  SetColumn(index, TIME, timeStr);

  // --- Distance ---
  double dist = 0.0;
  const Position* dest = nullptr;

  if (ov->Finished() && ov->ReachedDestination())
    dest = ov->GetDestinationPosition();

  if (dest) dist = ComputeRouteDistance(dest);

  wxString distStr = wxString::Format("%.1f nm", dist);
  SetColumn(index, DISTANCE, distStr);

  // --- Static metadata ---
  UpdateStaticColumns(index, wr);

  // --- Computed values ---
  UpdateComputedColumns(index, wr);
}
*/



void WeatherRouting::UpdateItem(int index, bool changed) {
  if (index < 0 || index >= (int)m_WeatherRoutes.size()) return;
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  if (index < 0 || index >= m_panel->m_lWeatherRoutes->GetItemCount()) return;


  auto it = m_WeatherRoutes.begin();
  std::advance(it, index);
  WeatherRoute* wr = *it;

 // WeatherRoute* wr = m_WeatherRoutes[index];
  RouteMapOverlay* ov = wr->routemapoverlay;

  // --- Always write the State column ---
  SetColumn(index, STATE, wr->State);

  // --- Always write static configuration columns ---
  UpdateStaticColumns(index, wr);

  // If route not computed yet, leave computed columns blank
  if (!ov || !ov->Finished() || ov->GetIsoChronList().empty()) {
    ClearComputedColumns(index);
    return;
  }

  // --- Now write computed columns ---
  const auto& origin = ov->GetIsoChronList();
  IsoChron* firstIso = origin.front();
  IsoChron* lastIso = origin.back();

  if (!firstIso || !lastIso) {
    ClearComputedColumns(index);
    return;
  }

  // Start Time
  SetColumn(index, STARTTIME, firstIso->time.FormatISOCombined(' '));

  // End Time
  SetColumn(index, ENDTIME, lastIso->time.FormatISOCombined(' '));

  // Duration
  wxTimeSpan span = lastIso->time - firstIso->time;
  SetColumn(index, TIME, span.Format("%H:%M"));

  // Distance
  double dist = 0.0;
  const Position* dest = nullptr;

  if (ov->Finished() && ov->ReachedDestination())
    dest = ov->GetDestinationPosition();

  if (dest) dist = ComputeRouteDistance(dest);

  SetColumn(index, DISTANCE, wxString::Format("%.1f nm", dist));

  // Computed values
  UpdateComputedColumns(index, wr);

}



// Rebuilds the columns in the wxListCtrl based on user settings and updates all
// rows to reflect any changes (eg. local/UTC switch for time columns)
// Called when user changes column visibility settings or local/UTC time setting

void WeatherRouting::UpdateColumns() {

  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  m_panel->m_lWeatherRoutes->DeleteAllColumns();

  for (int i = 0; i < NUM_COLS; i++) {
    if (GetSettingsDialog().m_cblFields->IsChecked(i)) {
      columns[i] = m_panel->m_lWeatherRoutes->GetColumnCount();
      wxString name = _(column_names[i]);

      if (i == STARTTIME || i == ENDTIME) {
        name += " (";
        if (GetSettingsDialog().m_cbUseLocalTime->GetValue())
          name += _("local");
        else
          name += "UTC";
        name += ")";
      }

      m_panel->m_lWeatherRoutes->InsertColumn(columns[i], name);
      m_panel->m_lWeatherRoutes->SetColumnWidth(columns[i], wxLIST_AUTOSIZE);
    } else
      columns[i] = -1;
  }

  std::list<WeatherRoute*>::iterator it = m_WeatherRoutes.begin();
  for (int i = 0; i < m_panel->m_lWeatherRoutes->GetItemCount(); i++, it++) {
    m_panel->m_lWeatherRoutes->SetItemPtrData(i, (wxUIntPtr)*it);
    (*it)->Update(
        this);  // update utc/local switch to strings of start/end time
    UpdateItem(i, true);
  }

  OnWeatherRouteSelected();  // update utc/local switch if configuration dialog
                             // is visible
}




void WeatherRouting::RebuildList() {
  // Preserve selection
  std::vector<WeatherRoute*> selected;
  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);
    if (item == -1) break;
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));
    selected.push_back(wr);
  }
  // Preserve scroll position
  int top = m_panel->m_lWeatherRoutes->GetTopItem();
  // Clear and rebuild
  m_panel->m_lWeatherRoutes->Freeze();
  m_panel->m_lWeatherRoutes->DeleteAllItems();

  for (auto* wr : m_WeatherRoutes) {
    if (!wr->Filtered) {
      wxListItem item;
      item.SetId(m_panel->m_lWeatherRoutes->GetItemCount());
      item.SetData(wr);
      long idx = m_panel->m_lWeatherRoutes->InsertItem(item);
      UpdateItem(idx, true);
    }
  }
  // Restore selection
  for (long i = 0; i < m_panel->m_lWeatherRoutes->GetItemCount(); i++) {
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));

    if (std::find(selected.begin(), selected.end(), wr) != selected.end())
      m_panel->m_lWeatherRoutes->SetItemState(i, wxLIST_STATE_SELECTED,
                                              wxLIST_STATE_SELECTED);
  }
  // Restore scroll position
  if (top >= 0) m_panel->m_lWeatherRoutes->EnsureVisible(top);
  m_panel->m_lWeatherRoutes->Thaw();
}


/*********************************************************/
/*   10.Thread Lifecycle(Modern 3?Phase Model)     */
/*********************************************************/
// StopAll
//    Stops all route threads safely
//    by signaling workers to stop, waiting for worker
//    exit signal, and thencleaning up
// ResetAll
//    Resets all routes using the unified 3 phase lifecycle
//    Stops all threads, resets each overlay, then updates the UI
// WaitForAllRoutesToStop
//    Waits for all route threads to exit and be joined
//-------------------------
// Stop(RouteMapOverlay*)
//    Stops a single route thread safely
// Reset(RouteMapOverlay*)
//    Resets a single route using the unified 3 phase lifecycle
//-------------------------
// ResetSelected
//   Stops and resets only the selected RouteMapOverlay objects
//   then updates the UI
// WaitForRoutesToStop
//   Waits for the specified route threads to exit and be joined
//   by iterating over a list of RouteMapOverlay pointers

//------------------------------------------
//   10.1 Global
//------------------------------------------

void WeatherRouting::StopAll() {
  if (m_shuttingDown)
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
      return;

  wxLogMessage("WeatherRouting::StopAll - BEGIN");

#ifdef __WXMSW__
  DisableNewComputations();
#endif

  // ------------------------------------------------------------
  // 1. Snapshot the overlays under lock
  // ------------------------------------------------------------
  std::vector<RouteMapOverlay*> overlays;
  {
    wxMutexLocker lock(m_OverlayListMutex);
    overlays.reserve(m_RouteMapOverlays.size());
    for (auto* o : m_RouteMapOverlays) overlays.push_back(o);
  }

  wxLogMessage("StopAll: snapshot contains %zu overlay(s)", overlays.size());

  // ------------------------------------------------------------
  // Phase 1: signal all workers to stop
  // ------------------------------------------------------------
  for (auto* overlay : overlays) {
    if (!overlay) continue;

    if (!overlay->HasThread()) {
      wxLogMessage("StopAll: overlay=%p has no thread, skipping signal",
                   overlay);
      continue;
    }

    wxLogMessage("StopAll: signaling overlay=%p to stop", overlay);
    overlay->SetFinished(true);
    overlay->m_Stopped = true;
  }

  // ------------------------------------------------------------
  // Phase 2: wait for workers to exit
  // ------------------------------------------------------------
  WaitForAllRoutesToStop();

  // ------------------------------------------------------------
  // Phase 3: cleanup thread objects
  // ------------------------------------------------------------
  for (auto* overlay : overlays) {
    if (!overlay) continue;

    if (overlay->ThreadExited() && overlay->HasThread()) {
      wxLogMessage("StopAll: Stop() on overlay=%p (thread exited)", overlay);
      overlay->Stop();  // safe: worker already exited
      m_WaitingRouteMaps.remove(overlay);
      m_RunningRouteMaps.remove(overlay);
    }
  }
  AssertThreadLifecycleInvariants();
  wxLogMessage("WeatherRouting::StopAll - END");
}



void WeatherRouting::ResetAll() {
  if (m_shuttingDown)
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
      return;

  wxLogMessage("WeatherRouting::ResetAll - BEGIN");

  // Stop all threads first
  StopAll();

  // Snapshot overlays under lock
  std::vector<RouteMapOverlay*> overlays;
  {
    wxMutexLocker lock(m_OverlayListMutex);
    overlays = m_RouteMapOverlays;
  }

  // Reset each overlay using the canonical 3?phase lifecycle
  for (auto* overlay : overlays) {
    if (overlay) Reset(overlay);
  }

 // Clear cursor highlight
  m_positionOnRoute = nullptr;

  // 5. Refresh UI once (global refresh)
  UpdateAllItems(true);
  UpdateDialogs();
  UpdateComputeState();

  if (GetParent())
      GetParent()->Refresh();

  AssertThreadLifecycleInvariants();
  wxLogMessage("WeatherRouting::ResetAll - END");
}


void WeatherRouting::WaitForAllRoutesToStop() {
  if (m_shuttingDown)
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
      return;

  wxLogMessage("WeatherRouting::WaitForAllRoutesToStop - BEGIN");

  std::vector<RouteMapOverlay*> overlays;
  {
    wxMutexLocker lock(m_OverlayListMutex);
    overlays.reserve(m_RouteMapOverlays.size());
    for (auto* o : m_RouteMapOverlays) overlays.push_back(o);
  }

  auto start = std::chrono::steady_clock::now();
  const auto timeout = std::chrono::seconds(5);

  bool allExited = false;

  while (!allExited) {
    allExited = true;

    for (auto* overlay : overlays) {
      if (!overlay) continue;

      // No thread? Already stopped.
      if (!overlay->HasThread()) continue;

      if (!overlay->ThreadExited()) {
        allExited = false;
        break;
      }
    }

    if (allExited) break;

#ifdef PLUGIN_USE_ASM
    if (std::chrono::steady_clock::now() - start > timeout) {
      wxLogMessage("WaitForAllRoutesToStop - TIMEOUT");
      break;
    }
#endif
    wxThread::Sleep(20);
  }

  // After waiting, log any overlays still running
  for (auto* overlay : overlays) {
    if (overlay && overlay->HasThread() && !overlay->ThreadExited()) {
      wxLogMessage("WaitForAllRoutesToStop: overlay=%p still running", overlay);
    }
  }

  wxLogMessage("WeatherRouting::WaitForAllRoutesToStop - END");
}


//------------------------------------------
//   10.2 Per?Route
//------------------------------------------

void WeatherRouting::Stop(RouteMapOverlay* routemapoverlay) {
  if (!routemapoverlay) return;

  // Signal the overlay to stop its worker thread
  routemapoverlay->Stop();

  // Ensure scheduler invariants still hold
  AssertThreadLifecycleInvariants();
}


void WeatherRouting::Reset(RouteMapOverlay* overlay) {
  if (!overlay) return;

  wxLogMessage("WeatherRouting::Reset(per-route) - BEGIN overlay=%p", overlay);

  // Phase 1: signal worker to stop (if running)
  overlay->SetFinished(true);
  overlay->m_Stopped = true;

  // Phase 2: wait for this route's thread to terminate
  std::list<RouteMapOverlay*> one = {overlay};
  WaitForRoutesToStop(one);

  // Phase 3: cleanup thread object for this overlay
  if (overlay->ThreadExited() && overlay->HasThread()) {
    wxLogMessage("WeatherRouting::Reset(per-route) - stopping overlay %p",
                 overlay);
    overlay->Stop();  // join + delete thread
  }

  // 4. Reset compute engine
  overlay->Clear();  // engine reset

  // 5. Mark dirty so UI clears computed fields
  overlay->MarkDirty();

  // 6. Clear cursor highlight
  m_positionOnRoute = nullptr;

  // 7. Update UI for this route only
  UpdateRouteMap(overlay);

  AssertThreadLifecycleInvariants();
  wxLogMessage("WeatherRouting::Reset(per-route) - END overlay=%p", overlay);
}

void WeatherRoute::ClearComputedFields() {
  // TODO: clear any cached/computed values
}
// Not complete yet
//But the existence of this function is important.
// It?s part of the routing engine lifecycle,
//and it?s meant to be called whenever 
//    a route is invalidated
//    a route is recomputed
//    a route is deleted
//    a route?s inputs change
//    the solver needs a clean slate
//Right now
// the function is a stub because the computed fields
// haven?t been enumerated and centralized yet.
// Once the computed fields are identified,
// this function will be implemented to clear them all.
// total route time, total distance, average speed,
// fuel consumption estimates, waypoints reached,
// weather impact assessments, cached performance predictions,
// solveer states, parent pointers best route or best position references,




// ResetSelected stops and clears only the selected RouteMapOverlay objects,
// then updates their states in the UI.
// ------------------------------------------------------------
// 1. Gather selected overlays
//      CurrentRouteMaps(false) returns ONLY the overlays whose
//      corresponding WeatherRoute entries are selected in the UI.
//    This is the authoritative selection API for this plugin.
// ------------------------------------------------------------
void WeatherRouting::ResetSelected() {

    if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxLogMessage("============================================================");
  wxLogMessage("WeatherRouting::ResetSelected - BEGIN");

  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  //    The list control is the authoritative source of selection.
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  wxLogMessage("ResetSelected: %zu overlay(s) selected", overlays.size());

  if (overlays.empty()) {
    wxLogMessage("ResetSelected: no routes selected ? nothing to do");
    wxLogMessage("WeatherRouting::ResetSelected - END (no selection)");
    wxLogMessage(
        "============================================================");
    return;
  }

  // ---------------------------------------------------------------------
  // 2. Log each selected overlay pointer for debugging
  // ---------------------------------------------------------------------
  for (auto* ov : overlays) {
    wxLogMessage("ResetSelected: selected overlay=%p", ov);
  }

  // ---------------------------------------------------------------------
  // 3. Reset each selected overlay using the safe 3?phase Reset(overlay)
  //
  // Reset(overlay) performs:
  //   Phase 1: overlay->SetFinished(true), overlay->m_Stopped = true
  //   Phase 2: WaitForRoutesToStop({overlay})  (wait for worker exit)
  //   Phase 3: overlay->Stop()  (join + delete thread)
  //            overlay->Reset() (compute engine reset)
  //            overlay->MarkDirty()
  //            UpdateRouteMap(overlay)
  //
  // DO NOT call Stop(), Wait(), or MarkDirty() here.
  // Reset(overlay) encapsulates the entire safe lifecycle.
  // ---------------------------------------------------------------------
  for (auto* overlay : overlays) {
    if (!overlay) {
      wxLogWarning("ResetSelected: encountered NULL overlay pointer");
      continue;
    }

    wxLogMessage("ResetSelected: invoking Reset(per-route) for overlay=%p",
                 overlay);
    Reset(overlay);
  }

  // ---------------------------------------------------------------------
  // 4. Clear cursor highlight (UI state only)
  // ---------------------------------------------------------------------
  wxLogMessage("ResetSelected: clearing m_positionOnRoute cursor highlight");
  m_positionOnRoute = nullptr;

  // ---------------------------------------------------------------------
  // 5. Refresh UI once after all resets
  // ---------------------------------------------------------------------
  wxLogMessage("ResetSelected: refreshing UI");
  UpdateAllItems(true);
  UpdateDialogs();
  UpdateComputeState();
  GetParent()->Refresh();

  wxLogMessage("WeatherRouting::ResetSelected - END");
  wxLogMessage("============================================================");
}


void WeatherRouting::WaitForRoutesToStop(
    const std::list<RouteMapOverlay*>& overlays) {

  if (m_shuttingDown)
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;

  wxLogMessage("WeatherRouting::WaitForRoutesToStop(one) - BEGIN, count=%zu",
               overlays.size());

  auto start = std::chrono::steady_clock::now();
  const auto timeout = std::chrono::seconds(5);

  bool allExited = false;

  while (!allExited) {
    allExited = true;

    for (auto* ov : overlays) {
      if (!ov) continue;

      // No thread? Consider it already stopped.
      if (!ov->HasThread()) continue;

      if (!ov->ThreadExited()) {
        allExited = false;
        break;
      }
    }

    if (allExited) break;

#ifdef PLUGIN_USE_ASM
    if (std::chrono::steady_clock::now() - start > timeout) {
      wxLogMessage("WaitForRoutesToStop(one) - TIMEOUT");
      break;
    }
#endif
    wxThread::Sleep(20);
  }

  // After waiting, log any overlays that are still running
  for (auto* ov : overlays) {
    if (ov && ov->HasThread() && !ov->ThreadExited()) {
      wxLogMessage("WaitForRoutesToStop(one): overlay=%p still running", ov);
    }
  }

  wxLogMessage("WeatherRouting::WaitForRoutesToStop(one) - END");
}



/*********************************************************/
/*   10.Route Lifecyle Management                         */
/*********************************************************/
//  ResetSelectedRoutes() 
//      Resets only the selected routes in the list control
//  DeleteRouteMaps() This is the paradym See Heading 12
//     Deletes the RouteMapOverlay objects and their associated
//     WeatherRoute entries from the model and UI.
//  DeleteAllRoutes()  see DeleteAll under 8.1 Add / Remove
//      Deletes all RouteMapOverlay objects and their associated
//      WeatherRoute entries from the model and UI.
//  StopAllRoutes()  See StopAll under  10.1 Global
//      Stops all running route computations.
//  StopRoute()      See Stop under 10.2 Per-Route
//      Stops a single route computation.
//  ResetRoute()  See Reset under 10.2 Per-Route
//      Resets a single route computation.


void WeatherRouting::ResetSelectedRoutes() {
  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  if (!lc) return;

  // Collect selected indices
  std::vector<long> selected;
  long item = -1;

  for (;;) {
    item = lc->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item == -1) break;
    selected.push_back(item);
  }

  if (selected.empty()) return;

  // Gather overlays to reset
  std::list<RouteMapOverlay*> overlays;
  for (long idx : selected) {
    if (idx < 0 || idx >= (long)m_WeatherRoutes.size()) continue;

    auto it = m_WeatherRoutes.begin();
    std::advance(it, idx);
    WeatherRoute* wr = *it;
    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  // 1. Signal stop
  for (auto* ov : overlays) {
    ov->SetFinished(true);
    ov->m_Stopped = true;
  }

  // 2. Wait for threads to exit
  WaitForRoutesToStop(overlays);

  // 3. Reset each overlay using canonical per-route reset
  for (auto* ov : overlays) {
    // Remove from scheduler lists
    m_WaitingRouteMaps.remove(ov);
    m_RunningRouteMaps.remove(ov);

    // Stop thread object if still present
    if (ov->HasThread()) ov->Stop();

    ov->DeleteThread();

    // Modern compute-engine reset
    ov->Clear();

    // Clear model-side computed fields
    for (auto* wr : m_WeatherRoutes) {
      if (wr->routemapoverlay == ov) wr->ClearComputedFields();
    }

    // Update UI for this overlay only
    UpdateRouteMap(ov);
  }

  // 4. Global UI refresh pipeline
  m_ReportDialog.m_bReportStale = true;
  SetEnableConfigurationMenu();
  UpdateAllItems(true);
  UpdateDialogs();
  UpdateComputeState();

  if (GetParent()) GetParent()->Refresh();
}

/*********************************************************/
/*   11.Compute Scheduler     */
/*********************************************************/
// StartAll
//   Begins processing all RouteMapOverlay objects
//   by populating the waiting list and starting the
//   compute scheduler timer.
// OnComputationTimer
//   Is the timer event handler that manages the compute
//   scheduling, worker startup, and UI updates.
// OnHideConfigurationTimer
//   Handles delayed hiding of the configuration dialog
//   after computations complete.
// FirstCurrentRouteMap
//   Returns the first RouteMapOverlay in the current
//   selection (or NULL if none).
// CurrentRouteMaps
//   Returns a list of all RouteMapOverlay objects
//   corresponding to the current selection in the UI.
//   If includeUnselected==true, returns ALL overlays.


void WeatherRouting::StartAll() {
  wxLogMessage("StartAll(): building waiting list from all overlays");

  // Reset scheduler lists
  m_WaitingRouteMaps.clear();
  m_RunningRouteMaps.clear();

  // Populate waiting list from all known overlays
  for (auto* ov : m_RouteMapOverlays) {
    if (!ov) continue;
    m_WaitingRouteMaps.push_back(ov);
  }

  // Set counters
  m_RoutesToRun = m_WaitingRouteMaps.size();
  m_bRunning = (m_RoutesToRun > 0);

  wxLogMessage("StartAll(): %zu route(s) queued for computation",
               m_WaitingRouteMaps.size());

    // Start scheduler timer
  if (m_bRunning) UpdateComputeState();

  AssertThreadLifecycleInvariants();
}


void WeatherRouting::OnHideConfigurationTimer(wxTimerEvent& event) {
  m_ConfigurationDialog.Hide();
}


void WeatherRouting::OnComputationTimer(wxTimerEvent& event) {
  // Safety: UI must exist
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  // =========================================================
  // 1. CLEAN UP RUNNING OVERLAYS
  //
  // Each RouteMapOverlay owns its worker thread.
  // The scheduler NEVER joins or deletes threads directly.
  // Instead, it checks overlay state:
  //   - Running() means the worker thread is alive
  //   - IsThreadExited() means the worker thread has returned
  //   - Stop() performs the join + cleanup on the overlay
  //
  // This ensures thread lifecycle is race?free and deterministic.
  // =========================================================
  for (auto it = m_RunningRouteMaps.begin(); it != m_RunningRouteMaps.end();) {
    RouteMapOverlay* ov = *it;
    if (!ov) {
      it = m_RunningRouteMaps.erase(it);
      continue;
    }

    // Worker thread has exited: overlay must finalize its own cleanup.
    // Stop() joins the thread, clears m_Thread, sets m_Stopped, etc.
    if (ov->ThreadExited()) {
      ov->Stop();
    }

    // If overlay is no longer Running(), the worker thread is gone.
    // Remove it from the running list and update UI.
    if (!ov->Running()) {
      UpdateRouteMap(ov);  // WeatherRoute::Update() computes correct State
      it = m_RunningRouteMaps.erase(it);
    } else {
      // Still computing: update UI row
      UpdateRouteMap(ov);
      ++it;
    }
  }
  // =========================================================
  // 2. PROMOTE WAITING ? RUNNING
  //
  // Only the scheduler starts worker threads.
  // Concurrency limit is enforced here.
  //
  // ov->Start(error):
  //   - Creates worker thread
  //   - Sets Running() = true
  //   - Returns false if thread could not be created
  //
  // If Start() fails, overlay remains non?running and is NOT requeued.
  // =========================================================
  // _CRTDBG_REPORT_FLAG |= _CRTDBG_LEAK_CHECK_DF; 
  //  const int maxConcurrent = GetSettingsDialog().m_sMaxConcurrent->GetValue();

  const int maxConcurrent = 1;  // modern architecture: one thread at a time

  while ((int)m_RunningRouteMaps.size() < maxConcurrent &&
         !m_WaitingRouteMaps.empty()) {
    RouteMapOverlay* ov = m_WaitingRouteMaps.front();
    m_WaitingRouteMaps.pop_front();

    if (!ov) continue;

    wxString error;
    if (!ov->Start(error)) {
      // Worker thread could not be created.
      // UI will show the error via WeatherRoute::Update().
      wxLogMessage("OnComputationTimer: Failed to start overlay: %s",
                   error.mb_str());
      UpdateRouteMap(ov);
      continue;
    }

    // Worker thread successfully created.
    m_RunningRouteMaps.push_back(ov);
    UpdateRouteMap(ov);  // State becomes "Computing..."
  }
  // =========================================================
  // 3. GRIB REQUEST HANDLING
  //
  // Only one overlay at a time may request GRIB.
  // NeedsGrib() is set by the worker thread when it reaches a GRIB boundary.
  //
  // The scheduler:
  //   - detects the first overlay needing GRIB
  //   - sets m_RouteMapOverlayNeedingGrib
  //   - calls RequestGrib() (main?thread safe)
  //
  // Worker threads remain blocked until GRIB arrives.
  // =========================================================

  // OLD CODE  REMOVED FOR CLARITY
  // m_RouteMapOverlayNeedingGrib = nullptr;

  //for (auto* ov : m_RunningRouteMaps) {
  //  if (ov && ov->NeedsGrib()) {
  //    m_RouteMapOverlayNeedingGrib = ov;
  //    RequestGrib();
  //    break;
  //   }
  // }
  // =========================================================
  // 4. PROGRESS BAR UPDATE
  //
  // Progress = total - waiting - running
  // Clamped to [0, total].
  //
  // Worker threads update Finished() internally.
  // Scheduler updates progress only from main thread.
  // =========================================================
  if (m_panel->m_gProgress) {
    int done = m_RoutesToRun - (int)m_WaitingRouteMaps.size() -
               (int)m_RunningRouteMaps.size();

    if (done < 0) done = 0;
    if (done > (int)m_RoutesToRun) done = m_RoutesToRun;

    m_panel->m_gProgress->SetValue(done);
  }
  // =========================================================
  // 5. UPDATE DIALOGS
  //
  // Statistics, Report, and Plot dialogs are read?only views.
  // They must be updated from the main thread only.
  // =========================================================
  UpdateDialogs();
  // =========================================================
  // 6. UPDATE COMPUTE STATE (buttons, status text)
  //
  // Compute enabled when at least one route is Ready/NotComputed.
  // Stop enabled when at least one worker thread is alive.
  //
  // This function does NOT touch worker threads.
  // =========================================================
  UpdateComputeState();
  // =========================================================
  // 7. RESTART TIMER IF WORK REMAINS
  //
  // The scheduler runs as a one?shot timer.
  // It restarts itself only when:
  //   - at least one worker thread is alive, OR
  //   - at least one overlay is waiting to be started
  //
  // When both lists are empty, computation is complete.
  // =========================================================
  if (!m_RunningRouteMaps.empty() || !m_WaitingRouteMaps.empty()) {
    m_tCompute.Start(25, true);
  } else {
    m_bRunning = false;
  }
  AssertSchedulerInvariants();
}


RouteMapOverlay* WeatherRouting::FirstCurrentRouteMap() {
  // Find the first selected WeatherRoute in the list control
  long item = m_panel->m_lWeatherRoutes->GetNextItem(-1, wxLIST_NEXT_ALL,
                                                     wxLIST_STATE_SELECTED);

  if (item < 0) return nullptr;

  WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
      wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

  return (wr && wr->routemapoverlay) ? wr->routemapoverlay : nullptr;
}





/*********************************************************/
/*   12.Route Deletion(Modern Safe Version)     */
/*********************************************************/
// DeleteRouteMaps
// Safely deletes the given list of RouteMapOverlay objects
// following a modern 4?phase lifecycle:
//   1. Signal all overlays to stop
//   2. Wait for all worker threads to exit
//   3. Remove overlays from scheduler lists
//   4. Remove overlays + WeatherRoute objects
//   5. Rebuild the wxListCtrl from scratch
//   6. UI updates

void WeatherRouting::DeleteRouteMaps(
    const std::list<RouteMapOverlay*>& overlays) {
  if (overlays.empty()) return;

  // ------------------------------------------------------------
  // 1. Reset each overlay using the canonical lifecycle
  //    (stop ? wait ? cleanup ? remove from scheduler lists)
  // ------------------------------------------------------------
  for (auto* ov : overlays) {
    if (!ov) continue;
    Reset(ov);
  }

  // ------------------------------------------------------------
  // 2. Remove WeatherRoute objects associated with these overlays
  // ------------------------------------------------------------
  for (auto* ov : overlays) {
    if (!ov) continue;

    for (auto it = m_WeatherRoutes.begin(); it != m_WeatherRoutes.end(); ++it) {
      WeatherRoute* wr = *it;
      if (wr->routemapoverlay == ov) {
        delete wr;
        m_WeatherRoutes.erase(it);
        break;
      }
    }
  }

  // ------------------------------------------------------------
  // 3. Rebuild the wxListCtrl from scratch
  // ------------------------------------------------------------
  m_panel->m_lWeatherRoutes->DeleteAllItems();

  long index = 0;
  for (auto* wr : m_WeatherRoutes) {
    wxListItem item;
    item.SetId(index);
    item.SetData(reinterpret_cast<wxUIntPtr>(wr));
    m_panel->m_lWeatherRoutes->InsertItem(item);
    UpdateItem(index, true);
    index++;
  }

  // ------------------------------------------------------------
  // 4. Global UI refresh pipeline
  // ------------------------------------------------------------
  UpdateDialogs();
  UpdateComputeState();
  if (GetParent()) GetParent()->Refresh();

  // ------------------------------------------------------------
  // 5. Ensure scheduler invariants still hold
  // ------------------------------------------------------------
  AssertSchedulerInvariants();
}


/*********************************************************/
/*    13.Batch Routing    */
/*********************************************************/
// GenerateBatch
//   Generates multiple weather routing configurations
//   based on user-defined parameters in the ConfigurationBatchDialog.
// --------------------------------------------------------------

void WeatherRouting::GenerateBatch() {
  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> routemapoverlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay)
      routemapoverlays.push_back(wr->routemapoverlay);
  }

  if (routemapoverlays.empty()) return;

  // ---------------------------------------------------------------------
  // 2. Prepare progress dialog and batch timing parameters
  // ---------------------------------------------------------------------
  wxProgressDialog* progressdialog = NULL;
  int count = routemapoverlays.size(), c = 0;
  int times = 0;

  wxTimeSpan StartSpan, StartSpacingSpan;
  double days, hours;

  ConfigurationBatchDialog& dlg = m_ConfigurationBatchDialog;
  dlg.m_tStartDays->GetValue().ToDouble(&days);
  StartSpan = wxTimeSpan::Days(days);

  dlg.m_tStartHours->GetValue().ToDouble(&hours);
  StartSpan += wxTimeSpan::Seconds(3600 * hours);

  dlg.m_tStartSpacingDays->GetValue().ToDouble(&days);
  StartSpacingSpan = wxTimeSpan::Days(days);

  dlg.m_tStartSpacingHours->GetValue().ToDouble(&hours);
  StartSpacingSpan += wxTimeSpan::Seconds(3600 * hours);

  if (!StartSpacingSpan.GetSeconds().ToLong()) {
    wxMessageDialog mdlg(this, _("Zero time span forbidden, aborting."),
                         _("Weather Routing"), wxOK | wxICON_ERROR);
    mdlg.ShowModal();
    return;
  }

  wxDateTime StartTime = wxDateTime::Now(), EndTime = StartTime + StartSpan;

  for (wxDateTime start = StartTime; start <= EndTime;
       start += StartSpacingSpan)
    times++;

  int sources = 0;
  for (auto it = dlg.sources.begin(); it != dlg.sources.end(); it++)
    for (auto it2 = (*it)->destinations.begin();
         it2 != (*it)->destinations.end(); it2++)
      sources++;

  count *= sources;
  count *= dlg.m_lBoats->GetCount();

  if (count > 10) {
    progressdialog = new wxProgressDialog(
        _("Batch configuration"), _("Weather Routing"), count, this,
        wxPD_CAN_ABORT | wxPD_ELAPSED_TIME | wxPD_REMAINING_TIME);
  }

  // ---------------------------------------------------------------------
  // 3. Main batch generation loop
  // ---------------------------------------------------------------------
  for (auto* ov : routemapoverlays) {
    RouteMapConfiguration configuration = ov->GetConfiguration();

    EndTime = configuration.StartTime + StartSpan;

    for (; configuration.StartTime <= EndTime;
         configuration.StartTime += StartSpacingSpan) {
      for (auto it = dlg.sources.begin(); it != dlg.sources.end(); it++) {
        configuration.Start = (*it)->Name;

        for (auto it2 = (*it)->destinations.begin();
             it2 != (*it)->destinations.end(); it2++) {
          configuration.End = (*it2)->Name;

          for (unsigned int boatindex = 0; boatindex < dlg.m_lBoats->GetCount();
               boatindex++) {
            configuration.boatFileName = dlg.m_lBoats->GetString(boatindex);

            for (int windstrength = dlg.m_sWindStrengthMin->GetValue();
                 windstrength <= dlg.m_sWindStrengthMax->GetValue();
                 windstrength += dlg.m_sWindStrengthStep->GetValue()) {
              configuration.WindStrength = windstrength / 100.0;

              AddConfiguration(configuration);
              m_WeatherRoutes.back()->routemapoverlay->LoadBoat();
              configuration =
                  m_WeatherRoutes.back()->routemapoverlay->GetConfiguration();

              if (progressdialog && !progressdialog->Update(c++)) goto abort;
            }
          }
        }
      }
    }
  }

abort:
  // ---------------------------------------------------------------------
  // 4. Cleanup: delete the overlays used for batch generation
  // ---------------------------------------------------------------------
  DeleteRouteMaps(routemapoverlays);

  delete progressdialog;
}


/*********************************************************/
/*    14.Export / Track / Route Saving    */
/*********************************************************/
// OnSaveAsTrack
//   Saves the selected RouteMapOverlay as a GPX track.
// OnSaveAllAsTracks
//    Saves all RouteMapOverlay objects as GPX tracks.
// OnSaveAsRoute
//   Saves the selected RouteMapOverlay as a GPX route.
// ShowRouteSaveOptionsDialog
//   Shows a dialog to get route save options from the user.
//   and returns the selected options.
// OnExportRouteAsGPX
//   Currently disabled. Placeholder for future functionality.
// SaveRouteOptions
//   Struct holding route save options.
// SaveAsTrack
//   Saves the given RouteMapOverlay as a GPX track.
//   Applies simplification if requested. Prompts for filename.
// SaveAsRoute
//   Saves the given RouteMapOverlay as a GPX route.
// SaveSimplifiedRouteAsGPX
//   Saves a simplified version of the given RouteMapOverlay
//   as a GPX route, applying the specified maximum time penalty.
//   Prompts for filename.


void WeatherRouting::OnSaveAsTrack(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  if (overlays.empty()) return;

  // ---------------------------------------------------------------------
  // 2. Save each selected overlay as a track
  // ---------------------------------------------------------------------
  for (auto* ov : overlays) {
    if (!ov) continue;

    SaveAsTrack(*ov);
  }
}

void WeatherRouting::OnSaveAllAsTracks(wxCommandEvent& event) {
  const int count = m_panel->m_lWeatherRoutes->GetItemCount();

  for (int i = 0; i < count; i++) {
    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(i)));

    if (!wr || !wr->routemapoverlay) continue;

    SaveAsTrack(*wr->routemapoverlay);
  }
}

void WeatherRouting::OnSaveAsRoute(wxCommandEvent& event) {
  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  // ---------------------------------------------------------------------
  // 2. If nothing is selected, warn the user
  // ---------------------------------------------------------------------
  if (overlays.empty()) {
    wxMessageDialog mdlg(this, _("No weather route selected"),
                         _("Weather Routing"), wxOK | wxICON_WARNING);
    mdlg.ShowModal();
    return;
  }

  // ---------------------------------------------------------------------
  // 3. Saving logic continues below (your existing SaveAsRoute handler)
  // ---------------------------------------------------------------------
  // The caller will now iterate overlays and call SaveAsRoute(*ov)
  // exactly as before.
}


void WeatherRouting::OnExportRouteAsGPX(wxCommandEvent & event) {
    wxMessageDialog mdlg(this, _("Export Route As GPX is currently disabled."),
                         _("Weather Routing"), wxOK | wxICON_INFORMATION);
    mdlg.ShowModal();
}


WeatherRouting::SaveRouteOptions
  WeatherRouting::ShowRouteSaveOptionsDialog() {
    SaveRouteOptions options;
    options.dialogAccepted = false;

    // Create a dialog with save options.
    wxDialog dlg(this, wxID_ANY, _("Save Route Options"), wxDefaultPosition,
                 wxDefaultSize);
    wxBoxSizer* mainSizer = new wxBoxSizer(wxVERTICAL);

    // Add simplify route option.
    wxCheckBox* cbSimplifyRoute =
        new wxCheckBox(&dlg, wxID_ANY, _("Simplify Route (experimental)"));
    cbSimplifyRoute->SetValue(true);
    mainSizer->Add(cbSimplifyRoute, 0, wxALL | wxEXPAND, 5);

    // Create a panel for simplification options that will be shown/hidden.
    wxPanel* simplifyPanel = new wxPanel(&dlg, wxID_ANY);
    wxBoxSizer* simplifyPanelSizer = new wxBoxSizer(wxVERTICAL);

    // Add time penalty control.
    wxStaticText* timePenaltyLabel =
        new wxStaticText(simplifyPanel, wxID_ANY, _("Maximum Time Loss (%)"));
    simplifyPanelSizer->Add(timePenaltyLabel, 0, wxALL | wxEXPAND, 5);

    // Create a horizontal sizer for the spinner and text display
    wxBoxSizer* penaltySizer = new wxBoxSizer(wxHORIZONTAL);

    // Add a spinner control for precise 0.1% increments
    wxSpinCtrlDouble* spinnerTimePenalty = new wxSpinCtrlDouble(
        simplifyPanel, wxID_ANY, wxEmptyString, wxDefaultPosition,
        wxDefaultSize, wxSP_ARROW_KEYS, 0.0, 20.0, 5.0, 0.1);
    spinnerTimePenalty->SetDigits(1);  // Show one decimal place

    penaltySizer->Add(spinnerTimePenalty, 1, wxALL | wxEXPAND, 5);

    // Add percentage text
    wxStaticText* percentLabel =
        new wxStaticText(simplifyPanel, wxID_ANY, _("%"));
    penaltySizer->Add(percentLabel, 0, wxALL | wxALIGN_CENTER_VERTICAL, 5);

    simplifyPanelSizer->Add(penaltySizer, 0, wxALL | wxEXPAND, 5);

    simplifyPanel->SetSizer(simplifyPanelSizer);
    mainSizer->Add(simplifyPanel, 0, wxALL | wxEXPAND, 5);

    wxStdDialogButtonSizer* buttonSizer = new wxStdDialogButtonSizer();
    buttonSizer->AddButton(new wxButton(&dlg, wxID_OK, _("Save")));
    buttonSizer->AddButton(new wxButton(&dlg, wxID_CANCEL));
    buttonSizer->Realize();

    mainSizer->Add(buttonSizer, 0, wxALL | wxEXPAND, 10);

    dlg.SetSizer(mainSizer);
    mainSizer->Fit(&dlg);
    dlg.Centre();

    // Setup checkbox event to show/hide simplification panel.
    cbSimplifyRoute->Bind(
        wxEVT_CHECKBOX, [simplifyPanel, &dlg, mainSizer](wxCommandEvent&) {
          simplifyPanel->Show(simplifyPanel->IsShown() ? false : true);
          mainSizer->Fit(&dlg);
        });

    if (dlg.ShowModal() == wxID_OK) {
      options.dialogAccepted = true;
      options.simplifyRoute = cbSimplifyRoute->GetValue();
      options.maxTimePenalty = spinnerTimePenalty->GetValue() / 100.0;
    }
    return options;
  }


void WeatherRouting::SaveAsTrack(RouteMapOverlay & routemapoverlay) {
    std::list<PlotData> plotdata = routemapoverlay.GetPlotData(false);

    if (plotdata.empty()) {
      wxMessageDialog mdlg(this, _("Empty routing, nothing to save\n"),
                           _("Weather Routing"), wxOK | wxICON_WARNING);
      mdlg.ShowModal();
      return;
    }

    PlugIn_Track* newPath = new PlugIn_Track;
    wxDateTime display_time = routemapoverlay.StartTime();
    if (GetSettingsDialog().m_cbUseLocalTime->GetValue())
      display_time = display_time.FromUTC();

    newPath->m_NameString =
        _("Weather Route ") + " (" + display_time.Format("%x %H:%M") + ")";

    // XXX double check time is really end time, not start time off by one.
    RouteMapConfiguration c = routemapoverlay.GetConfiguration();
    newPath->m_StartString = c.Start;
    newPath->m_EndString = c.End;
    newPath->m_GUID = GetNewGUID();

    for (auto const& it : plotdata) {
      PlugIn_Waypoint* newPoint = new PlugIn_Waypoint(
          it.lat, heading_resolve(it.lon), "circle", _("Weather Route Point"));

      newPoint->m_CreateTime = it.time;
      newPath->pWaypointList->Append(newPoint);
    }

// last point, missing if config didn't succeed
    const Position* p = routemapoverlay.GetDestinationPosition();
    if (p) {
      PlugIn_Waypoint* newPoint =
          new PlugIn_Waypoint(p->lat, heading_resolve(p->lon), "circle",
                              _("Weather Route Destination"));
      newPoint->m_CreateTime = routemapoverlay.EndTime();
      newPath->pWaypointList->Append(newPoint);
    }

    AddPlugInTrack(newPath);
    // not done PlugIn_Track DTOR
    newPath->pWaypointList->DeleteContents(true);
    newPath->pWaypointList->Clear();

    delete newPath;

    GetParent()->Refresh();

    wxMessageDialog mdlg(
        this,
        _("Routing has been saved as a track in the 'Route and "
          "Mark' Manager\n"),
        _("Weather Routing"), wxOK);
    mdlg.ShowModal();
  }



void WeatherRouting::SaveAsRoute(RouteMapOverlay & routemapoverlay) {
    std::list<PlotData> plotdata = routemapoverlay.GetPlotData(false);

    if (plotdata.empty()) {
      wxMessageDialog mdlg(this, _("Empty routing, nothing to save\n"),
                           _("Weather Routing"), wxOK | wxICON_WARNING);
      mdlg.ShowModal();
      return;
    }

    PlugIn_Route_Ex* newRoute = new PlugIn_Route_Ex();
    wxDateTime display_time = routemapoverlay.StartTime();
    if (GetSettingsDialog().m_cbUseLocalTime->GetValue())
      display_time = display_time.FromUTC();

    newRoute->m_NameString =
        _("Weather Route ") + " (" + display_time.Format("%x %H:%M") + ")";

    RouteMapConfiguration c = routemapoverlay.GetConfiguration();
    newRoute->m_StartString = c.Start;
    newRoute->m_EndString = c.End;
    newRoute->m_isVisible = true;
    newRoute->m_GUID = GetNewGUID();

    for (auto const& it : plotdata) {
      PlugIn_Waypoint_Ex* newPoint = new PlugIn_Waypoint_Ex(
          it.lat, heading_resolve(it.lon), "circle", _("Weather Route Point"));
      // newPoint->m_PlannedSpeed = it.sog;
      newPoint->m_CreateTime = it.time;
      newRoute->pWaypointList->Append(newPoint);
    }

// last point, missing if config didn't succeed
    const Position* p = routemapoverlay.GetDestinationPosition();
    if (p) {
      PlugIn_Waypoint_Ex* newPoint =
          new PlugIn_Waypoint_Ex(p->lat, heading_resolve(p->lon), "circle",
                                 _("Weather Route Destination"));
      newPoint->m_CreateTime = routemapoverlay.EndTime();
      newRoute->pWaypointList->Append(newPoint);
    }


    AddPlugInRouteEx(newRoute);
    // Clean up waypoint list (ownership transferred to OpenCPN)
    newRoute->pWaypointList->DeleteContents(true);
    newRoute->pWaypointList->Clear();

    delete newRoute;

    GetParent()->Refresh();

    wxMessageDialog mdlg(
        this,
        _("Routing has been saved as a route in the 'Route and "
          "Mark' Manager\n"),
        _("Weather Routing"), wxOK);
    mdlg.ShowModal();
  }



void WeatherRouting::SaveSimplifiedRoute(
        RouteMapOverlay& routemapoverlay,
        const std::list<Position*>& simplifiedRoute) {
  if (simplifiedRoute.empty()) return;

  // Create a new OpenCPN route
  PlugIn_Route* newRoute = new PlugIn_Route();

  // Set route name
  RouteMapConfiguration config = routemapoverlay.GetConfiguration();
  wxString name = wxString::Format("Simplified %s to %s", config.Start.c_str(),
                                   config.End.c_str());
  newRoute->m_NameString = name;
  newRoute->m_GUID = wxString::Format("%i", (int)GetRandomNumber(1, 4000000));

  // Add waypoints
  for (Position* pos : simplifiedRoute) {
    PlugIn_Waypoint* waypoint = new PlugIn_Waypoint();
    waypoint->m_lat = pos->lat;
    waypoint->m_lon = pos->lon;
    waypoint->m_GUID = wxString::Format("%i", (int)GetRandomNumber(1, 4000000));
    waypoint->m_IconName = "circle";
    waypoint->m_MarkName =
        wxString::Format("WP%03d", newRoute->pWaypointList->GetCount() + 1);

    // Try to add time information if available
    std::list<PlotData> plotData = routemapoverlay.GetPlotData(false);
    if (!plotData.empty()) {
      // Find the closest plot data point to this position
      PlotData* closestData = nullptr;
      double minDistance = INFINITY;

      for (auto& data : plotData) {
        double dist =
            DistGreatCircle_Plugin(pos->lat, pos->lon, data.lat, data.lon);
        if (dist < minDistance) {
          minDistance = dist;
          closestData = &data;
        }
      }

      if (closestData && minDistance < 0.1) {  // Within 0.1 nm
        // Add time information to waypoint description
        wxDateTime time = closestData->time;
        if (GetSettingsDialog().m_cbUseLocalTime->GetValue())
          time = time.FromUTC();

        waypoint->m_MarkDescription = time.Format("%x %H:%M");

        // Optionally add other information (wind, etc.)
        waypoint->m_MarkDescription += wxString::Format(
            "\nWind: %.1f kts at %.0f\u00B0", closestData->twsOverWater,
            closestData->twdOverWater);

        waypoint->m_MarkDescription +=
            wxString::Format("\nBoat: %.1f kts at %.0f\u00B0", closestData->stw,
                             closestData->ctw);
      }
    }
    // Add to route
    newRoute->pWaypointList->Append(waypoint);
  }
  // Add route to OpenCPN
  AddPlugInRoute(newRoute);
  RequestRefresh(GetParent());
}


/*********************************************************/
/*    15. UI Update Pipeline (Unified, Deterministic   */
/*********************************************************/


/*
Update, RebuidList  Reset(overlay)- Key Roles
Reset(overlay)
    Clears the a RouteMapOverlay state
ResetSelected()
    Stops and clears only the selected RouteMapOverlay   objects, then
    updates their states in the UI.
ResetAll ()
    Stops and clears all RouteMapOverlay objects,
    then updates their states in the UI.
OnResetSelected()
    The event handler that calls ResetSelected().
OnSaveAsTrack()
    is the event handler that saves the selected routes as tracks.
ShowRouteSaveOptionsDialog()
   Shows a dialog to get route saving   options from the user.
OnSaveAsRoute()
   Event handler that saves the selected routes as routes. T
UI Related Functions:
   RefreshUI()
      refreshes the entire UI, including list controls and dialogs
   UpdateStates()
      walks all WeatherRoute objects, calls WeatherRoute::Update(stateonly=true),
      updates the list control row RebuidList()
      rebuilds the entire wxListCtrl that displays all routes.
      Heavier than UpdateStates()
   Rebuild
      also repopulates the whole table,refreshes the UI UpdateRouteMap(overlay)
      updates only the specified  RouteMapOverlay   */


//------------------------------------------
//   15.1 Core
//------------------------------------------
// UpdateStates
//   Walks all WeatherRoute objects, checks their associated
//   RouteMapOverlay state, updates WeatherRoute fields,
//   and refreshes the corresponding wxListCtrl row if needed.
// UpdateDialogs
//   Updates all open dialogs (Statistics, Report, Plot)
//   with the current RouteMapOverlay data.
// UpdateComputeState
//   Updates the Compute button, Stop button, progress bar,
//   and status text based on the current state of all
//   RouteMapOverlay objects.
// UpdateCurrentConfigurations
//   Updates the current configuration display based on the
//   first selected RouteMapOverlay (if any).
// SetEnableConfigurationMenu
//   Enables or disables the configuration menu based on
//   whether any RouteMapOverlay objects are selected.
// RefreshUI
//   The main UI refresh pipeline that calls UpdateStates(),
//   UpdateDialogs, and UpdateComputeState.

void WeatherRouting::UpdateStates() {
  int index = 0;

  for (auto* wr : m_WeatherRoutes) {
    RouteMapOverlay* ov = wr->routemapoverlay;

    bool changed = false;
    wxString newState;

    // Snapshot overlay state for logging
    const bool hasOverlay = (ov != nullptr);
    const bool isDirty = hasOverlay && ov->IsDirty();
    const bool hasThread = hasOverlay && ov->HasThread();
    const bool finished = hasOverlay && ov->Finished();
    const bool reachedDest = hasOverlay && ov->ReachedDestination();
    const bool stopped = hasOverlay && ov->m_Stopped;

    // --- 1. Determine the new state --------------------
    if (!hasOverlay) {
      newState = _("Not Computed");
    } else if (isDirty) {
      newState = _("Ready");
      // Clear the dirty flag once we?ve consumed it
      ov->ClearDirty();
      changed = true;
    } else if (hasThread) {
      newState = _("Computing");
    } else if (finished && reachedDest) {
      newState = _("Complete");
    } else if (finished) {
      newState = _("Ready");
    } else {
      newState = _("Not Computed");
    }

    // --- 2. Update the model if the state changed ------
    if (wr->State != newState) {
      wxLogMessage(
          "WeatherRouting::UpdateStates route %d: '%s' -> '%s' "
          "(hasOverlay=%d, dirty=%d, hasThread=%d, finished=%d, "
          "reachedDest=%d, stopped=%d)",
          index, wr->State.mb_str(), newState.mb_str(), hasOverlay, isDirty,
          hasThread, finished, reachedDest, stopped);

      wr->State = newState;
      wr->StateChanged = true;
      changed = true;
    }

    // --- 3. Update other columns (distance, ETA, etc.) -----
    wr->Update(this, changed);

    // --- 4. Refresh the UI row only if something changed --
    if (changed) {
      UpdateItem(index, true);

      wxLogMessage(
          "WeatherRouting::UpdateStates route %d: UI row refreshed "
          "(StateChanged=%d)",
          index, wr->StateChanged ? 1 : 0);
    }

    // Reset per-iteration flag
    wr->StateChanged = false;
    index++;
  }
}


void WeatherRouting::UpdateDialogs() {
  if (m_shuttingDown)
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
     return;
  // ---------------------------------------------------------------------
  // 1. Collect overlays for all *selected* WeatherRoutes
  // ---------------------------------------------------------------------
  std::list<RouteMapOverlay*> overlays;

  long item = -1;
  while (true) {
    item = m_panel->m_lWeatherRoutes->GetNextItem(item, wxLIST_NEXT_ALL,
                                                  wxLIST_STATE_SELECTED);

    if (item < 0) break;

    WeatherRoute* wr = reinterpret_cast<WeatherRoute*>(
        wxUIntToPtr(m_panel->m_lWeatherRoutes->GetItemData(item)));

    if (wr && wr->routemapoverlay) overlays.push_back(wr->routemapoverlay);
  }

  // ---------------------------------------------------------------------
  // 2. Statistics Dialog
  // ---------------------------------------------------------------------
  if (m_StatisticsDialog.IsShown()) {
    m_StatisticsDialog.SetRouteMapOverlays(overlays);
    m_StatisticsDialog.Refresh();
  }

  // ---------------------------------------------------------------------
  // 3. Report Dialog
  // ---------------------------------------------------------------------
  if (m_ReportDialog.IsShown()) {
    m_ReportDialog.SetRouteMapOverlays(overlays);
    m_ReportDialog.Refresh();
  }

  // ---------------------------------------------------------------------
  // 4. Plot Dialog (uses only the first selected overlay)
  // ---------------------------------------------------------------------
  if (m_PlotDialog.IsShown()) {
    RouteMapOverlay* first = overlays.empty() ? nullptr : overlays.front();

    m_PlotDialog.SetRouteMapOverlay(first);
    m_PlotDialog.Refresh();
  }
}

void WeatherRouting::UpdateComputeState() {
  if (m_shuttingDown)
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
      return;

  // Count how many overlays are in each state
  int computing = 0;
  int ready = 0;
  int notComputed = 0;
  int complete = 0;

  for (auto* wr : m_WeatherRoutes) {
    RouteMapOverlay* ov = wr->routemapoverlay;

    if (!ov) {
      notComputed++;
      continue;
    }

    if (ov->HasThread()) {
      computing++;
    } else if (ov->Finished() && ov->ReachedDestination()) {
      complete++;
    } else if (ov->Finished()) {
      ready++;
    } else {
      notComputed++;
    }
  }

  // --- Compute button logic ---
  // Enabled when at least one route is Ready or Not Computed
  bool canCompute = (ready > 0 || notComputed > 0);
  m_panel->m_bCompute->Enable(canCompute);

  // --- Stop button logic ---
  // Enabled when at least one route is actively computing
  bool canStop = (computing > 0);
  // m_panel->m_bStop->Enable(canStop);
  m_panel->SetStopButtonEnabled(canStop);

  // --- Progress bar ---
  int total = m_WeatherRoutes.size();
  int done = complete + ready;

  m_panel->m_gProgress->SetRange(total);
  m_panel->m_gProgress->SetValue(done);

  // --- Status text ---
  wxString status;

  if (computing > 0)
    status = _("Computing routes?");
  else if (complete > 0)
    status = _("Routes computed");
  else if (ready > 0)
    status = _("Ready");
  else
    status = _("Not computed");

  // m_panel->m_tStatus->SetLabel(status);
  m_panel->SetStatusText(status);
}


void WeatherRouting::UpdateCurrentConfigurations() {
  wxLogMessage("WeatherRouting::UpdateCurrentConfigurations()");

  if (m_panel && m_panel->m_lWeatherRoutes) {
    m_panel->m_lWeatherRoutes->DeleteAllItems();

    long index = 0;
    for (auto* wr : m_WeatherRoutes) {
      wxListItem item;
      item.SetId(index);
      item.SetData(reinterpret_cast<wxUIntPtr>(wr));
      m_panel->m_lWeatherRoutes->InsertItem(item);
      UpdateItem(index, true);
      index++;
    }
  }

  SetEnableConfigurationMenu();
  UpdateAllItems(true);
  UpdateDialogs();
  UpdateComputeState();

  if (GetParent()) GetParent()->Refresh();
}


void WeatherRouting::RefreshUI() {
  // ============================================================
  // 0. Sanity check: Ensure we have a panel and list control to refresh
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;  // nothing to refresh yet

  // 1. Refresh the entire routing table
  //
  // UpdateAllItems(true) forces a full table refresh:
  //   - Re-runs WeatherRoute::Update() for every route
  //   - Rewrites all columns (State, Start Type, times, metrics)
  //   - Ensures the list control stays consistent after any change
  //
  // This replaces the old UpdateStates(), which is now obsolete.
  // ============================================================
  UpdateAllItems(true);

  // ============================================================
  // 2. Update all open dialogs (Statistics, Report, Plot)
  //
  // These dialogs are read-only views of the current overlays.
  // They must be refreshed whenever the routing model changes.
  // ============================================================
  UpdateDialogs();

  // ============================================================
  // 3. Update compute-state UI
  //
  // This updates:
  //   - Compute button enable state
  //   - Stop button enable state
  //   - Progress bar
  //   - Status text ("Ready", "Computing routes?", etc.)
  //
  // This keeps the control panel in sync with the routing engine.
  // ============================================================
  UpdateComputeState();

  // ============================================================
  // 4. Refresh the main panel (list control + controls)
  //
  // Ensures the list control and panel repaint immediately.
  // ============================================================
  if (m_panel) m_panel->Refresh();

  // ============================================================
  // 5. Refresh the Routing Table panel (if present)
  //
  // This is the detailed per-isochron table. It must be updated
  // whenever the routing model changes.
  // ============================================================
  if (m_RoutingTablePanel) {
    ((RoutingTablePanel*)m_RoutingTablePanel)->PopulateTable();
  }

  // ============================================================
  // 6. Trigger a parent window refresh
  //
  // Forces the chart canvas to redraw, ensuring overlays,
  // tracks, and route lines reflect the latest state.
  // ============================================================
  if (GetParent()) GetParent()->Refresh();
}



//------------------------------------------
//   15.2 Per?Route
//------------------------------------------

/* THE HEART OF THE WEATHER ROUTING ENGINE                         *
 * Promotes overelays from waiting to running, checks for completed threads *
 * Starts new worker threads as needed Monitors thread completion *
 * Requests Grib data as needed for running threads         *
 * Updates UI state as needed                         *
 * Refreshes  dialogs, route map dislay and statistics periodically      *
 * Detects when all routes are finished, stops the timer cleanly      *
 * Runs the scheduler, moves routes between lists, checks thread progress.
 * Scheduler purely a state machine, not an owner of thread lifetime. *
 * Everything else ? OnCompute(), StartCompute(), StopAll(), UpdateStates(),
 * even AddConfiguration() ? exists to feed this scheduler.
 * Without OnComputationTimer, no routing computations occur
 *.and the plugin is just a static UI
 * Don't call this directly, use StartCompute() to begin computations *
 * Don't screw with the lists while this is running.
 * Keeps the UI updated as routes progress.
 * UI updates are deterministic and centralized here.
 * Everything else just marks overlays dirty and lets this
 * scheduler handle the rest.
 * Don't call UpdateRouteMap() directly, it's called from here as needed.
 * Keeps the UI in sync with the model.
 */ 

// UpdateRouteMap
//   Updates only the specified RouteMapOverlay in the wxListCtrl.
//   Called when a RouteMapOverlay changes state or completes computation.
//   Efficient targeted update to keep the UI in sync with the model.
//   Does not rebuild the entire list, only the affected row.
//   Used by the computation scheduler to refresh the UI as routes progress.
//   Searches for the WeatherRoute associated with the given RouteMapOverlay,
//   then calls UpdateItem() to refresh that row in the wxListCtrl.
//   If the RouteMapOverlay is not found, does nothing.
//   This function is more efficient than UpdateAllItems() when only one
//   route needs to be updated.
//   Note: This function assumes that each RouteMapOverlay is unique
//   and associated with only one WeatherRoute.
// 
// UpdateItem  See 9.WeatherRoute::Update(Model Update Logic
//   Updates a single row in the wxListCtrl based on the WeatherRoute data.
// UpdateAllItems
//   Updates all rows in the wxListCtrl.
// UpdateSelectedItem
//   Updates only the selected rows in the wxListCtrl.
//------------------------------------------


// This is the OLDER CODE - DO NOT USE, has one parameter less than needed
// void WeatherRoute::Update(WeatherRouting* wr) { State = ComputeStateString();
//}


void WeatherRouting::UpdateRouteMap(RouteMapOverlay* routemapoverlay) {
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* lc = m_panel->m_lWeatherRoutes;

  for (int i = 0; i < lc->GetItemCount(); i++) {
    WeatherRoute* weatherroute =
        reinterpret_cast<WeatherRoute*>(wxUIntToPtr(lc->GetItemData(i)));

    if (weatherroute && weatherroute->routemapoverlay == routemapoverlay) {
      weatherroute->Update(this, false);  // modern call
      UpdateItem(i, false);               // fast UI refresh
      return;
    }
  }
}



void WeatherRouting::UpdateAllItems(bool changed) {
  if (m_shuttingDown)
    wxLogMessage("IGNORED CALLBACK: %s during shutdown", __FUNCTION__);
    return;
  if (m_WeatherRoutes.empty()) return;
  if (!m_panel || !m_panel->m_lWeatherRoutes) return;

  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  lc->Freeze();

  int index = 0;
  for (auto it = m_WeatherRoutes.begin(); it != m_WeatherRoutes.end();
       ++it, ++index) {
    UpdateItem(index, changed);
  }

  if (changed) {
    for (int c = 0; c < NUM_COLS; c++) {
      if (columns[c] >= 0) lc->SetColumnWidth(columns[c], wxLIST_AUTOSIZE);
    }
  }

  lc->Thaw();
}



void WeatherRouting::UpdateSelectedItems(bool changed) {
  wxListCtrl* lc = m_panel->m_lWeatherRoutes;
  if (!lc) return;

  long item = -1;

  // Iterate through all selected rows
  for (;;) {
    item = lc->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
    if (item == -1) break;

    // Update the selected row
    UpdateItem(item, changed);
  }
}


//------------------------------------------
//   15.3 Column Helpers
//------------------------------------------
// SetColumn
//   Sets the text of a specific column in the wxListCtrl for a given row.
// ClearComputedColumns
//   Clears all computed columns for a given row in the wxListCtrl.
// UpdateStaticColumns
//   Updates the static columns (Boat, StartType, Start, End, Visible) for
//   a given row based on the WeatherRoute data.
// UpdateComputedColumns
//   Updates the computed columns (AvgSpeed, MaxSpeed, etc.) for a given row
//   based on the WeatherRoute data.
//------------------------------------------


void WeatherRouting::SetColumn(long index, int col, const wxString& value) {
  if (columns[col] >= 0)
    m_panel->m_lWeatherRoutes->SetItem(index, columns[col], value);
}

void WeatherRouting::ClearComputedColumns(long index) {
  SetColumn(index, STARTTIME, "");
  SetColumn(index, ENDTIME, "");
  SetColumn(index, TIME, "");  // ? FIXED
  SetColumn(index, DISTANCE, "");
  SetColumn(index, AVGSPEED, "");
  SetColumn(index, MAXSPEED, "");
  SetColumn(index, AVGSPEEDGROUND, "");
  SetColumn(index, MAXSPEEDGROUND, "");
  SetColumn(index, AVGWIND, "");
  SetColumn(index, MAXWIND, "");
  SetColumn(index, MAXWINDGUST, "");
  SetColumn(index, AVGCURRENT, "");
  SetColumn(index, MAXCURRENT, "");
  SetColumn(index, AVGSWELL, "");
  SetColumn(index, MAXSWELL, "");
  SetColumn(index, UPWINDPERCENTAGE, "");
  SetColumn(index, PORTSTARBOARD, "");
  SetColumn(index, TACKS, "");
  SetColumn(index, JIBES, "");
  SetColumn(index, SAILPLANCHANGES, "");
  SetColumn(index, COMFORT, "");
}

// UpdateStaticColumns sets the non-computed columns based on the WeatherRoute
// data. These columns typically include information that doesn't change during
// computation, This includes the boat name, start type, start and end
// locations, and visibility. This function is called when a new route is added
// or when the static information of a route changes. It ensures that the UI
// reflects the current state of the WeatherRoute's static properties.
void WeatherRouting::UpdateStaticColumns(long index, WeatherRoute* wr) {
  // Visible icon
  if (columns[VISIBLE] >= 0)
    m_panel->m_lWeatherRoutes->SetItemImage(
        index, wr->routemapoverlay->m_bEndRouteVisible ? 0 : -1);

  SetColumn(index, BOAT, wxFileName(wr->BoatFilename).GetName());
  SetColumn(index, STARTTYPE, wr->StartType);
  SetColumn(index, START, wr->Start);
  SetColumn(index, END, wr->End);
}

void WeatherRouting::UpdateComputedColumns(long index, WeatherRoute* wr) {
  SetColumn(index, AVGSPEED, wr->AvgSpeed);
  SetColumn(index, MAXSPEED, wr->MaxSpeed);
  SetColumn(index, AVGSPEEDGROUND, wr->AvgSpeedGround);
  SetColumn(index, MAXSPEEDGROUND, wr->MaxSpeedGround);
  SetColumn(index, AVGWIND, wr->AvgWind);
  SetColumn(index, MAXWIND, wr->MaxWind);
  SetColumn(index, MAXWINDGUST, wr->MaxWindGust);
  SetColumn(index, AVGCURRENT, wr->AvgCurrent);
  SetColumn(index, MAXCURRENT, wr->MaxCurrent);
  SetColumn(index, AVGSWELL, wr->AvgSwell);
  SetColumn(index, MAXSWELL, wr->MaxSwell);
  SetColumn(index, UPWINDPERCENTAGE, wr->UpwindPercentage);
  SetColumn(index, PORTSTARBOARD, wr->PortStarboard);
  SetColumn(index, TACKS, wr->Tacks);
  SetColumn(index, JIBES, wr->Jibes);
  SetColumn(index, SAILPLANCHANGES, wr->SailPlanChanges);
  SetColumn(index, COMFORT, wr->Comfort);
}


//------------------------------------------
//   16. Miscellaneous UI
//------------------------------------------
// Show
//   Shows or hides all plugin dialogs and menu items.
//   When hiding, saves the current visibility state of each dialog.
//   When showing, restores each dialog to its previous visibility state.
//   Also hides the routing table panel if it exists.
//   Returns the result of the base class Show() method.
// CopyDataFiles
//   Recursively copies data files from one directory to another.
//   Takes care to create destination directories as needed.
//   maintains the directory structure.
//   and logs each file copy operation.
// StopAllRoutes -deprecated-
//   Stops all active route computations.
//------------------------------------------

bool WeatherRouting::Show(bool show) {
  m_weather_routing_pi.ShowMenuItems(show);

if (show) {
    m_ConfigurationDialog.Show(m_bShowConfiguration);
    m_ConfigurationBatchDialog.Show(m_bShowConfigurationBatch);
    m_SettingsDialog.Show(m_bShowSettings);
    m_StatisticsDialog.Show(m_bShowStatistics);
    m_ReportDialog.Show(m_bShowReport);
    m_PlotDialog.Show(m_bShowPlot);
    m_FilterRoutesDialog.Show(m_bShowFilter);
    m_RoutePositionDialog.Show(m_bShowRoutePosition);
  } else {
    // Save + hide dialogs
    m_bShowConfiguration = m_ConfigurationDialog.IsShown();
    m_ConfigurationDialog.Hide();

    m_bShowConfigurationBatch = m_ConfigurationBatchDialog.IsShown();
    m_ConfigurationBatchDialog.Hide();

    m_bShowSettings = m_SettingsDialog.IsShown();
    m_SettingsDialog.Hide();

    m_bShowStatistics = m_StatisticsDialog.IsShown();
    m_StatisticsDialog.Hide();

    m_bShowReport = m_ReportDialog.IsShown();
    m_ReportDialog.Hide();

    m_bShowPlot = m_PlotDialog.IsShown();
    m_PlotDialog.Hide();

    m_bShowFilter = m_FilterRoutesDialog.IsShown();
    m_FilterRoutesDialog.Hide();

    m_bShowRoutePosition = m_RoutePositionDialog.IsShown();
    m_RoutePositionDialog.Hide();

    // Do NOT touch AUI panes here. // AUI owns visibility of the
    // RoutingTablePanel.
    // Hide routing table panel
  //  if (m_RoutingTablePanel) {
  //    wxAuiManager* mgr = ::GetFrameAuiManager();
  //    wxAuiPaneInfo& pane = mgr->GetPane(m_RoutingTablePanel);
  //    if (pane.IsOk() && pane.IsShown()) pane.Hide();
  //    mgr->Update();
  //  }

  }
  return WeatherRoutingBase::Show(show);
}



void WeatherRouting::CopyDataFiles(wxString from, wxString to) {
  if (from[from.Len() - 1] != '\\' && from[from.Len() - 1] != '/')
    from += wxFILE_SEP_PATH;
  if (to[to.Len() - 1] != '\\' && to[to.Len() - 1] != '/')
    to += wxFILE_SEP_PATH;

  if (!wxDirExists(to))
    wxFileName::Mkdir(to, wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL);

  wxDir dir(from);
  wxString next = wxEmptyString;
  bool b = dir.GetFirst(&next);
  while (b) {
    const wxString fileFrom = from + next;
    const wxString fileTo = to + next;
    if (wxDirExists(fileFrom))
      CopyDataFiles(fileFrom, fileTo);
    else {
      wxLogMessage("WeatherRouting copy file: " + fileFrom + " to " + fileTo);
      wxCopyFile(fileFrom, fileTo);
    }
    b = dir.GetNext(&next);
  }
}


/* ************************************************************************
 *   End of WeatherRouting.cpp
 * ***********************************************************************
 */
